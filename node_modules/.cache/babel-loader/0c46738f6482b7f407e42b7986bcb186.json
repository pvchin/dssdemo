{"ast":null,"code":"/*!\n * Globalize\n *\n * http://github.com/jquery/globalize\n *\n * Copyright Software Freedom Conservancy, Inc.\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n */\n(function (window, undefined) {\n  var Globalize, // private variables\n  regexHex, regexInfinity, regexParseFloat, regexTrim, // private JavaScript utility functions\n  arrayIndexOf, endsWith, extend, isArray, isFunction, isObject, startsWith, trim, truncate, zeroPad, // private Globalization utility functions\n  appendPreOrPostMatch, expandFormat, formatDate, formatNumber, getTokenRegExp, getEra, getEraYear, parseExact, parseNegativePattern; // Global variable (Globalize) or CommonJS module (globalize)\n\n  Globalize = function (cultureSelector) {\n    return new Globalize.prototype.init(cultureSelector);\n  };\n\n  if (typeof require !== \"undefined\" && typeof exports !== \"undefined\" && typeof module !== \"undefined\") {\n    // Assume CommonJS\n    module.exports = Globalize;\n  } else {\n    // Export as global variable\n    window.Globalize = Globalize;\n  }\n\n  Globalize.cultures = {};\n  Globalize.prototype = {\n    constructor: Globalize,\n    init: function (cultureSelector) {\n      this.cultures = Globalize.cultures;\n      this.cultureSelector = cultureSelector;\n      return this;\n    }\n  };\n  Globalize.prototype.init.prototype = Globalize.prototype; // 1. When defining a culture, all fields are required except the ones stated as optional.\n  // 2. Each culture should have a \".calendars\" object with at least one calendar named \"standard\"\n  //    which serves as the default calendar in use by that culture.\n  // 3. Each culture should have a \".calendar\" object which is the current calendar being used,\n  //    it may be dynamically changed at any time to one of the calendars in \".calendars\".\n\n  Globalize.cultures[\"default\"] = {\n    // A unique name for the culture in the form <language code>-<country/region code>\n    name: \"en\",\n    // the name of the culture in the english language\n    englishName: \"English\",\n    // the name of the culture in its own language\n    nativeName: \"English\",\n    // whether the culture uses right-to-left text\n    isRTL: false,\n    // \"language\" is used for so-called \"specific\" cultures.\n    // For example, the culture \"es-CL\" means \"Spanish, in Chili\".\n    // It represents the Spanish-speaking culture as it is in Chili,\n    // which might have different formatting rules or even translations\n    // than Spanish in Spain. A \"neutral\" culture is one that is not\n    // specific to a region. For example, the culture \"es\" is the generic\n    // Spanish culture, which may be a more generalized version of the language\n    // that may or may not be what a specific culture expects.\n    // For a specific culture like \"es-CL\", the \"language\" field refers to the\n    // neutral, generic culture information for the language it is using.\n    // This is not always a simple matter of the string before the dash.\n    // For example, the \"zh-Hans\" culture is netural (Simplified Chinese).\n    // And the \"zh-SG\" culture is Simplified Chinese in Singapore, whose lanugage\n    // field is \"zh-CHS\", not \"zh\".\n    // This field should be used to navigate from a specific culture to it's\n    // more general, neutral culture. If a culture is already as general as it\n    // can get, the language may refer to itself.\n    language: \"en\",\n    // numberFormat defines general number formatting rules, like the digits in\n    // each grouping, the group separator, and how negative numbers are displayed.\n    numberFormat: {\n      // [negativePattern]\n      // Note, numberFormat.pattern has no \"positivePattern\" unlike percent and currency,\n      // but is still defined as an array for consistency with them.\n      //   negativePattern: one of \"(n)|-n|- n|n-|n -\"\n      pattern: [\"-n\"],\n      // number of decimal places normally shown\n      decimals: 2,\n      // string that separates number groups, as in 1,000,000\n      \",\": \",\",\n      // string that separates a number from the fractional portion, as in 1.99\n      \".\": \".\",\n      // array of numbers indicating the size of each number group.\n      // TODO: more detailed description and example\n      groupSizes: [3],\n      // symbol used for positive numbers\n      \"+\": \"+\",\n      // symbol used for negative numbers\n      \"-\": \"-\",\n      // symbol used for NaN (Not-A-Number)\n      \"NaN\": \"NaN\",\n      // symbol used for Negative Infinity\n      negativeInfinity: \"-Infinity\",\n      // symbol used for Positive Infinity\n      positiveInfinity: \"Infinity\",\n      percent: {\n        // [negativePattern, positivePattern]\n        //   negativePattern: one of \"-n %|-n%|-%n|%-n|%n-|n-%|n%-|-% n|n %-|% n-|% -n|n- %\"\n        //   positivePattern: one of \"n %|n%|%n|% n\"\n        pattern: [\"-n %\", \"n %\"],\n        // number of decimal places normally shown\n        decimals: 2,\n        // array of numbers indicating the size of each number group.\n        // TODO: more detailed description and example\n        groupSizes: [3],\n        // string that separates number groups, as in 1,000,000\n        \",\": \",\",\n        // string that separates a number from the fractional portion, as in 1.99\n        \".\": \".\",\n        // symbol used to represent a percentage\n        symbol: \"%\"\n      },\n      currency: {\n        // [negativePattern, positivePattern]\n        //   negativePattern: one of \"($n)|-$n|$-n|$n-|(n$)|-n$|n-$|n$-|-n $|-$ n|n $-|$ n-|$ -n|n- $|($ n)|(n $)\"\n        //   positivePattern: one of \"$n|n$|$ n|n $\"\n        pattern: [\"($n)\", \"$n\"],\n        // number of decimal places normally shown\n        decimals: 2,\n        // array of numbers indicating the size of each number group.\n        // TODO: more detailed description and example\n        groupSizes: [3],\n        // string that separates number groups, as in 1,000,000\n        \",\": \",\",\n        // string that separates a number from the fractional portion, as in 1.99\n        \".\": \".\",\n        // symbol used to represent currency\n        symbol: \"$\"\n      }\n    },\n    // calendars defines all the possible calendars used by this culture.\n    // There should be at least one defined with name \"standard\", and is the default\n    // calendar used by the culture.\n    // A calendar contains information about how dates are formatted, information about\n    // the calendar's eras, a standard set of the date formats,\n    // translations for day and month names, and if the calendar is not based on the Gregorian\n    // calendar, conversion functions to and from the Gregorian calendar.\n    calendars: {\n      standard: {\n        // name that identifies the type of calendar this is\n        name: \"Gregorian_USEnglish\",\n        // separator of parts of a date (e.g. \"/\" in 11/05/1955)\n        \"/\": \"/\",\n        // separator of parts of a time (e.g. \":\" in 05:44 PM)\n        \":\": \":\",\n        // the first day of the week (0 = Sunday, 1 = Monday, etc)\n        firstDay: 0,\n        days: {\n          // full day names\n          names: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n          // abbreviated day names\n          namesAbbr: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n          // shortest day names\n          namesShort: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"]\n        },\n        months: {\n          // full month names (13 months for lunar calendards -- 13th month should be \"\" if not lunar)\n          names: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\", \"\"],\n          // abbreviated month names\n          namesAbbr: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"\"]\n        },\n        // AM and PM designators in one of these forms:\n        // The usual view, and the upper and lower case versions\n        //   [ standard, lowercase, uppercase ]\n        // The culture does not use AM or PM (likely all standard date formats use 24 hour time)\n        //   null\n        AM: [\"AM\", \"am\", \"AM\"],\n        PM: [\"PM\", \"pm\", \"PM\"],\n        eras: [// eras in reverse chronological order.\n        // name: the name of the era in this culture (e.g. A.D., C.E.)\n        // start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era.\n        // offset: offset in years from gregorian calendar\n        {\n          \"name\": \"A.D.\",\n          \"start\": null,\n          \"offset\": 0\n        }],\n        // when a two digit year is given, it will never be parsed as a four digit\n        // year greater than this year (in the appropriate era for the culture)\n        // Set it as a full year (e.g. 2029) or use an offset format starting from\n        // the current year: \"+19\" would correspond to 2029 if the current year 2010.\n        twoDigitYearMax: 2029,\n        // set of predefined date and time patterns used by the culture\n        // these represent the format someone in this culture would expect\n        // to see given the portions of the date that are shown.\n        patterns: {\n          // short date pattern\n          d: \"M/d/yyyy\",\n          // long date pattern\n          D: \"dddd, MMMM dd, yyyy\",\n          // short time pattern\n          t: \"h:mm tt\",\n          // long time pattern\n          T: \"h:mm:ss tt\",\n          // long date, short time pattern\n          f: \"dddd, MMMM dd, yyyy h:mm tt\",\n          // long date, long time pattern\n          F: \"dddd, MMMM dd, yyyy h:mm:ss tt\",\n          // month/day pattern\n          M: \"MMMM dd\",\n          // month/year pattern\n          Y: \"yyyy MMMM\",\n          // S is a sortable format that does not vary by culture\n          S: \"yyyy\\u0027-\\u0027MM\\u0027-\\u0027dd\\u0027T\\u0027HH\\u0027:\\u0027mm\\u0027:\\u0027ss\"\n        } // optional fields for each calendar:\n\n        /*\n        monthsGenitive:\n        \tSame as months but used when the day preceeds the month.\n        \tOmit if the culture has no genitive distinction in month names.\n        \tFor an explaination of genitive months, see http://blogs.msdn.com/michkap/archive/2004/12/25/332259.aspx\n        convert:\n        \tAllows for the support of non-gregorian based calendars. This convert object is used to\n        \tto convert a date to and from a gregorian calendar date to handle parsing and formatting.\n        \tThe two functions:\n        \t\tfromGregorian( date )\n        \t\t\tGiven the date as a parameter, return an array with parts [ year, month, day ]\n        \t\t\tcorresponding to the non-gregorian based year, month, and day for the calendar.\n        \t\ttoGregorian( year, month, day )\n        \t\t\tGiven the non-gregorian year, month, and day, return a new Date() object\n        \t\t\tset to the corresponding date in the gregorian calendar.\n        */\n\n      }\n    },\n    // For localized strings\n    messages: {}\n  };\n  Globalize.cultures[\"default\"].calendar = Globalize.cultures[\"default\"].calendars.standard;\n  Globalize.cultures.en = Globalize.cultures[\"default\"];\n  Globalize.cultureSelector = \"en\"; //\n  // private variables\n  //\n\n  regexHex = /^0x[a-f0-9]+$/i;\n  regexInfinity = /^[+\\-]?infinity$/i;\n  regexParseFloat = /^[+\\-]?\\d*\\.?\\d*(e[+\\-]?\\d+)?$/;\n  regexTrim = /^\\s+|\\s+$/g; //\n  // private JavaScript utility functions\n  //\n\n  arrayIndexOf = function (array, item) {\n    if (array.indexOf) {\n      return array.indexOf(item);\n    }\n\n    for (var i = 0, length = array.length; i < length; i++) {\n      if (array[i] === item) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  endsWith = function (value, pattern) {\n    return value.substr(value.length - pattern.length) === pattern;\n  };\n\n  extend = function () {\n    var options,\n        name,\n        src,\n        copy,\n        copyIsArray,\n        clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false; // Handle a deep copy situation\n\n    if (typeof target === \"boolean\") {\n      deep = target;\n      target = arguments[1] || {}; // skip the boolean and the target\n\n      i = 2;\n    } // Handle case when target is a string or something (possible in deep copy)\n\n\n    if (typeof target !== \"object\" && !isFunction(target)) {\n      target = {};\n    }\n\n    for (; i < length; i++) {\n      // Only deal with non-null/undefined values\n      if ((options = arguments[i]) != null) {\n        // Extend the base object\n        for (name in options) {\n          src = target[name];\n          copy = options[name]; // Prevent never-ending loop\n\n          if (target === copy) {\n            continue;\n          } // Recurse if we're merging plain objects or arrays\n\n\n          if (deep && copy && (isObject(copy) || (copyIsArray = isArray(copy)))) {\n            if (copyIsArray) {\n              copyIsArray = false;\n              clone = src && isArray(src) ? src : [];\n            } else {\n              clone = src && isObject(src) ? src : {};\n            } // Never move original objects, clone them\n\n\n            target[name] = extend(deep, clone, copy); // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            target[name] = copy;\n          }\n        }\n      }\n    } // Return the modified object\n\n\n    return target;\n  };\n\n  isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n\n  isFunction = function (obj) {\n    return Object.prototype.toString.call(obj) === \"[object Function]\";\n  };\n\n  isObject = function (obj) {\n    return Object.prototype.toString.call(obj) === \"[object Object]\";\n  };\n\n  startsWith = function (value, pattern) {\n    return value.indexOf(pattern) === 0;\n  };\n\n  trim = function (value) {\n    return (value + \"\").replace(regexTrim, \"\");\n  };\n\n  truncate = function (value) {\n    if (isNaN(value)) {\n      return NaN;\n    }\n\n    return Math[value < 0 ? \"ceil\" : \"floor\"](value);\n  };\n\n  zeroPad = function (str, count, left) {\n    var l;\n\n    for (l = str.length; l < count; l += 1) {\n      str = left ? \"0\" + str : str + \"0\";\n    }\n\n    return str;\n  }; //\n  // private Globalization utility functions\n  //\n\n\n  appendPreOrPostMatch = function (preMatch, strings) {\n    // appends pre- and post- token match strings while removing escaped characters.\n    // Returns a single quote count which is used to determine if the token occurs\n    // in a string literal.\n    var quoteCount = 0,\n        escaped = false;\n\n    for (var i = 0, il = preMatch.length; i < il; i++) {\n      var c = preMatch.charAt(i);\n\n      switch (c) {\n        case \"\\'\":\n          if (escaped) {\n            strings.push(\"\\'\");\n          } else {\n            quoteCount++;\n          }\n\n          escaped = false;\n          break;\n\n        case \"\\\\\":\n          if (escaped) {\n            strings.push(\"\\\\\");\n          }\n\n          escaped = !escaped;\n          break;\n\n        default:\n          strings.push(c);\n          escaped = false;\n          break;\n      }\n    }\n\n    return quoteCount;\n  };\n\n  expandFormat = function (cal, format) {\n    // expands unspecified or single character date formats into the full pattern.\n    format = format || \"F\";\n    var pattern,\n        patterns = cal.patterns,\n        len = format.length;\n\n    if (len === 1) {\n      pattern = patterns[format];\n\n      if (!pattern) {\n        throw \"Invalid date format string \\'\" + format + \"\\'.\";\n      }\n\n      format = pattern;\n    } else if (len === 2 && format.charAt(0) === \"%\") {\n      // %X escape format -- intended as a custom format string that is only one character, not a built-in format.\n      format = format.charAt(1);\n    }\n\n    return format;\n  };\n\n  formatDate = function (value, format, culture) {\n    var cal = culture.calendar,\n        convert = cal.convert,\n        ret;\n\n    if (!format || !format.length || format === \"i\") {\n      if (culture && culture.name.length) {\n        if (convert) {\n          // non-gregorian calendar, so we cannot use built-in toLocaleString()\n          ret = formatDate(value, cal.patterns.F, culture);\n        } else {\n          var eraDate = new Date(value.getTime()),\n              era = getEra(value, cal.eras);\n          eraDate.setFullYear(getEraYear(value, cal, era));\n          ret = eraDate.toLocaleString();\n        }\n      } else {\n        ret = value.toString();\n      }\n\n      return ret;\n    }\n\n    var eras = cal.eras,\n        sortable = format === \"s\";\n    format = expandFormat(cal, format); // Start with an empty string\n\n    ret = [];\n    var hour,\n        zeros = [\"0\", \"00\", \"000\"],\n        foundDay,\n        checkedDay,\n        dayPartRegExp = /([^d]|^)(d|dd)([^d]|$)/g,\n        quoteCount = 0,\n        tokenRegExp = getTokenRegExp(),\n        converted;\n\n    function padZeros(num, c) {\n      var r,\n          s = num + \"\";\n\n      if (c > 1 && s.length < c) {\n        r = zeros[c - 2] + s;\n        return r.substr(r.length - c, c);\n      } else {\n        r = s;\n      }\n\n      return r;\n    }\n\n    function hasDay() {\n      if (foundDay || checkedDay) {\n        return foundDay;\n      }\n\n      foundDay = dayPartRegExp.test(format);\n      checkedDay = true;\n      return foundDay;\n    }\n\n    function getPart(date, part) {\n      if (converted) {\n        return converted[part];\n      }\n\n      switch (part) {\n        case 0:\n          return date.getFullYear();\n\n        case 1:\n          return date.getMonth();\n\n        case 2:\n          return date.getDate();\n\n        default:\n          throw \"Invalid part value \" + part;\n      }\n    }\n\n    if (!sortable && convert) {\n      converted = convert.fromGregorian(value);\n    }\n\n    for (;;) {\n      // Save the current index\n      var index = tokenRegExp.lastIndex,\n          // Look for the next pattern\n      ar = tokenRegExp.exec(format); // Append the text before the pattern (or the end of the string if not found)\n\n      var preMatch = format.slice(index, ar ? ar.index : format.length);\n      quoteCount += appendPreOrPostMatch(preMatch, ret);\n\n      if (!ar) {\n        break;\n      } // do not replace any matches that occur inside a string literal.\n\n\n      if (quoteCount % 2) {\n        ret.push(ar[0]);\n        continue;\n      }\n\n      var current = ar[0],\n          clength = current.length;\n\n      switch (current) {\n        case \"ddd\": //Day of the week, as a three-letter abbreviation\n\n        case \"dddd\":\n          // Day of the week, using the full name\n          var names = clength === 3 ? cal.days.namesAbbr : cal.days.names;\n          ret.push(names[value.getDay()]);\n          break;\n\n        case \"d\": // Day of month, without leading zero for single-digit days\n\n        case \"dd\":\n          // Day of month, with leading zero for single-digit days\n          foundDay = true;\n          ret.push(padZeros(getPart(value, 2), clength));\n          break;\n\n        case \"MMM\": // Month, as a three-letter abbreviation\n\n        case \"MMMM\":\n          // Month, using the full name\n          var part = getPart(value, 1);\n          ret.push(cal.monthsGenitive && hasDay() ? cal.monthsGenitive[clength === 3 ? \"namesAbbr\" : \"names\"][part] : cal.months[clength === 3 ? \"namesAbbr\" : \"names\"][part]);\n          break;\n\n        case \"M\": // Month, as digits, with no leading zero for single-digit months\n\n        case \"MM\":\n          // Month, as digits, with leading zero for single-digit months\n          ret.push(padZeros(getPart(value, 1) + 1, clength));\n          break;\n\n        case \"y\": // Year, as two digits, but with no leading zero for years less than 10\n\n        case \"yy\": // Year, as two digits, with leading zero for years less than 10\n\n        case \"yyyy\":\n          // Year represented by four full digits\n          part = converted ? converted[0] : getEraYear(value, cal, getEra(value, eras), sortable);\n\n          if (clength < 4) {\n            part = part % 100;\n          }\n\n          ret.push(padZeros(part, clength));\n          break;\n\n        case \"h\": // Hours with no leading zero for single-digit hours, using 12-hour clock\n\n        case \"hh\":\n          // Hours with leading zero for single-digit hours, using 12-hour clock\n          hour = value.getHours() % 12;\n          if (hour === 0) hour = 12;\n          ret.push(padZeros(hour, clength));\n          break;\n\n        case \"H\": // Hours with no leading zero for single-digit hours, using 24-hour clock\n\n        case \"HH\":\n          // Hours with leading zero for single-digit hours, using 24-hour clock\n          ret.push(padZeros(value.getHours(), clength));\n          break;\n\n        case \"m\": // Minutes with no leading zero for single-digit minutes\n\n        case \"mm\":\n          // Minutes with leading zero for single-digit minutes\n          ret.push(padZeros(value.getMinutes(), clength));\n          break;\n\n        case \"s\": // Seconds with no leading zero for single-digit seconds\n\n        case \"ss\":\n          // Seconds with leading zero for single-digit seconds\n          ret.push(padZeros(value.getSeconds(), clength));\n          break;\n\n        case \"t\": // One character am/pm indicator (\"a\" or \"p\")\n\n        case \"tt\":\n          // Multicharacter am/pm indicator\n          part = value.getHours() < 12 ? cal.AM ? cal.AM[0] : \" \" : cal.PM ? cal.PM[0] : \" \";\n          ret.push(clength === 1 ? part.charAt(0) : part);\n          break;\n\n        case \"f\": // Deciseconds\n\n        case \"ff\": // Centiseconds\n\n        case \"fff\":\n          // Milliseconds\n          ret.push(padZeros(value.getMilliseconds(), 3).substr(0, clength));\n          break;\n\n        case \"z\": // Time zone offset, no leading zero\n\n        case \"zz\":\n          // Time zone offset with leading zero\n          hour = value.getTimezoneOffset() / 60;\n          ret.push((hour <= 0 ? \"+\" : \"-\") + padZeros(Math.floor(Math.abs(hour)), clength));\n          break;\n\n        case \"zzz\":\n          // Time zone offset with leading zero\n          hour = value.getTimezoneOffset() / 60;\n          ret.push((hour <= 0 ? \"+\" : \"-\") + padZeros(Math.floor(Math.abs(hour)), 2) + // Hard coded \":\" separator, rather than using cal.TimeSeparator\n          // Repeated here for consistency, plus \":\" was already assumed in date parsing.\n          \":\" + padZeros(Math.abs(value.getTimezoneOffset() % 60), 2));\n          break;\n\n        case \"g\":\n        case \"gg\":\n          if (cal.eras) {\n            ret.push(cal.eras[getEra(value, eras)].name);\n          }\n\n          break;\n\n        case \"/\":\n          ret.push(cal[\"/\"]);\n          break;\n\n        default:\n          throw \"Invalid date format pattern \\'\" + current + \"\\'.\";\n      }\n    }\n\n    return ret.join(\"\");\n  }; // formatNumber\n\n\n  (function () {\n    var expandNumber;\n\n    expandNumber = function (number, precision, formatInfo) {\n      var groupSizes = formatInfo.groupSizes,\n          curSize = groupSizes[0],\n          curGroupIndex = 1,\n          factor = Math.pow(10, precision),\n          rounded = Math.round(number * factor) / factor;\n\n      if (!isFinite(rounded)) {\n        rounded = number;\n      }\n\n      number = rounded;\n      var numberString = number + \"\",\n          right = \"\",\n          split = numberString.split(/e/i),\n          exponent = split.length > 1 ? parseInt(split[1], 10) : 0;\n      numberString = split[0];\n      split = numberString.split(\".\");\n      numberString = split[0];\n      right = split.length > 1 ? split[1] : \"\";\n      var l;\n\n      if (exponent > 0) {\n        right = zeroPad(right, exponent, false);\n        numberString += right.slice(0, exponent);\n        right = right.substr(exponent);\n      } else if (exponent < 0) {\n        exponent = -exponent;\n        numberString = zeroPad(numberString, exponent + 1, true);\n        right = numberString.slice(-exponent, numberString.length) + right;\n        numberString = numberString.slice(0, -exponent);\n      }\n\n      if (precision > 0) {\n        right = formatInfo[\".\"] + (right.length > precision ? right.slice(0, precision) : zeroPad(right, precision));\n      } else {\n        right = \"\";\n      }\n\n      var stringIndex = numberString.length - 1,\n          sep = formatInfo[\",\"],\n          ret = \"\";\n\n      while (stringIndex >= 0) {\n        if (curSize === 0 || curSize > stringIndex) {\n          return numberString.slice(0, stringIndex + 1) + (ret.length ? sep + ret + right : right);\n        }\n\n        ret = numberString.slice(stringIndex - curSize + 1, stringIndex + 1) + (ret.length ? sep + ret : \"\");\n        stringIndex -= curSize;\n\n        if (curGroupIndex < groupSizes.length) {\n          curSize = groupSizes[curGroupIndex];\n          curGroupIndex++;\n        }\n      }\n\n      return numberString.slice(0, stringIndex + 1) + sep + ret + right;\n    };\n\n    formatNumber = function (value, format, culture) {\n      if (!isFinite(value)) {\n        if (value === Infinity) {\n          return culture.numberFormat.positiveInfinity;\n        }\n\n        if (value === -Infinity) {\n          return culture.numberFormat.negativeInfinity;\n        }\n\n        return culture.numberFormat[\"NaN\"];\n      }\n\n      if (!format || format === \"i\") {\n        return culture.name.length ? value.toLocaleString() : value.toString();\n      }\n\n      format = format || \"D\";\n      var nf = culture.numberFormat,\n          number = Math.abs(value),\n          precision = -1,\n          pattern;\n      if (format.length > 1) precision = parseInt(format.slice(1), 10);\n      var current = format.charAt(0).toUpperCase(),\n          formatInfo;\n\n      switch (current) {\n        case \"D\":\n          pattern = \"n\";\n          number = truncate(number);\n\n          if (precision !== -1) {\n            number = zeroPad(\"\" + number, precision, true);\n          }\n\n          if (value < 0) number = \"-\" + number;\n          break;\n\n        case \"N\":\n          formatInfo = nf;\n\n        /* falls through */\n\n        case \"C\":\n          formatInfo = formatInfo || nf.currency;\n\n        /* falls through */\n\n        case \"P\":\n          formatInfo = formatInfo || nf.percent;\n          pattern = value < 0 ? formatInfo.pattern[0] : formatInfo.pattern[1] || \"n\";\n          if (precision === -1) precision = formatInfo.decimals;\n          number = expandNumber(number * (current === \"P\" ? 100 : 1), precision, formatInfo);\n          break;\n\n        default:\n          throw \"Bad number format specifier: \" + current;\n      }\n\n      var patternParts = /n|\\$|-|%/g,\n          ret = \"\";\n\n      for (;;) {\n        var index = patternParts.lastIndex,\n            ar = patternParts.exec(pattern);\n        ret += pattern.slice(index, ar ? ar.index : pattern.length);\n\n        if (!ar) {\n          break;\n        }\n\n        switch (ar[0]) {\n          case \"n\":\n            ret += number;\n            break;\n\n          case \"$\":\n            ret += nf.currency.symbol;\n            break;\n\n          case \"-\":\n            // don't make 0 negative\n            if (/[1-9]/.test(number)) {\n              ret += nf[\"-\"];\n            }\n\n            break;\n\n          case \"%\":\n            ret += nf.percent.symbol;\n            break;\n        }\n      }\n\n      return ret;\n    };\n  })();\n\n  getTokenRegExp = function () {\n    // regular expression for matching date and time tokens in format strings.\n    return /\\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g;\n  };\n\n  getEra = function (date, eras) {\n    if (!eras) return 0;\n    var start,\n        ticks = date.getTime();\n\n    for (var i = 0, l = eras.length; i < l; i++) {\n      start = eras[i].start;\n\n      if (start === null || ticks >= start) {\n        return i;\n      }\n    }\n\n    return 0;\n  };\n\n  getEraYear = function (date, cal, era, sortable) {\n    var year = date.getFullYear();\n\n    if (!sortable && cal.eras) {\n      // convert normal gregorian year to era-shifted gregorian\n      // year by subtracting the era offset\n      year -= cal.eras[era].offset;\n    }\n\n    return year;\n  }; // parseExact\n\n\n  (function () {\n    var expandYear, getDayIndex, getMonthIndex, getParseRegExp, outOfRange, toUpper, toUpperArray;\n\n    expandYear = function (cal, year) {\n      // expands 2-digit year into 4 digits.\n      if (year < 100) {\n        var now = new Date(),\n            era = getEra(now),\n            curr = getEraYear(now, cal, era),\n            twoDigitYearMax = cal.twoDigitYearMax;\n        twoDigitYearMax = typeof twoDigitYearMax === \"string\" ? new Date().getFullYear() % 100 + parseInt(twoDigitYearMax, 10) : twoDigitYearMax;\n        year += curr - curr % 100;\n\n        if (year > twoDigitYearMax) {\n          year -= 100;\n        }\n      }\n\n      return year;\n    };\n\n    getDayIndex = function (cal, value, abbr) {\n      var ret,\n          days = cal.days,\n          upperDays = cal._upperDays;\n\n      if (!upperDays) {\n        cal._upperDays = upperDays = [toUpperArray(days.names), toUpperArray(days.namesAbbr), toUpperArray(days.namesShort)];\n      }\n\n      value = toUpper(value);\n\n      if (abbr) {\n        ret = arrayIndexOf(upperDays[1], value);\n\n        if (ret === -1) {\n          ret = arrayIndexOf(upperDays[2], value);\n        }\n      } else {\n        ret = arrayIndexOf(upperDays[0], value);\n      }\n\n      return ret;\n    };\n\n    getMonthIndex = function (cal, value, abbr) {\n      var months = cal.months,\n          monthsGen = cal.monthsGenitive || cal.months,\n          upperMonths = cal._upperMonths,\n          upperMonthsGen = cal._upperMonthsGen;\n\n      if (!upperMonths) {\n        cal._upperMonths = upperMonths = [toUpperArray(months.names), toUpperArray(months.namesAbbr)];\n        cal._upperMonthsGen = upperMonthsGen = [toUpperArray(monthsGen.names), toUpperArray(monthsGen.namesAbbr)];\n      }\n\n      value = toUpper(value);\n      var i = arrayIndexOf(abbr ? upperMonths[1] : upperMonths[0], value);\n\n      if (i < 0) {\n        i = arrayIndexOf(abbr ? upperMonthsGen[1] : upperMonthsGen[0], value);\n      }\n\n      return i;\n    };\n\n    getParseRegExp = function (cal, format) {\n      // converts a format string into a regular expression with groups that\n      // can be used to extract date fields from a date string.\n      // check for a cached parse regex.\n      var re = cal._parseRegExp;\n\n      if (!re) {\n        cal._parseRegExp = re = {};\n      } else {\n        var reFormat = re[format];\n\n        if (reFormat) {\n          return reFormat;\n        }\n      } // expand single digit formats, then escape regular expression characters.\n\n\n      var expFormat = expandFormat(cal, format).replace(/([\\^\\$\\.\\*\\+\\?\\|\\[\\]\\(\\)\\{\\}])/g, \"\\\\\\\\$1\"),\n          regexp = [\"^\"],\n          groups = [],\n          index = 0,\n          quoteCount = 0,\n          tokenRegExp = getTokenRegExp(),\n          match; // iterate through each date token found.\n\n      while ((match = tokenRegExp.exec(expFormat)) !== null) {\n        var preMatch = expFormat.slice(index, match.index);\n        index = tokenRegExp.lastIndex; // don't replace any matches that occur inside a string literal.\n\n        quoteCount += appendPreOrPostMatch(preMatch, regexp);\n\n        if (quoteCount % 2) {\n          regexp.push(match[0]);\n          continue;\n        } // add a regex group for the token.\n\n\n        var m = match[0],\n            len = m.length,\n            add;\n\n        switch (m) {\n          case \"dddd\":\n          case \"ddd\":\n          case \"MMMM\":\n          case \"MMM\":\n          case \"gg\":\n          case \"g\":\n            add = \"(\\\\D+)\";\n            break;\n\n          case \"tt\":\n          case \"t\":\n            add = \"(\\\\D*)\";\n            break;\n\n          case \"yyyy\":\n          case \"fff\":\n          case \"ff\":\n          case \"f\":\n            add = \"(\\\\d{\" + len + \"})\";\n            break;\n\n          case \"dd\":\n          case \"d\":\n          case \"MM\":\n          case \"M\":\n          case \"yy\":\n          case \"y\":\n          case \"HH\":\n          case \"H\":\n          case \"hh\":\n          case \"h\":\n          case \"mm\":\n          case \"m\":\n          case \"ss\":\n          case \"s\":\n            add = \"(\\\\d\\\\d?)\";\n            break;\n\n          case \"zzz\":\n            add = \"([+-]?\\\\d\\\\d?:\\\\d{2})\";\n            break;\n\n          case \"zz\":\n          case \"z\":\n            add = \"([+-]?\\\\d\\\\d?)\";\n            break;\n\n          case \"/\":\n            add = \"(\\\\/)\";\n            break;\n\n          default:\n            throw \"Invalid date format pattern \\'\" + m + \"\\'.\";\n        }\n\n        if (add) {\n          regexp.push(add);\n        }\n\n        groups.push(match[0]);\n      }\n\n      appendPreOrPostMatch(expFormat.slice(index), regexp);\n      regexp.push(\"$\"); // allow whitespace to differ when matching formats.\n\n      var regexpStr = regexp.join(\"\").replace(/\\s+/g, \"\\\\s+\"),\n          parseRegExp = {\n        \"regExp\": regexpStr,\n        \"groups\": groups\n      }; // cache the regex for this format.\n\n      return re[format] = parseRegExp;\n    };\n\n    outOfRange = function (value, low, high) {\n      return value < low || value > high;\n    };\n\n    toUpper = function (value) {\n      // \"he-IL\" has non-breaking space in weekday names.\n      return value.split(\"\\u00A0\").join(\" \").toUpperCase();\n    };\n\n    toUpperArray = function (arr) {\n      var results = [];\n\n      for (var i = 0, l = arr.length; i < l; i++) {\n        results[i] = toUpper(arr[i]);\n      }\n\n      return results;\n    };\n\n    parseExact = function (value, format, culture) {\n      // try to parse the date string by matching against the format string\n      // while using the specified culture for date field names.\n      value = trim(value);\n      var cal = culture.calendar,\n          // convert date formats into regular expressions with groupings.\n      // use the regexp to determine the input format and extract the date fields.\n      parseInfo = getParseRegExp(cal, format),\n          match = new RegExp(parseInfo.regExp).exec(value);\n\n      if (match === null) {\n        return null;\n      } // found a date format that matches the input.\n\n\n      var groups = parseInfo.groups,\n          era = null,\n          year = null,\n          month = null,\n          date = null,\n          weekDay = null,\n          hour = 0,\n          hourOffset,\n          min = 0,\n          sec = 0,\n          msec = 0,\n          tzMinOffset = null,\n          pmHour = false; // iterate the format groups to extract and set the date fields.\n\n      for (var j = 0, jl = groups.length; j < jl; j++) {\n        var matchGroup = match[j + 1];\n\n        if (matchGroup) {\n          var current = groups[j],\n              clength = current.length,\n              matchInt = parseInt(matchGroup, 10);\n\n          switch (current) {\n            case \"dd\":\n            case \"d\":\n              // Day of month.\n              date = matchInt; // check that date is generally in valid range, also checking overflow below.\n\n              if (outOfRange(date, 1, 31)) return null;\n              break;\n\n            case \"MMM\":\n            case \"MMMM\":\n              month = getMonthIndex(cal, matchGroup, clength === 3);\n              if (outOfRange(month, 0, 11)) return null;\n              break;\n\n            case \"M\":\n            case \"MM\":\n              // Month.\n              month = matchInt - 1;\n              if (outOfRange(month, 0, 11)) return null;\n              break;\n\n            case \"y\":\n            case \"yy\":\n            case \"yyyy\":\n              year = clength < 4 ? expandYear(cal, matchInt) : matchInt;\n              if (outOfRange(year, 0, 9999)) return null;\n              break;\n\n            case \"h\":\n            case \"hh\":\n              // Hours (12-hour clock).\n              hour = matchInt;\n              if (hour === 12) hour = 0;\n              if (outOfRange(hour, 0, 11)) return null;\n              break;\n\n            case \"H\":\n            case \"HH\":\n              // Hours (24-hour clock).\n              hour = matchInt;\n              if (outOfRange(hour, 0, 23)) return null;\n              break;\n\n            case \"m\":\n            case \"mm\":\n              // Minutes.\n              min = matchInt;\n              if (outOfRange(min, 0, 59)) return null;\n              break;\n\n            case \"s\":\n            case \"ss\":\n              // Seconds.\n              sec = matchInt;\n              if (outOfRange(sec, 0, 59)) return null;\n              break;\n\n            case \"tt\":\n            case \"t\":\n              // AM/PM designator.\n              // see if it is standard, upper, or lower case PM. If not, ensure it is at least one of\n              // the AM tokens. If not, fail the parse for this format.\n              pmHour = cal.PM && (matchGroup === cal.PM[0] || matchGroup === cal.PM[1] || matchGroup === cal.PM[2]);\n              if (!pmHour && (!cal.AM || matchGroup !== cal.AM[0] && matchGroup !== cal.AM[1] && matchGroup !== cal.AM[2])) return null;\n              break;\n\n            case \"f\": // Deciseconds.\n\n            case \"ff\": // Centiseconds.\n\n            case \"fff\":\n              // Milliseconds.\n              msec = matchInt * Math.pow(10, 3 - clength);\n              if (outOfRange(msec, 0, 999)) return null;\n              break;\n\n            case \"ddd\": // Day of week.\n\n            case \"dddd\":\n              // Day of week.\n              weekDay = getDayIndex(cal, matchGroup, clength === 3);\n              if (outOfRange(weekDay, 0, 6)) return null;\n              break;\n\n            case \"zzz\":\n              // Time zone offset in +/- hours:min.\n              var offsets = matchGroup.split(/:/);\n              if (offsets.length !== 2) return null;\n              hourOffset = parseInt(offsets[0], 10);\n              if (outOfRange(hourOffset, -12, 13)) return null;\n              var minOffset = parseInt(offsets[1], 10);\n              if (outOfRange(minOffset, 0, 59)) return null;\n              tzMinOffset = hourOffset * 60 + (startsWith(matchGroup, \"-\") ? -minOffset : minOffset);\n              break;\n\n            case \"z\":\n            case \"zz\":\n              // Time zone offset in +/- hours.\n              hourOffset = matchInt;\n              if (outOfRange(hourOffset, -12, 13)) return null;\n              tzMinOffset = hourOffset * 60;\n              break;\n\n            case \"g\":\n            case \"gg\":\n              var eraName = matchGroup;\n              if (!eraName || !cal.eras) return null;\n              eraName = trim(eraName.toLowerCase());\n\n              for (var i = 0, l = cal.eras.length; i < l; i++) {\n                if (eraName === cal.eras[i].name.toLowerCase()) {\n                  era = i;\n                  break;\n                }\n              } // could not find an era with that name\n\n\n              if (era === null) return null;\n              break;\n          }\n        }\n      }\n\n      var result = new Date(),\n          defaultYear,\n          convert = cal.convert;\n      defaultYear = convert ? convert.fromGregorian(result)[0] : result.getFullYear();\n\n      if (year === null) {\n        year = defaultYear;\n      } else if (cal.eras) {\n        // year must be shifted to normal gregorian year\n        // but not if year was not specified, its already normal gregorian\n        // per the main if clause above.\n        year += cal.eras[era || 0].offset;\n      } // set default day and month to 1 and January, so if unspecified, these are the defaults\n      // instead of the current day/month.\n\n\n      if (month === null) {\n        month = 0;\n      }\n\n      if (date === null) {\n        date = 1;\n      } // now have year, month, and date, but in the culture's calendar.\n      // convert to gregorian if necessary\n\n\n      if (convert) {\n        result = convert.toGregorian(year, month, date); // conversion failed, must be an invalid match\n\n        if (result === null) return null;\n      } else {\n        // have to set year, month and date together to avoid overflow based on current date.\n        result.setFullYear(year, month, date); // check to see if date overflowed for specified month (only checked 1-31 above).\n\n        if (result.getDate() !== date) return null; // invalid day of week.\n\n        if (weekDay !== null && result.getDay() !== weekDay) {\n          return null;\n        }\n      } // if pm designator token was found make sure the hours fit the 24-hour clock.\n\n\n      if (pmHour && hour < 12) {\n        hour += 12;\n      }\n\n      result.setHours(hour, min, sec, msec);\n\n      if (tzMinOffset !== null) {\n        // adjust timezone to utc before applying local offset.\n        var adjustedMin = result.getMinutes() - (tzMinOffset + result.getTimezoneOffset()); // Safari limits hours and minutes to the range of -127 to 127.  We need to use setHours\n        // to ensure both these fields will not exceed this range.\tadjustedMin will range\n        // somewhere between -1440 and 1500, so we only need to split this into hours.\n\n        result.setHours(result.getHours() + parseInt(adjustedMin / 60, 10), adjustedMin % 60);\n      }\n\n      return result;\n    };\n  })();\n\n  parseNegativePattern = function (value, nf, negativePattern) {\n    var neg = nf[\"-\"],\n        pos = nf[\"+\"],\n        ret;\n\n    switch (negativePattern) {\n      case \"n -\":\n        neg = \" \" + neg;\n        pos = \" \" + pos;\n\n      /* falls through */\n\n      case \"n-\":\n        if (endsWith(value, neg)) {\n          ret = [\"-\", value.substr(0, value.length - neg.length)];\n        } else if (endsWith(value, pos)) {\n          ret = [\"+\", value.substr(0, value.length - pos.length)];\n        }\n\n        break;\n\n      case \"- n\":\n        neg += \" \";\n        pos += \" \";\n\n      /* falls through */\n\n      case \"-n\":\n        if (startsWith(value, neg)) {\n          ret = [\"-\", value.substr(neg.length)];\n        } else if (startsWith(value, pos)) {\n          ret = [\"+\", value.substr(pos.length)];\n        }\n\n        break;\n\n      case \"(n)\":\n        if (startsWith(value, \"(\") && endsWith(value, \")\")) {\n          ret = [\"-\", value.substr(1, value.length - 2)];\n        }\n\n        break;\n    }\n\n    return ret || [\"\", value];\n  }; //\n  // public instance functions\n  //\n\n\n  Globalize.prototype.findClosestCulture = function (cultureSelector) {\n    return Globalize.findClosestCulture.call(this, cultureSelector);\n  };\n\n  Globalize.prototype.format = function (value, format, cultureSelector) {\n    return Globalize.format.call(this, value, format, cultureSelector);\n  };\n\n  Globalize.prototype.localize = function (key, cultureSelector) {\n    return Globalize.localize.call(this, key, cultureSelector);\n  };\n\n  Globalize.prototype.parseInt = function (value, radix, cultureSelector) {\n    return Globalize.parseInt.call(this, value, radix, cultureSelector);\n  };\n\n  Globalize.prototype.parseFloat = function (value, radix, cultureSelector) {\n    return Globalize.parseFloat.call(this, value, radix, cultureSelector);\n  };\n\n  Globalize.prototype.culture = function (cultureSelector) {\n    return Globalize.culture.call(this, cultureSelector);\n  }; //\n  // public singleton functions\n  //\n\n\n  Globalize.addCultureInfo = function (cultureName, baseCultureName, info) {\n    var base = {},\n        isNew = false;\n\n    if (typeof cultureName !== \"string\") {\n      // cultureName argument is optional string. If not specified, assume info is first\n      // and only argument. Specified info deep-extends current culture.\n      info = cultureName;\n      cultureName = this.culture().name;\n      base = this.cultures[cultureName];\n    } else if (typeof baseCultureName !== \"string\") {\n      // baseCultureName argument is optional string. If not specified, assume info is second\n      // argument. Specified info deep-extends specified culture.\n      // If specified culture does not exist, create by deep-extending default\n      info = baseCultureName;\n      isNew = this.cultures[cultureName] == null;\n      base = this.cultures[cultureName] || this.cultures[\"default\"];\n    } else {\n      // cultureName and baseCultureName specified. Assume a new culture is being created\n      // by deep-extending an specified base culture\n      isNew = true;\n      base = this.cultures[baseCultureName];\n    }\n\n    this.cultures[cultureName] = extend(true, {}, base, info); // Make the standard calendar the current culture if it's a new culture\n\n    if (isNew) {\n      this.cultures[cultureName].calendar = this.cultures[cultureName].calendars.standard;\n    }\n  };\n\n  Globalize.findClosestCulture = function (name) {\n    var match;\n\n    if (!name) {\n      return this.findClosestCulture(this.cultureSelector) || this.cultures[\"default\"];\n    }\n\n    if (typeof name === \"string\") {\n      name = name.split(\",\");\n    }\n\n    if (isArray(name)) {\n      var lang,\n          cultures = this.cultures,\n          list = name,\n          i,\n          l = list.length,\n          prioritized = [];\n\n      for (i = 0; i < l; i++) {\n        name = trim(list[i]);\n        var pri,\n            parts = name.split(\";\");\n        lang = trim(parts[0]);\n\n        if (parts.length === 1) {\n          pri = 1;\n        } else {\n          name = trim(parts[1]);\n\n          if (name.indexOf(\"q=\") === 0) {\n            name = name.substr(2);\n            pri = parseFloat(name);\n            pri = isNaN(pri) ? 0 : pri;\n          } else {\n            pri = 1;\n          }\n        }\n\n        prioritized.push({\n          lang: lang,\n          pri: pri\n        });\n      }\n\n      prioritized.sort(function (a, b) {\n        if (a.pri < b.pri) {\n          return 1;\n        } else if (a.pri > b.pri) {\n          return -1;\n        }\n\n        return 0;\n      }); // exact match\n\n      for (i = 0; i < l; i++) {\n        lang = prioritized[i].lang;\n        match = cultures[lang];\n\n        if (match) {\n          return match;\n        }\n      } // neutral language match\n\n\n      for (i = 0; i < l; i++) {\n        lang = prioritized[i].lang;\n\n        do {\n          var index = lang.lastIndexOf(\"-\");\n\n          if (index === -1) {\n            break;\n          } // strip off the last part. e.g. en-US => en\n\n\n          lang = lang.substr(0, index);\n          match = cultures[lang];\n\n          if (match) {\n            return match;\n          }\n        } while (1);\n      } // last resort: match first culture using that language\n\n\n      for (i = 0; i < l; i++) {\n        lang = prioritized[i].lang;\n\n        for (var cultureKey in cultures) {\n          var culture = cultures[cultureKey];\n\n          if (culture.language == lang) {\n            return culture;\n          }\n        }\n      }\n    } else if (typeof name === \"object\") {\n      return name;\n    }\n\n    return match || null;\n  };\n\n  Globalize.format = function (value, format, cultureSelector) {\n    var culture = this.findClosestCulture(cultureSelector);\n\n    if (value instanceof Date) {\n      value = formatDate(value, format, culture);\n    } else if (typeof value === \"number\") {\n      value = formatNumber(value, format, culture);\n    }\n\n    return value;\n  };\n\n  Globalize.localize = function (key, cultureSelector) {\n    return this.findClosestCulture(cultureSelector).messages[key] || this.cultures[\"default\"].messages[key];\n  };\n\n  Globalize.parseDate = function (value, formats, culture) {\n    culture = this.findClosestCulture(culture);\n    var date, prop, patterns;\n\n    if (formats) {\n      if (typeof formats === \"string\") {\n        formats = [formats];\n      }\n\n      if (formats.length) {\n        for (var i = 0, l = formats.length; i < l; i++) {\n          var format = formats[i];\n\n          if (format) {\n            date = parseExact(value, format, culture);\n\n            if (date) {\n              break;\n            }\n          }\n        }\n      }\n    } else {\n      patterns = culture.calendar.patterns;\n\n      for (prop in patterns) {\n        date = parseExact(value, patterns[prop], culture);\n\n        if (date) {\n          break;\n        }\n      }\n    }\n\n    return date || null;\n  };\n\n  Globalize.parseInt = function (value, radix, cultureSelector) {\n    return truncate(Globalize.parseFloat(value, radix, cultureSelector));\n  };\n\n  Globalize.parseFloat = function (value, radix, cultureSelector) {\n    // radix argument is optional\n    if (typeof radix !== \"number\") {\n      cultureSelector = radix;\n      radix = 10;\n    }\n\n    var culture = this.findClosestCulture(cultureSelector);\n    var ret = NaN,\n        nf = culture.numberFormat;\n\n    if (value.indexOf(culture.numberFormat.currency.symbol) > -1) {\n      // remove currency symbol\n      value = value.replace(culture.numberFormat.currency.symbol, \"\"); // replace decimal seperator\n\n      value = value.replace(culture.numberFormat.currency[\".\"], culture.numberFormat[\".\"]);\n    } //Remove percentage character from number string before parsing\n\n\n    if (value.indexOf(culture.numberFormat.percent.symbol) > -1) {\n      value = value.replace(culture.numberFormat.percent.symbol, \"\");\n    } // remove spaces: leading, trailing and between - and number. Used for negative currency pt-BR\n\n\n    value = value.replace(/ /g, \"\"); // allow infinity or hexidecimal\n\n    if (regexInfinity.test(value)) {\n      ret = parseFloat(value);\n    } else if (!radix && regexHex.test(value)) {\n      ret = parseInt(value, 16);\n    } else {\n      // determine sign and number\n      var signInfo = parseNegativePattern(value, nf, nf.pattern[0]),\n          sign = signInfo[0],\n          num = signInfo[1]; // #44 - try parsing as \"(n)\"\n\n      if (sign === \"\" && nf.pattern[0] !== \"(n)\") {\n        signInfo = parseNegativePattern(value, nf, \"(n)\");\n        sign = signInfo[0];\n        num = signInfo[1];\n      } // try parsing as \"-n\"\n\n\n      if (sign === \"\" && nf.pattern[0] !== \"-n\") {\n        signInfo = parseNegativePattern(value, nf, \"-n\");\n        sign = signInfo[0];\n        num = signInfo[1];\n      }\n\n      sign = sign || \"+\"; // determine exponent and number\n\n      var exponent,\n          intAndFraction,\n          exponentPos = num.indexOf(\"e\");\n      if (exponentPos < 0) exponentPos = num.indexOf(\"E\");\n\n      if (exponentPos < 0) {\n        intAndFraction = num;\n        exponent = null;\n      } else {\n        intAndFraction = num.substr(0, exponentPos);\n        exponent = num.substr(exponentPos + 1);\n      } // determine decimal position\n\n\n      var integer,\n          fraction,\n          decSep = nf[\".\"],\n          decimalPos = intAndFraction.indexOf(decSep);\n\n      if (decimalPos < 0) {\n        integer = intAndFraction;\n        fraction = null;\n      } else {\n        integer = intAndFraction.substr(0, decimalPos);\n        fraction = intAndFraction.substr(decimalPos + decSep.length);\n      } // handle groups (e.g. 1,000,000)\n\n\n      var groupSep = nf[\",\"];\n      integer = integer.split(groupSep).join(\"\");\n      var altGroupSep = groupSep.replace(/\\u00A0/g, \" \");\n\n      if (groupSep !== altGroupSep) {\n        integer = integer.split(altGroupSep).join(\"\");\n      } // build a natively parsable number string\n\n\n      var p = sign + integer;\n\n      if (fraction !== null) {\n        p += \".\" + fraction;\n      }\n\n      if (exponent !== null) {\n        // exponent itself may have a number patternd\n        var expSignInfo = parseNegativePattern(exponent, nf, \"-n\");\n        p += \"e\" + (expSignInfo[0] || \"+\") + expSignInfo[1];\n      }\n\n      if (regexParseFloat.test(p)) {\n        ret = parseFloat(p);\n      }\n    }\n\n    return ret;\n  };\n\n  Globalize.culture = function (cultureSelector) {\n    // setter\n    if (typeof cultureSelector !== \"undefined\") {\n      this.cultureSelector = cultureSelector;\n    } // getter\n\n\n    return this.findClosestCulture(cultureSelector) || this.cultures[\"default\"];\n  };\n})(this);","map":{"version":3,"sources":["D:/react-myprojects/hrms-airtable/node_modules/globalize/lib/globalize.js"],"names":["window","undefined","Globalize","regexHex","regexInfinity","regexParseFloat","regexTrim","arrayIndexOf","endsWith","extend","isArray","isFunction","isObject","startsWith","trim","truncate","zeroPad","appendPreOrPostMatch","expandFormat","formatDate","formatNumber","getTokenRegExp","getEra","getEraYear","parseExact","parseNegativePattern","cultureSelector","prototype","init","require","exports","module","cultures","constructor","name","englishName","nativeName","isRTL","language","numberFormat","pattern","decimals","groupSizes","negativeInfinity","positiveInfinity","percent","symbol","currency","calendars","standard","firstDay","days","names","namesAbbr","namesShort","months","AM","PM","eras","twoDigitYearMax","patterns","d","D","t","T","f","F","M","Y","S","messages","calendar","en","array","item","indexOf","i","length","value","substr","options","src","copy","copyIsArray","clone","target","arguments","deep","Array","obj","Object","toString","call","replace","isNaN","NaN","Math","str","count","left","l","preMatch","strings","quoteCount","escaped","il","c","charAt","push","cal","format","len","culture","convert","ret","eraDate","Date","getTime","era","setFullYear","toLocaleString","sortable","hour","zeros","foundDay","checkedDay","dayPartRegExp","tokenRegExp","converted","padZeros","num","r","s","hasDay","test","getPart","date","part","getFullYear","getMonth","getDate","fromGregorian","index","lastIndex","ar","exec","slice","current","clength","getDay","monthsGenitive","getHours","getMinutes","getSeconds","getMilliseconds","getTimezoneOffset","floor","abs","join","expandNumber","number","precision","formatInfo","curSize","curGroupIndex","factor","pow","rounded","round","isFinite","numberString","right","split","exponent","parseInt","stringIndex","sep","Infinity","nf","toUpperCase","patternParts","start","ticks","year","offset","expandYear","getDayIndex","getMonthIndex","getParseRegExp","outOfRange","toUpper","toUpperArray","now","curr","abbr","upperDays","_upperDays","monthsGen","upperMonths","_upperMonths","upperMonthsGen","_upperMonthsGen","re","_parseRegExp","reFormat","expFormat","regexp","groups","match","m","add","regexpStr","parseRegExp","low","high","arr","results","parseInfo","RegExp","regExp","month","weekDay","hourOffset","min","sec","msec","tzMinOffset","pmHour","j","jl","matchGroup","matchInt","offsets","minOffset","eraName","toLowerCase","result","defaultYear","toGregorian","setHours","adjustedMin","negativePattern","neg","pos","findClosestCulture","localize","key","radix","parseFloat","addCultureInfo","cultureName","baseCultureName","info","base","isNew","lang","list","prioritized","pri","parts","sort","a","b","lastIndexOf","cultureKey","parseDate","formats","prop","signInfo","sign","intAndFraction","exponentPos","integer","fraction","decSep","decimalPos","groupSep","altGroupSep","p","expSignInfo"],"mappings":"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","sourcesContent":["/*!\n * Globalize\n *\n * http://github.com/jquery/globalize\n *\n * Copyright Software Freedom Conservancy, Inc.\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n */\n\n(function( window, undefined ) {\n\nvar Globalize,\n\t// private variables\n\tregexHex,\n\tregexInfinity,\n\tregexParseFloat,\n\tregexTrim,\n\t// private JavaScript utility functions\n\tarrayIndexOf,\n\tendsWith,\n\textend,\n\tisArray,\n\tisFunction,\n\tisObject,\n\tstartsWith,\n\ttrim,\n\ttruncate,\n\tzeroPad,\n\t// private Globalization utility functions\n\tappendPreOrPostMatch,\n\texpandFormat,\n\tformatDate,\n\tformatNumber,\n\tgetTokenRegExp,\n\tgetEra,\n\tgetEraYear,\n\tparseExact,\n\tparseNegativePattern;\n\n// Global variable (Globalize) or CommonJS module (globalize)\nGlobalize = function( cultureSelector ) {\n\treturn new Globalize.prototype.init( cultureSelector );\n};\n\nif ( typeof require !== \"undefined\" &&\n\ttypeof exports !== \"undefined\" &&\n\ttypeof module !== \"undefined\" ) {\n\t// Assume CommonJS\n\tmodule.exports = Globalize;\n} else {\n\t// Export as global variable\n\twindow.Globalize = Globalize;\n}\n\nGlobalize.cultures = {};\n\nGlobalize.prototype = {\n\tconstructor: Globalize,\n\tinit: function( cultureSelector ) {\n\t\tthis.cultures = Globalize.cultures;\n\t\tthis.cultureSelector = cultureSelector;\n\n\t\treturn this;\n\t}\n};\nGlobalize.prototype.init.prototype = Globalize.prototype;\n\n// 1. When defining a culture, all fields are required except the ones stated as optional.\n// 2. Each culture should have a \".calendars\" object with at least one calendar named \"standard\"\n//    which serves as the default calendar in use by that culture.\n// 3. Each culture should have a \".calendar\" object which is the current calendar being used,\n//    it may be dynamically changed at any time to one of the calendars in \".calendars\".\nGlobalize.cultures[ \"default\" ] = {\n\t// A unique name for the culture in the form <language code>-<country/region code>\n\tname: \"en\",\n\t// the name of the culture in the english language\n\tenglishName: \"English\",\n\t// the name of the culture in its own language\n\tnativeName: \"English\",\n\t// whether the culture uses right-to-left text\n\tisRTL: false,\n\t// \"language\" is used for so-called \"specific\" cultures.\n\t// For example, the culture \"es-CL\" means \"Spanish, in Chili\".\n\t// It represents the Spanish-speaking culture as it is in Chili,\n\t// which might have different formatting rules or even translations\n\t// than Spanish in Spain. A \"neutral\" culture is one that is not\n\t// specific to a region. For example, the culture \"es\" is the generic\n\t// Spanish culture, which may be a more generalized version of the language\n\t// that may or may not be what a specific culture expects.\n\t// For a specific culture like \"es-CL\", the \"language\" field refers to the\n\t// neutral, generic culture information for the language it is using.\n\t// This is not always a simple matter of the string before the dash.\n\t// For example, the \"zh-Hans\" culture is netural (Simplified Chinese).\n\t// And the \"zh-SG\" culture is Simplified Chinese in Singapore, whose lanugage\n\t// field is \"zh-CHS\", not \"zh\".\n\t// This field should be used to navigate from a specific culture to it's\n\t// more general, neutral culture. If a culture is already as general as it\n\t// can get, the language may refer to itself.\n\tlanguage: \"en\",\n\t// numberFormat defines general number formatting rules, like the digits in\n\t// each grouping, the group separator, and how negative numbers are displayed.\n\tnumberFormat: {\n\t\t// [negativePattern]\n\t\t// Note, numberFormat.pattern has no \"positivePattern\" unlike percent and currency,\n\t\t// but is still defined as an array for consistency with them.\n\t\t//   negativePattern: one of \"(n)|-n|- n|n-|n -\"\n\t\tpattern: [ \"-n\" ],\n\t\t// number of decimal places normally shown\n\t\tdecimals: 2,\n\t\t// string that separates number groups, as in 1,000,000\n\t\t\",\": \",\",\n\t\t// string that separates a number from the fractional portion, as in 1.99\n\t\t\".\": \".\",\n\t\t// array of numbers indicating the size of each number group.\n\t\t// TODO: more detailed description and example\n\t\tgroupSizes: [ 3 ],\n\t\t// symbol used for positive numbers\n\t\t\"+\": \"+\",\n\t\t// symbol used for negative numbers\n\t\t\"-\": \"-\",\n\t\t// symbol used for NaN (Not-A-Number)\n\t\t\"NaN\": \"NaN\",\n\t\t// symbol used for Negative Infinity\n\t\tnegativeInfinity: \"-Infinity\",\n\t\t// symbol used for Positive Infinity\n\t\tpositiveInfinity: \"Infinity\",\n\t\tpercent: {\n\t\t\t// [negativePattern, positivePattern]\n\t\t\t//   negativePattern: one of \"-n %|-n%|-%n|%-n|%n-|n-%|n%-|-% n|n %-|% n-|% -n|n- %\"\n\t\t\t//   positivePattern: one of \"n %|n%|%n|% n\"\n\t\t\tpattern: [ \"-n %\", \"n %\" ],\n\t\t\t// number of decimal places normally shown\n\t\t\tdecimals: 2,\n\t\t\t// array of numbers indicating the size of each number group.\n\t\t\t// TODO: more detailed description and example\n\t\t\tgroupSizes: [ 3 ],\n\t\t\t// string that separates number groups, as in 1,000,000\n\t\t\t\",\": \",\",\n\t\t\t// string that separates a number from the fractional portion, as in 1.99\n\t\t\t\".\": \".\",\n\t\t\t// symbol used to represent a percentage\n\t\t\tsymbol: \"%\"\n\t\t},\n\t\tcurrency: {\n\t\t\t// [negativePattern, positivePattern]\n\t\t\t//   negativePattern: one of \"($n)|-$n|$-n|$n-|(n$)|-n$|n-$|n$-|-n $|-$ n|n $-|$ n-|$ -n|n- $|($ n)|(n $)\"\n\t\t\t//   positivePattern: one of \"$n|n$|$ n|n $\"\n\t\t\tpattern: [ \"($n)\", \"$n\" ],\n\t\t\t// number of decimal places normally shown\n\t\t\tdecimals: 2,\n\t\t\t// array of numbers indicating the size of each number group.\n\t\t\t// TODO: more detailed description and example\n\t\t\tgroupSizes: [ 3 ],\n\t\t\t// string that separates number groups, as in 1,000,000\n\t\t\t\",\": \",\",\n\t\t\t// string that separates a number from the fractional portion, as in 1.99\n\t\t\t\".\": \".\",\n\t\t\t// symbol used to represent currency\n\t\t\tsymbol: \"$\"\n\t\t}\n\t},\n\t// calendars defines all the possible calendars used by this culture.\n\t// There should be at least one defined with name \"standard\", and is the default\n\t// calendar used by the culture.\n\t// A calendar contains information about how dates are formatted, information about\n\t// the calendar's eras, a standard set of the date formats,\n\t// translations for day and month names, and if the calendar is not based on the Gregorian\n\t// calendar, conversion functions to and from the Gregorian calendar.\n\tcalendars: {\n\t\tstandard: {\n\t\t\t// name that identifies the type of calendar this is\n\t\t\tname: \"Gregorian_USEnglish\",\n\t\t\t// separator of parts of a date (e.g. \"/\" in 11/05/1955)\n\t\t\t\"/\": \"/\",\n\t\t\t// separator of parts of a time (e.g. \":\" in 05:44 PM)\n\t\t\t\":\": \":\",\n\t\t\t// the first day of the week (0 = Sunday, 1 = Monday, etc)\n\t\t\tfirstDay: 0,\n\t\t\tdays: {\n\t\t\t\t// full day names\n\t\t\t\tnames: [ \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" ],\n\t\t\t\t// abbreviated day names\n\t\t\t\tnamesAbbr: [ \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" ],\n\t\t\t\t// shortest day names\n\t\t\t\tnamesShort: [ \"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\" ]\n\t\t\t},\n\t\t\tmonths: {\n\t\t\t\t// full month names (13 months for lunar calendards -- 13th month should be \"\" if not lunar)\n\t\t\t\tnames: [ \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\", \"\" ],\n\t\t\t\t// abbreviated month names\n\t\t\t\tnamesAbbr: [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"\" ]\n\t\t\t},\n\t\t\t// AM and PM designators in one of these forms:\n\t\t\t// The usual view, and the upper and lower case versions\n\t\t\t//   [ standard, lowercase, uppercase ]\n\t\t\t// The culture does not use AM or PM (likely all standard date formats use 24 hour time)\n\t\t\t//   null\n\t\t\tAM: [ \"AM\", \"am\", \"AM\" ],\n\t\t\tPM: [ \"PM\", \"pm\", \"PM\" ],\n\t\t\teras: [\n\t\t\t\t// eras in reverse chronological order.\n\t\t\t\t// name: the name of the era in this culture (e.g. A.D., C.E.)\n\t\t\t\t// start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era.\n\t\t\t\t// offset: offset in years from gregorian calendar\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"A.D.\",\n\t\t\t\t\t\"start\": null,\n\t\t\t\t\t\"offset\": 0\n\t\t\t\t}\n\t\t\t],\n\t\t\t// when a two digit year is given, it will never be parsed as a four digit\n\t\t\t// year greater than this year (in the appropriate era for the culture)\n\t\t\t// Set it as a full year (e.g. 2029) or use an offset format starting from\n\t\t\t// the current year: \"+19\" would correspond to 2029 if the current year 2010.\n\t\t\ttwoDigitYearMax: 2029,\n\t\t\t// set of predefined date and time patterns used by the culture\n\t\t\t// these represent the format someone in this culture would expect\n\t\t\t// to see given the portions of the date that are shown.\n\t\t\tpatterns: {\n\t\t\t\t// short date pattern\n\t\t\t\td: \"M/d/yyyy\",\n\t\t\t\t// long date pattern\n\t\t\t\tD: \"dddd, MMMM dd, yyyy\",\n\t\t\t\t// short time pattern\n\t\t\t\tt: \"h:mm tt\",\n\t\t\t\t// long time pattern\n\t\t\t\tT: \"h:mm:ss tt\",\n\t\t\t\t// long date, short time pattern\n\t\t\t\tf: \"dddd, MMMM dd, yyyy h:mm tt\",\n\t\t\t\t// long date, long time pattern\n\t\t\t\tF: \"dddd, MMMM dd, yyyy h:mm:ss tt\",\n\t\t\t\t// month/day pattern\n\t\t\t\tM: \"MMMM dd\",\n\t\t\t\t// month/year pattern\n\t\t\t\tY: \"yyyy MMMM\",\n\t\t\t\t// S is a sortable format that does not vary by culture\n\t\t\t\tS: \"yyyy\\u0027-\\u0027MM\\u0027-\\u0027dd\\u0027T\\u0027HH\\u0027:\\u0027mm\\u0027:\\u0027ss\"\n\t\t\t}\n\t\t\t// optional fields for each calendar:\n\t\t\t/*\n\t\t\tmonthsGenitive:\n\t\t\t\tSame as months but used when the day preceeds the month.\n\t\t\t\tOmit if the culture has no genitive distinction in month names.\n\t\t\t\tFor an explaination of genitive months, see http://blogs.msdn.com/michkap/archive/2004/12/25/332259.aspx\n\t\t\tconvert:\n\t\t\t\tAllows for the support of non-gregorian based calendars. This convert object is used to\n\t\t\t\tto convert a date to and from a gregorian calendar date to handle parsing and formatting.\n\t\t\t\tThe two functions:\n\t\t\t\t\tfromGregorian( date )\n\t\t\t\t\t\tGiven the date as a parameter, return an array with parts [ year, month, day ]\n\t\t\t\t\t\tcorresponding to the non-gregorian based year, month, and day for the calendar.\n\t\t\t\t\ttoGregorian( year, month, day )\n\t\t\t\t\t\tGiven the non-gregorian year, month, and day, return a new Date() object\n\t\t\t\t\t\tset to the corresponding date in the gregorian calendar.\n\t\t\t*/\n\t\t}\n\t},\n\t// For localized strings\n\tmessages: {}\n};\n\nGlobalize.cultures[ \"default\" ].calendar = Globalize.cultures[ \"default\" ].calendars.standard;\n\nGlobalize.cultures.en = Globalize.cultures[ \"default\" ];\n\nGlobalize.cultureSelector = \"en\";\n\n//\n// private variables\n//\n\nregexHex = /^0x[a-f0-9]+$/i;\nregexInfinity = /^[+\\-]?infinity$/i;\nregexParseFloat = /^[+\\-]?\\d*\\.?\\d*(e[+\\-]?\\d+)?$/;\nregexTrim = /^\\s+|\\s+$/g;\n\n//\n// private JavaScript utility functions\n//\n\narrayIndexOf = function( array, item ) {\n\tif ( array.indexOf ) {\n\t\treturn array.indexOf( item );\n\t}\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\tif ( array[i] === item ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\nendsWith = function( value, pattern ) {\n\treturn value.substr( value.length - pattern.length ) === pattern;\n};\n\nextend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( isObject(copy) || (copyIsArray = isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && isObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\nisArray = Array.isArray || function( obj ) {\n\treturn Object.prototype.toString.call( obj ) === \"[object Array]\";\n};\n\nisFunction = function( obj ) {\n\treturn Object.prototype.toString.call( obj ) === \"[object Function]\";\n};\n\nisObject = function( obj ) {\n\treturn Object.prototype.toString.call( obj ) === \"[object Object]\";\n};\n\nstartsWith = function( value, pattern ) {\n\treturn value.indexOf( pattern ) === 0;\n};\n\ntrim = function( value ) {\n\treturn ( value + \"\" ).replace( regexTrim, \"\" );\n};\n\ntruncate = function( value ) {\n\tif ( isNaN( value ) ) {\n\t\treturn NaN;\n\t}\n\treturn Math[ value < 0 ? \"ceil\" : \"floor\" ]( value );\n};\n\nzeroPad = function( str, count, left ) {\n\tvar l;\n\tfor ( l = str.length; l < count; l += 1 ) {\n\t\tstr = ( left ? (\"0\" + str) : (str + \"0\") );\n\t}\n\treturn str;\n};\n\n//\n// private Globalization utility functions\n//\n\nappendPreOrPostMatch = function( preMatch, strings ) {\n\t// appends pre- and post- token match strings while removing escaped characters.\n\t// Returns a single quote count which is used to determine if the token occurs\n\t// in a string literal.\n\tvar quoteCount = 0,\n\t\tescaped = false;\n\tfor ( var i = 0, il = preMatch.length; i < il; i++ ) {\n\t\tvar c = preMatch.charAt( i );\n\t\tswitch ( c ) {\n\t\t\tcase \"\\'\":\n\t\t\t\tif ( escaped ) {\n\t\t\t\t\tstrings.push( \"\\'\" );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tquoteCount++;\n\t\t\t\t}\n\t\t\t\tescaped = false;\n\t\t\t\tbreak;\n\t\t\tcase \"\\\\\":\n\t\t\t\tif ( escaped ) {\n\t\t\t\t\tstrings.push( \"\\\\\" );\n\t\t\t\t}\n\t\t\t\tescaped = !escaped;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstrings.push( c );\n\t\t\t\tescaped = false;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn quoteCount;\n};\n\nexpandFormat = function( cal, format ) {\n\t// expands unspecified or single character date formats into the full pattern.\n\tformat = format || \"F\";\n\tvar pattern,\n\t\tpatterns = cal.patterns,\n\t\tlen = format.length;\n\tif ( len === 1 ) {\n\t\tpattern = patterns[ format ];\n\t\tif ( !pattern ) {\n\t\t\tthrow \"Invalid date format string \\'\" + format + \"\\'.\";\n\t\t}\n\t\tformat = pattern;\n\t}\n\telse if ( len === 2 && format.charAt(0) === \"%\" ) {\n\t\t// %X escape format -- intended as a custom format string that is only one character, not a built-in format.\n\t\tformat = format.charAt( 1 );\n\t}\n\treturn format;\n};\n\nformatDate = function( value, format, culture ) {\n\tvar cal = culture.calendar,\n\t\tconvert = cal.convert,\n\t\tret;\n\n\tif ( !format || !format.length || format === \"i\" ) {\n\t\tif ( culture && culture.name.length ) {\n\t\t\tif ( convert ) {\n\t\t\t\t// non-gregorian calendar, so we cannot use built-in toLocaleString()\n\t\t\t\tret = formatDate( value, cal.patterns.F, culture );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar eraDate = new Date( value.getTime() ),\n\t\t\t\t\tera = getEra( value, cal.eras );\n\t\t\t\teraDate.setFullYear( getEraYear(value, cal, era) );\n\t\t\t\tret = eraDate.toLocaleString();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tret = value.toString();\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvar eras = cal.eras,\n\t\tsortable = format === \"s\";\n\tformat = expandFormat( cal, format );\n\n\t// Start with an empty string\n\tret = [];\n\tvar hour,\n\t\tzeros = [ \"0\", \"00\", \"000\" ],\n\t\tfoundDay,\n\t\tcheckedDay,\n\t\tdayPartRegExp = /([^d]|^)(d|dd)([^d]|$)/g,\n\t\tquoteCount = 0,\n\t\ttokenRegExp = getTokenRegExp(),\n\t\tconverted;\n\n\tfunction padZeros( num, c ) {\n\t\tvar r, s = num + \"\";\n\t\tif ( c > 1 && s.length < c ) {\n\t\t\tr = ( zeros[c - 2] + s);\n\t\t\treturn r.substr( r.length - c, c );\n\t\t}\n\t\telse {\n\t\t\tr = s;\n\t\t}\n\t\treturn r;\n\t}\n\n\tfunction hasDay() {\n\t\tif ( foundDay || checkedDay ) {\n\t\t\treturn foundDay;\n\t\t}\n\t\tfoundDay = dayPartRegExp.test( format );\n\t\tcheckedDay = true;\n\t\treturn foundDay;\n\t}\n\n\tfunction getPart( date, part ) {\n\t\tif ( converted ) {\n\t\t\treturn converted[ part ];\n\t\t}\n\t\tswitch ( part ) {\n\t\t\tcase 0:\n\t\t\t\treturn date.getFullYear();\n\t\t\tcase 1:\n\t\t\t\treturn date.getMonth();\n\t\t\tcase 2:\n\t\t\t\treturn date.getDate();\n\t\t\tdefault:\n\t\t\t\tthrow \"Invalid part value \" + part;\n\t\t}\n\t}\n\n\tif ( !sortable && convert ) {\n\t\tconverted = convert.fromGregorian( value );\n\t}\n\n\tfor ( ; ; ) {\n\t\t// Save the current index\n\t\tvar index = tokenRegExp.lastIndex,\n\t\t\t// Look for the next pattern\n\t\t\tar = tokenRegExp.exec( format );\n\n\t\t// Append the text before the pattern (or the end of the string if not found)\n\t\tvar preMatch = format.slice( index, ar ? ar.index : format.length );\n\t\tquoteCount += appendPreOrPostMatch( preMatch, ret );\n\n\t\tif ( !ar ) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// do not replace any matches that occur inside a string literal.\n\t\tif ( quoteCount % 2 ) {\n\t\t\tret.push( ar[0] );\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar current = ar[ 0 ],\n\t\t\tclength = current.length;\n\n\t\tswitch ( current ) {\n\t\t\tcase \"ddd\":\n\t\t\t\t//Day of the week, as a three-letter abbreviation\n\t\t\tcase \"dddd\":\n\t\t\t\t// Day of the week, using the full name\n\t\t\t\tvar names = ( clength === 3 ) ? cal.days.namesAbbr : cal.days.names;\n\t\t\t\tret.push( names[value.getDay()] );\n\t\t\t\tbreak;\n\t\t\tcase \"d\":\n\t\t\t\t// Day of month, without leading zero for single-digit days\n\t\t\tcase \"dd\":\n\t\t\t\t// Day of month, with leading zero for single-digit days\n\t\t\t\tfoundDay = true;\n\t\t\t\tret.push(\n\t\t\t\t\tpadZeros( getPart(value, 2), clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"MMM\":\n\t\t\t\t// Month, as a three-letter abbreviation\n\t\t\tcase \"MMMM\":\n\t\t\t\t// Month, using the full name\n\t\t\t\tvar part = getPart( value, 1 );\n\t\t\t\tret.push(\n\t\t\t\t\t( cal.monthsGenitive && hasDay() ) ?\n\t\t\t\t\t( cal.monthsGenitive[ clength === 3 ? \"namesAbbr\" : \"names\" ][ part ] ) :\n\t\t\t\t\t( cal.months[ clength === 3 ? \"namesAbbr\" : \"names\" ][ part ] )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"M\":\n\t\t\t\t// Month, as digits, with no leading zero for single-digit months\n\t\t\tcase \"MM\":\n\t\t\t\t// Month, as digits, with leading zero for single-digit months\n\t\t\t\tret.push(\n\t\t\t\t\tpadZeros( getPart(value, 1) + 1, clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"y\":\n\t\t\t\t// Year, as two digits, but with no leading zero for years less than 10\n\t\t\tcase \"yy\":\n\t\t\t\t// Year, as two digits, with leading zero for years less than 10\n\t\t\tcase \"yyyy\":\n\t\t\t\t// Year represented by four full digits\n\t\t\t\tpart = converted ? converted[ 0 ] : getEraYear( value, cal, getEra(value, eras), sortable );\n\t\t\t\tif ( clength < 4 ) {\n\t\t\t\t\tpart = part % 100;\n\t\t\t\t}\n\t\t\t\tret.push(\n\t\t\t\t\tpadZeros( part, clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"h\":\n\t\t\t\t// Hours with no leading zero for single-digit hours, using 12-hour clock\n\t\t\tcase \"hh\":\n\t\t\t\t// Hours with leading zero for single-digit hours, using 12-hour clock\n\t\t\t\thour = value.getHours() % 12;\n\t\t\t\tif ( hour === 0 ) hour = 12;\n\t\t\t\tret.push(\n\t\t\t\t\tpadZeros( hour, clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"H\":\n\t\t\t\t// Hours with no leading zero for single-digit hours, using 24-hour clock\n\t\t\tcase \"HH\":\n\t\t\t\t// Hours with leading zero for single-digit hours, using 24-hour clock\n\t\t\t\tret.push(\n\t\t\t\t\tpadZeros( value.getHours(), clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"m\":\n\t\t\t\t// Minutes with no leading zero for single-digit minutes\n\t\t\tcase \"mm\":\n\t\t\t\t// Minutes with leading zero for single-digit minutes\n\t\t\t\tret.push(\n\t\t\t\t\tpadZeros( value.getMinutes(), clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"s\":\n\t\t\t\t// Seconds with no leading zero for single-digit seconds\n\t\t\tcase \"ss\":\n\t\t\t\t// Seconds with leading zero for single-digit seconds\n\t\t\t\tret.push(\n\t\t\t\t\tpadZeros( value.getSeconds(), clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"t\":\n\t\t\t\t// One character am/pm indicator (\"a\" or \"p\")\n\t\t\tcase \"tt\":\n\t\t\t\t// Multicharacter am/pm indicator\n\t\t\t\tpart = value.getHours() < 12 ? ( cal.AM ? cal.AM[0] : \" \" ) : ( cal.PM ? cal.PM[0] : \" \" );\n\t\t\t\tret.push( clength === 1 ? part.charAt(0) : part );\n\t\t\t\tbreak;\n\t\t\tcase \"f\":\n\t\t\t\t// Deciseconds\n\t\t\tcase \"ff\":\n\t\t\t\t// Centiseconds\n\t\t\tcase \"fff\":\n\t\t\t\t// Milliseconds\n\t\t\t\tret.push(\n\t\t\t\t\tpadZeros( value.getMilliseconds(), 3 ).substr( 0, clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"z\":\n\t\t\t\t// Time zone offset, no leading zero\n\t\t\tcase \"zz\":\n\t\t\t\t// Time zone offset with leading zero\n\t\t\t\thour = value.getTimezoneOffset() / 60;\n\t\t\t\tret.push(\n\t\t\t\t\t( hour <= 0 ? \"+\" : \"-\" ) + padZeros( Math.floor(Math.abs(hour)), clength )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"zzz\":\n\t\t\t\t// Time zone offset with leading zero\n\t\t\t\thour = value.getTimezoneOffset() / 60;\n\t\t\t\tret.push(\n\t\t\t\t\t( hour <= 0 ? \"+\" : \"-\" ) + padZeros( Math.floor(Math.abs(hour)), 2 ) +\n\t\t\t\t\t// Hard coded \":\" separator, rather than using cal.TimeSeparator\n\t\t\t\t\t// Repeated here for consistency, plus \":\" was already assumed in date parsing.\n\t\t\t\t\t\":\" + padZeros( Math.abs(value.getTimezoneOffset() % 60), 2 )\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"g\":\n\t\t\tcase \"gg\":\n\t\t\t\tif ( cal.eras ) {\n\t\t\t\t\tret.push(\n\t\t\t\t\t\tcal.eras[ getEra(value, eras) ].name\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\tcase \"/\":\n\t\t\tret.push( cal[\"/\"] );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow \"Invalid date format pattern \\'\" + current + \"\\'.\";\n\t\t}\n\t}\n\treturn ret.join( \"\" );\n};\n\n// formatNumber\n(function() {\n\tvar expandNumber;\n\n\texpandNumber = function( number, precision, formatInfo ) {\n\t\tvar groupSizes = formatInfo.groupSizes,\n\t\t\tcurSize = groupSizes[ 0 ],\n\t\t\tcurGroupIndex = 1,\n\t\t\tfactor = Math.pow( 10, precision ),\n\t\t\trounded = Math.round( number * factor ) / factor;\n\n\t\tif ( !isFinite(rounded) ) {\n\t\t\trounded = number;\n\t\t}\n\t\tnumber = rounded;\n\n\t\tvar numberString = number+\"\",\n\t\t\tright = \"\",\n\t\t\tsplit = numberString.split( /e/i ),\n\t\t\texponent = split.length > 1 ? parseInt( split[1], 10 ) : 0;\n\t\tnumberString = split[ 0 ];\n\t\tsplit = numberString.split( \".\" );\n\t\tnumberString = split[ 0 ];\n\t\tright = split.length > 1 ? split[ 1 ] : \"\";\n\n\t\tvar l;\n\t\tif ( exponent > 0 ) {\n\t\t\tright = zeroPad( right, exponent, false );\n\t\t\tnumberString += right.slice( 0, exponent );\n\t\t\tright = right.substr( exponent );\n\t\t}\n\t\telse if ( exponent < 0 ) {\n\t\t\texponent = -exponent;\n\t\t\tnumberString = zeroPad( numberString, exponent + 1, true );\n\t\t\tright = numberString.slice( -exponent, numberString.length ) + right;\n\t\t\tnumberString = numberString.slice( 0, -exponent );\n\t\t}\n\n\t\tif ( precision > 0 ) {\n\t\t\tright = formatInfo[ \".\" ] +\n\t\t\t\t( (right.length > precision) ? right.slice(0, precision) : zeroPad(right, precision) );\n\t\t}\n\t\telse {\n\t\t\tright = \"\";\n\t\t}\n\n\t\tvar stringIndex = numberString.length - 1,\n\t\t\tsep = formatInfo[ \",\" ],\n\t\t\tret = \"\";\n\n\t\twhile ( stringIndex >= 0 ) {\n\t\t\tif ( curSize === 0 || curSize > stringIndex ) {\n\t\t\t\treturn numberString.slice( 0, stringIndex + 1 ) + ( ret.length ? (sep + ret + right) : right );\n\t\t\t}\n\t\t\tret = numberString.slice( stringIndex - curSize + 1, stringIndex + 1 ) + ( ret.length ? (sep + ret) : \"\" );\n\n\t\t\tstringIndex -= curSize;\n\n\t\t\tif ( curGroupIndex < groupSizes.length ) {\n\t\t\t\tcurSize = groupSizes[ curGroupIndex ];\n\t\t\t\tcurGroupIndex++;\n\t\t\t}\n\t\t}\n\n\t\treturn numberString.slice( 0, stringIndex + 1 ) + sep + ret + right;\n\t};\n\n\tformatNumber = function( value, format, culture ) {\n\t\tif ( !isFinite(value) ) {\n\t\t\tif ( value === Infinity ) {\n\t\t\t\treturn culture.numberFormat.positiveInfinity;\n\t\t\t}\n\t\t\tif ( value === -Infinity ) {\n\t\t\t\treturn culture.numberFormat.negativeInfinity;\n\t\t\t}\n\t\t\treturn culture.numberFormat[ \"NaN\" ];\n\t\t}\n\t\tif ( !format || format === \"i\" ) {\n\t\t\treturn culture.name.length ? value.toLocaleString() : value.toString();\n\t\t}\n\t\tformat = format || \"D\";\n\n\t\tvar nf = culture.numberFormat,\n\t\t\tnumber = Math.abs( value ),\n\t\t\tprecision = -1,\n\t\t\tpattern;\n\t\tif ( format.length > 1 ) precision = parseInt( format.slice(1), 10 );\n\n\t\tvar current = format.charAt( 0 ).toUpperCase(),\n\t\t\tformatInfo;\n\n\t\tswitch ( current ) {\n\t\t\tcase \"D\":\n\t\t\t\tpattern = \"n\";\n\t\t\t\tnumber = truncate( number );\n\t\t\t\tif ( precision !== -1 ) {\n\t\t\t\t\tnumber = zeroPad( \"\" + number, precision, true );\n\t\t\t\t}\n\t\t\t\tif ( value < 0 ) number = \"-\" + number;\n\t\t\t\tbreak;\n\t\t\tcase \"N\":\n\t\t\t\tformatInfo = nf;\n\t\t\t\t/* falls through */\n\t\t\tcase \"C\":\n\t\t\t\tformatInfo = formatInfo || nf.currency;\n\t\t\t\t/* falls through */\n\t\t\tcase \"P\":\n\t\t\t\tformatInfo = formatInfo || nf.percent;\n\t\t\t\tpattern = value < 0 ? formatInfo.pattern[ 0 ] : ( formatInfo.pattern[1] || \"n\" );\n\t\t\t\tif ( precision === -1 ) precision = formatInfo.decimals;\n\t\t\t\tnumber = expandNumber( number * (current === \"P\" ? 100 : 1), precision, formatInfo );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow \"Bad number format specifier: \" + current;\n\t\t}\n\n\t\tvar patternParts = /n|\\$|-|%/g,\n\t\t\tret = \"\";\n\t\tfor ( ; ; ) {\n\t\t\tvar index = patternParts.lastIndex,\n\t\t\t\tar = patternParts.exec( pattern );\n\n\t\t\tret += pattern.slice( index, ar ? ar.index : pattern.length );\n\n\t\t\tif ( !ar ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch ( ar[0] ) {\n\t\t\t\tcase \"n\":\n\t\t\t\t\tret += number;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"$\":\n\t\t\t\t\tret += nf.currency.symbol;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"-\":\n\t\t\t\t\t// don't make 0 negative\n\t\t\t\t\tif ( /[1-9]/.test(number) ) {\n\t\t\t\t\t\tret += nf[ \"-\" ];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"%\":\n\t\t\t\t\tret += nf.percent.symbol;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t};\n\n}());\n\ngetTokenRegExp = function() {\n\t// regular expression for matching date and time tokens in format strings.\n\treturn (/\\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g);\n};\n\ngetEra = function( date, eras ) {\n\tif ( !eras ) return 0;\n\tvar start, ticks = date.getTime();\n\tfor ( var i = 0, l = eras.length; i < l; i++ ) {\n\t\tstart = eras[ i ].start;\n\t\tif ( start === null || ticks >= start ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn 0;\n};\n\ngetEraYear = function( date, cal, era, sortable ) {\n\tvar year = date.getFullYear();\n\tif ( !sortable && cal.eras ) {\n\t\t// convert normal gregorian year to era-shifted gregorian\n\t\t// year by subtracting the era offset\n\t\tyear -= cal.eras[ era ].offset;\n\t}\n\treturn year;\n};\n\n// parseExact\n(function() {\n\tvar expandYear,\n\t\tgetDayIndex,\n\t\tgetMonthIndex,\n\t\tgetParseRegExp,\n\t\toutOfRange,\n\t\ttoUpper,\n\t\ttoUpperArray;\n\n\texpandYear = function( cal, year ) {\n\t\t// expands 2-digit year into 4 digits.\n\t\tif ( year < 100 ) {\n\t\t\tvar now = new Date(),\n\t\t\t\tera = getEra( now ),\n\t\t\t\tcurr = getEraYear( now, cal, era ),\n\t\t\t\ttwoDigitYearMax = cal.twoDigitYearMax;\n\t\t\ttwoDigitYearMax = typeof twoDigitYearMax === \"string\" ? new Date().getFullYear() % 100 + parseInt( twoDigitYearMax, 10 ) : twoDigitYearMax;\n\t\t\tyear += curr - ( curr % 100 );\n\t\t\tif ( year > twoDigitYearMax ) {\n\t\t\t\tyear -= 100;\n\t\t\t}\n\t\t}\n\t\treturn year;\n\t};\n\n\tgetDayIndex = function\t( cal, value, abbr ) {\n\t\tvar ret,\n\t\t\tdays = cal.days,\n\t\t\tupperDays = cal._upperDays;\n\t\tif ( !upperDays ) {\n\t\t\tcal._upperDays = upperDays = [\n\t\t\t\ttoUpperArray( days.names ),\n\t\t\t\ttoUpperArray( days.namesAbbr ),\n\t\t\t\ttoUpperArray( days.namesShort )\n\t\t\t];\n\t\t}\n\t\tvalue = toUpper( value );\n\t\tif ( abbr ) {\n\t\t\tret = arrayIndexOf( upperDays[1], value );\n\t\t\tif ( ret === -1 ) {\n\t\t\t\tret = arrayIndexOf( upperDays[2], value );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tret = arrayIndexOf( upperDays[0], value );\n\t\t}\n\t\treturn ret;\n\t};\n\n\tgetMonthIndex = function( cal, value, abbr ) {\n\t\tvar months = cal.months,\n\t\t\tmonthsGen = cal.monthsGenitive || cal.months,\n\t\t\tupperMonths = cal._upperMonths,\n\t\t\tupperMonthsGen = cal._upperMonthsGen;\n\t\tif ( !upperMonths ) {\n\t\t\tcal._upperMonths = upperMonths = [\n\t\t\t\ttoUpperArray( months.names ),\n\t\t\t\ttoUpperArray( months.namesAbbr )\n\t\t\t];\n\t\t\tcal._upperMonthsGen = upperMonthsGen = [\n\t\t\t\ttoUpperArray( monthsGen.names ),\n\t\t\t\ttoUpperArray( monthsGen.namesAbbr )\n\t\t\t];\n\t\t}\n\t\tvalue = toUpper( value );\n\t\tvar i = arrayIndexOf( abbr ? upperMonths[1] : upperMonths[0], value );\n\t\tif ( i < 0 ) {\n\t\t\ti = arrayIndexOf( abbr ? upperMonthsGen[1] : upperMonthsGen[0], value );\n\t\t}\n\t\treturn i;\n\t};\n\n\tgetParseRegExp = function( cal, format ) {\n\t\t// converts a format string into a regular expression with groups that\n\t\t// can be used to extract date fields from a date string.\n\t\t// check for a cached parse regex.\n\t\tvar re = cal._parseRegExp;\n\t\tif ( !re ) {\n\t\t\tcal._parseRegExp = re = {};\n\t\t}\n\t\telse {\n\t\t\tvar reFormat = re[ format ];\n\t\t\tif ( reFormat ) {\n\t\t\t\treturn reFormat;\n\t\t\t}\n\t\t}\n\n\t\t// expand single digit formats, then escape regular expression characters.\n\t\tvar expFormat = expandFormat( cal, format ).replace( /([\\^\\$\\.\\*\\+\\?\\|\\[\\]\\(\\)\\{\\}])/g, \"\\\\\\\\$1\" ),\n\t\t\tregexp = [ \"^\" ],\n\t\t\tgroups = [],\n\t\t\tindex = 0,\n\t\t\tquoteCount = 0,\n\t\t\ttokenRegExp = getTokenRegExp(),\n\t\t\tmatch;\n\n\t\t// iterate through each date token found.\n\t\twhile ( (match = tokenRegExp.exec(expFormat)) !== null ) {\n\t\t\tvar preMatch = expFormat.slice( index, match.index );\n\t\t\tindex = tokenRegExp.lastIndex;\n\n\t\t\t// don't replace any matches that occur inside a string literal.\n\t\t\tquoteCount += appendPreOrPostMatch( preMatch, regexp );\n\t\t\tif ( quoteCount % 2 ) {\n\t\t\t\tregexp.push( match[0] );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// add a regex group for the token.\n\t\t\tvar m = match[ 0 ],\n\t\t\t\tlen = m.length,\n\t\t\t\tadd;\n\t\t\tswitch ( m ) {\n\t\t\t\tcase \"dddd\": case \"ddd\":\n\t\t\t\tcase \"MMMM\": case \"MMM\":\n\t\t\t\tcase \"gg\": case \"g\":\n\t\t\t\t\tadd = \"(\\\\D+)\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"tt\": case \"t\":\n\t\t\t\t\tadd = \"(\\\\D*)\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"yyyy\":\n\t\t\t\tcase \"fff\":\n\t\t\t\tcase \"ff\":\n\t\t\t\tcase \"f\":\n\t\t\t\t\tadd = \"(\\\\d{\" + len + \"})\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"dd\": case \"d\":\n\t\t\t\tcase \"MM\": case \"M\":\n\t\t\t\tcase \"yy\": case \"y\":\n\t\t\t\tcase \"HH\": case \"H\":\n\t\t\t\tcase \"hh\": case \"h\":\n\t\t\t\tcase \"mm\": case \"m\":\n\t\t\t\tcase \"ss\": case \"s\":\n\t\t\t\t\tadd = \"(\\\\d\\\\d?)\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"zzz\":\n\t\t\t\t\tadd = \"([+-]?\\\\d\\\\d?:\\\\d{2})\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"zz\": case \"z\":\n\t\t\t\t\tadd = \"([+-]?\\\\d\\\\d?)\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"/\":\n\t\t\t\t\tadd = \"(\\\\/)\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow \"Invalid date format pattern \\'\" + m + \"\\'.\";\n\t\t\t}\n\t\t\tif ( add ) {\n\t\t\t\tregexp.push( add );\n\t\t\t}\n\t\t\tgroups.push( match[0] );\n\t\t}\n\t\tappendPreOrPostMatch( expFormat.slice(index), regexp );\n\t\tregexp.push( \"$\" );\n\n\t\t// allow whitespace to differ when matching formats.\n\t\tvar regexpStr = regexp.join( \"\" ).replace( /\\s+/g, \"\\\\s+\" ),\n\t\t\tparseRegExp = { \"regExp\": regexpStr, \"groups\": groups };\n\n\t\t// cache the regex for this format.\n\t\treturn re[ format ] = parseRegExp;\n\t};\n\n\toutOfRange = function( value, low, high ) {\n\t\treturn value < low || value > high;\n\t};\n\n\ttoUpper = function( value ) {\n\t\t// \"he-IL\" has non-breaking space in weekday names.\n\t\treturn value.split( \"\\u00A0\" ).join( \" \" ).toUpperCase();\n\t};\n\n\ttoUpperArray = function( arr ) {\n\t\tvar results = [];\n\t\tfor ( var i = 0, l = arr.length; i < l; i++ ) {\n\t\t\tresults[ i ] = toUpper( arr[i] );\n\t\t}\n\t\treturn results;\n\t};\n\n\tparseExact = function( value, format, culture ) {\n\t\t// try to parse the date string by matching against the format string\n\t\t// while using the specified culture for date field names.\n\t\tvalue = trim( value );\n\t\tvar cal = culture.calendar,\n\t\t\t// convert date formats into regular expressions with groupings.\n\t\t\t// use the regexp to determine the input format and extract the date fields.\n\t\t\tparseInfo = getParseRegExp( cal, format ),\n\t\t\tmatch = new RegExp( parseInfo.regExp ).exec( value );\n\t\tif ( match === null ) {\n\t\t\treturn null;\n\t\t}\n\t\t// found a date format that matches the input.\n\t\tvar groups = parseInfo.groups,\n\t\t\tera = null, year = null, month = null, date = null, weekDay = null,\n\t\t\thour = 0, hourOffset, min = 0, sec = 0, msec = 0, tzMinOffset = null,\n\t\t\tpmHour = false;\n\t\t// iterate the format groups to extract and set the date fields.\n\t\tfor ( var j = 0, jl = groups.length; j < jl; j++ ) {\n\t\t\tvar matchGroup = match[ j + 1 ];\n\t\t\tif ( matchGroup ) {\n\t\t\t\tvar current = groups[ j ],\n\t\t\t\t\tclength = current.length,\n\t\t\t\t\tmatchInt = parseInt( matchGroup, 10 );\n\t\t\t\tswitch ( current ) {\n\t\t\t\t\tcase \"dd\": case \"d\":\n\t\t\t\t\t\t// Day of month.\n\t\t\t\t\t\tdate = matchInt;\n\t\t\t\t\t\t// check that date is generally in valid range, also checking overflow below.\n\t\t\t\t\t\tif ( outOfRange(date, 1, 31) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"MMM\": case \"MMMM\":\n\t\t\t\t\t\tmonth = getMonthIndex( cal, matchGroup, clength === 3 );\n\t\t\t\t\t\tif ( outOfRange(month, 0, 11) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"M\": case \"MM\":\n\t\t\t\t\t\t// Month.\n\t\t\t\t\t\tmonth = matchInt - 1;\n\t\t\t\t\t\tif ( outOfRange(month, 0, 11) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"y\": case \"yy\":\n\t\t\t\t\tcase \"yyyy\":\n\t\t\t\t\t\tyear = clength < 4 ? expandYear( cal, matchInt ) : matchInt;\n\t\t\t\t\t\tif ( outOfRange(year, 0, 9999) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"h\": case \"hh\":\n\t\t\t\t\t\t// Hours (12-hour clock).\n\t\t\t\t\t\thour = matchInt;\n\t\t\t\t\t\tif ( hour === 12 ) hour = 0;\n\t\t\t\t\t\tif ( outOfRange(hour, 0, 11) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"H\": case \"HH\":\n\t\t\t\t\t\t// Hours (24-hour clock).\n\t\t\t\t\t\thour = matchInt;\n\t\t\t\t\t\tif ( outOfRange(hour, 0, 23) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"m\": case \"mm\":\n\t\t\t\t\t\t// Minutes.\n\t\t\t\t\t\tmin = matchInt;\n\t\t\t\t\t\tif ( outOfRange(min, 0, 59) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"s\": case \"ss\":\n\t\t\t\t\t\t// Seconds.\n\t\t\t\t\t\tsec = matchInt;\n\t\t\t\t\t\tif ( outOfRange(sec, 0, 59) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"tt\": case \"t\":\n\t\t\t\t\t\t// AM/PM designator.\n\t\t\t\t\t\t// see if it is standard, upper, or lower case PM. If not, ensure it is at least one of\n\t\t\t\t\t\t// the AM tokens. If not, fail the parse for this format.\n\t\t\t\t\t\tpmHour = cal.PM && ( matchGroup === cal.PM[0] || matchGroup === cal.PM[1] || matchGroup === cal.PM[2] );\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!pmHour && (\n\t\t\t\t\t\t\t\t!cal.AM || ( matchGroup !== cal.AM[0] && matchGroup !== cal.AM[1] && matchGroup !== cal.AM[2] )\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"f\":\n\t\t\t\t\t\t// Deciseconds.\n\t\t\t\t\tcase \"ff\":\n\t\t\t\t\t\t// Centiseconds.\n\t\t\t\t\tcase \"fff\":\n\t\t\t\t\t\t// Milliseconds.\n\t\t\t\t\t\tmsec = matchInt * Math.pow( 10, 3 - clength );\n\t\t\t\t\t\tif ( outOfRange(msec, 0, 999) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"ddd\":\n\t\t\t\t\t\t// Day of week.\n\t\t\t\t\tcase \"dddd\":\n\t\t\t\t\t\t// Day of week.\n\t\t\t\t\t\tweekDay = getDayIndex( cal, matchGroup, clength === 3 );\n\t\t\t\t\t\tif ( outOfRange(weekDay, 0, 6) ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"zzz\":\n\t\t\t\t\t\t// Time zone offset in +/- hours:min.\n\t\t\t\t\t\tvar offsets = matchGroup.split( /:/ );\n\t\t\t\t\t\tif ( offsets.length !== 2 ) return null;\n\t\t\t\t\t\thourOffset = parseInt( offsets[0], 10 );\n\t\t\t\t\t\tif ( outOfRange(hourOffset, -12, 13) ) return null;\n\t\t\t\t\t\tvar minOffset = parseInt( offsets[1], 10 );\n\t\t\t\t\t\tif ( outOfRange(minOffset, 0, 59) ) return null;\n\t\t\t\t\t\ttzMinOffset = ( hourOffset * 60 ) + ( startsWith(matchGroup, \"-\") ? -minOffset : minOffset );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"z\": case \"zz\":\n\t\t\t\t\t\t// Time zone offset in +/- hours.\n\t\t\t\t\t\thourOffset = matchInt;\n\t\t\t\t\t\tif ( outOfRange(hourOffset, -12, 13) ) return null;\n\t\t\t\t\t\ttzMinOffset = hourOffset * 60;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"g\": case \"gg\":\n\t\t\t\t\t\tvar eraName = matchGroup;\n\t\t\t\t\t\tif ( !eraName || !cal.eras ) return null;\n\t\t\t\t\t\teraName = trim( eraName.toLowerCase() );\n\t\t\t\t\t\tfor ( var i = 0, l = cal.eras.length; i < l; i++ ) {\n\t\t\t\t\t\t\tif ( eraName === cal.eras[i].name.toLowerCase() ) {\n\t\t\t\t\t\t\t\tera = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// could not find an era with that name\n\t\t\t\t\t\tif ( era === null ) return null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar result = new Date(), defaultYear, convert = cal.convert;\n\t\tdefaultYear = convert ? convert.fromGregorian( result )[ 0 ] : result.getFullYear();\n\t\tif ( year === null ) {\n\t\t\tyear = defaultYear;\n\t\t}\n\t\telse if ( cal.eras ) {\n\t\t\t// year must be shifted to normal gregorian year\n\t\t\t// but not if year was not specified, its already normal gregorian\n\t\t\t// per the main if clause above.\n\t\t\tyear += cal.eras[( era || 0 )].offset;\n\t\t}\n\t\t// set default day and month to 1 and January, so if unspecified, these are the defaults\n\t\t// instead of the current day/month.\n\t\tif ( month === null ) {\n\t\t\tmonth = 0;\n\t\t}\n\t\tif ( date === null ) {\n\t\t\tdate = 1;\n\t\t}\n\t\t// now have year, month, and date, but in the culture's calendar.\n\t\t// convert to gregorian if necessary\n\t\tif ( convert ) {\n\t\t\tresult = convert.toGregorian( year, month, date );\n\t\t\t// conversion failed, must be an invalid match\n\t\t\tif ( result === null ) return null;\n\t\t}\n\t\telse {\n\t\t\t// have to set year, month and date together to avoid overflow based on current date.\n\t\t\tresult.setFullYear( year, month, date );\n\t\t\t// check to see if date overflowed for specified month (only checked 1-31 above).\n\t\t\tif ( result.getDate() !== date ) return null;\n\t\t\t// invalid day of week.\n\t\t\tif ( weekDay !== null && result.getDay() !== weekDay ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// if pm designator token was found make sure the hours fit the 24-hour clock.\n\t\tif ( pmHour && hour < 12 ) {\n\t\t\thour += 12;\n\t\t}\n\t\tresult.setHours( hour, min, sec, msec );\n\t\tif ( tzMinOffset !== null ) {\n\t\t\t// adjust timezone to utc before applying local offset.\n\t\t\tvar adjustedMin = result.getMinutes() - ( tzMinOffset + result.getTimezoneOffset() );\n\t\t\t// Safari limits hours and minutes to the range of -127 to 127.  We need to use setHours\n\t\t\t// to ensure both these fields will not exceed this range.\tadjustedMin will range\n\t\t\t// somewhere between -1440 and 1500, so we only need to split this into hours.\n\t\t\tresult.setHours( result.getHours() + parseInt(adjustedMin / 60, 10), adjustedMin % 60 );\n\t\t}\n\t\treturn result;\n\t};\n}());\n\nparseNegativePattern = function( value, nf, negativePattern ) {\n\tvar neg = nf[ \"-\" ],\n\t\tpos = nf[ \"+\" ],\n\t\tret;\n\tswitch ( negativePattern ) {\n\t\tcase \"n -\":\n\t\t\tneg = \" \" + neg;\n\t\t\tpos = \" \" + pos;\n\t\t\t/* falls through */\n\t\tcase \"n-\":\n\t\t\tif ( endsWith(value, neg) ) {\n\t\t\t\tret = [ \"-\", value.substr(0, value.length - neg.length) ];\n\t\t\t}\n\t\t\telse if ( endsWith(value, pos) ) {\n\t\t\t\tret = [ \"+\", value.substr(0, value.length - pos.length) ];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"- n\":\n\t\t\tneg += \" \";\n\t\t\tpos += \" \";\n\t\t\t/* falls through */\n\t\tcase \"-n\":\n\t\t\tif ( startsWith(value, neg) ) {\n\t\t\t\tret = [ \"-\", value.substr(neg.length) ];\n\t\t\t}\n\t\t\telse if ( startsWith(value, pos) ) {\n\t\t\t\tret = [ \"+\", value.substr(pos.length) ];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"(n)\":\n\t\t\tif ( startsWith(value, \"(\") && endsWith(value, \")\") ) {\n\t\t\t\tret = [ \"-\", value.substr(1, value.length - 2) ];\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn ret || [ \"\", value ];\n};\n\n//\n// public instance functions\n//\n\nGlobalize.prototype.findClosestCulture = function( cultureSelector ) {\n\treturn Globalize.findClosestCulture.call( this, cultureSelector );\n};\n\nGlobalize.prototype.format = function( value, format, cultureSelector ) {\n\treturn Globalize.format.call( this, value, format, cultureSelector );\n};\n\nGlobalize.prototype.localize = function( key, cultureSelector ) {\n\treturn Globalize.localize.call( this, key, cultureSelector );\n};\n\nGlobalize.prototype.parseInt = function( value, radix, cultureSelector ) {\n\treturn Globalize.parseInt.call( this, value, radix, cultureSelector );\n};\n\nGlobalize.prototype.parseFloat = function( value, radix, cultureSelector ) {\n\treturn Globalize.parseFloat.call( this, value, radix, cultureSelector );\n};\n\nGlobalize.prototype.culture = function( cultureSelector ) {\n\treturn Globalize.culture.call( this, cultureSelector );\n};\n\n//\n// public singleton functions\n//\n\nGlobalize.addCultureInfo = function( cultureName, baseCultureName, info ) {\n\n\tvar base = {},\n\t\tisNew = false;\n\n\tif ( typeof cultureName !== \"string\" ) {\n\t\t// cultureName argument is optional string. If not specified, assume info is first\n\t\t// and only argument. Specified info deep-extends current culture.\n\t\tinfo = cultureName;\n\t\tcultureName = this.culture().name;\n\t\tbase = this.cultures[ cultureName ];\n\t} else if ( typeof baseCultureName !== \"string\" ) {\n\t\t// baseCultureName argument is optional string. If not specified, assume info is second\n\t\t// argument. Specified info deep-extends specified culture.\n\t\t// If specified culture does not exist, create by deep-extending default\n\t\tinfo = baseCultureName;\n\t\tisNew = ( this.cultures[ cultureName ] == null );\n\t\tbase = this.cultures[ cultureName ] || this.cultures[ \"default\" ];\n\t} else {\n\t\t// cultureName and baseCultureName specified. Assume a new culture is being created\n\t\t// by deep-extending an specified base culture\n\t\tisNew = true;\n\t\tbase = this.cultures[ baseCultureName ];\n\t}\n\n\tthis.cultures[ cultureName ] = extend(true, {},\n\t\tbase,\n\t\tinfo\n\t);\n\t// Make the standard calendar the current culture if it's a new culture\n\tif ( isNew ) {\n\t\tthis.cultures[ cultureName ].calendar = this.cultures[ cultureName ].calendars.standard;\n\t}\n};\n\nGlobalize.findClosestCulture = function( name ) {\n\tvar match;\n\tif ( !name ) {\n\t\treturn this.findClosestCulture( this.cultureSelector ) || this.cultures[ \"default\" ];\n\t}\n\tif ( typeof name === \"string\" ) {\n\t\tname = name.split( \",\" );\n\t}\n\tif ( isArray(name) ) {\n\t\tvar lang,\n\t\t\tcultures = this.cultures,\n\t\t\tlist = name,\n\t\t\ti, l = list.length,\n\t\t\tprioritized = [];\n\t\tfor ( i = 0; i < l; i++ ) {\n\t\t\tname = trim( list[i] );\n\t\t\tvar pri, parts = name.split( \";\" );\n\t\t\tlang = trim( parts[0] );\n\t\t\tif ( parts.length === 1 ) {\n\t\t\t\tpri = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tname = trim( parts[1] );\n\t\t\t\tif ( name.indexOf(\"q=\") === 0 ) {\n\t\t\t\t\tname = name.substr( 2 );\n\t\t\t\t\tpri = parseFloat( name );\n\t\t\t\t\tpri = isNaN( pri ) ? 0 : pri;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpri = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprioritized.push({ lang: lang, pri: pri });\n\t\t}\n\t\tprioritized.sort(function( a, b ) {\n\t\t\tif ( a.pri < b.pri ) {\n\t\t\t\treturn 1;\n\t\t\t} else if ( a.pri > b.pri ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t});\n\t\t// exact match\n\t\tfor ( i = 0; i < l; i++ ) {\n\t\t\tlang = prioritized[ i ].lang;\n\t\t\tmatch = cultures[ lang ];\n\t\t\tif ( match ) {\n\t\t\t\treturn match;\n\t\t\t}\n\t\t}\n\n\t\t// neutral language match\n\t\tfor ( i = 0; i < l; i++ ) {\n\t\t\tlang = prioritized[ i ].lang;\n\t\t\tdo {\n\t\t\t\tvar index = lang.lastIndexOf( \"-\" );\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// strip off the last part. e.g. en-US => en\n\t\t\t\tlang = lang.substr( 0, index );\n\t\t\t\tmatch = cultures[ lang ];\n\t\t\t\tif ( match ) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile ( 1 );\n\t\t}\n\n\t\t// last resort: match first culture using that language\n\t\tfor ( i = 0; i < l; i++ ) {\n\t\t\tlang = prioritized[ i ].lang;\n\t\t\tfor ( var cultureKey in cultures ) {\n\t\t\t\tvar culture = cultures[ cultureKey ];\n\t\t\t\tif ( culture.language == lang ) {\n\t\t\t\t\treturn culture;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if ( typeof name === \"object\" ) {\n\t\treturn name;\n\t}\n\treturn match || null;\n};\n\nGlobalize.format = function( value, format, cultureSelector ) {\n\tvar culture = this.findClosestCulture( cultureSelector );\n\tif ( value instanceof Date ) {\n\t\tvalue = formatDate( value, format, culture );\n\t}\n\telse if ( typeof value === \"number\" ) {\n\t\tvalue = formatNumber( value, format, culture );\n\t}\n\treturn value;\n};\n\nGlobalize.localize = function( key, cultureSelector ) {\n\treturn this.findClosestCulture( cultureSelector ).messages[ key ] ||\n\t\tthis.cultures[ \"default\" ].messages[ key ];\n};\n\nGlobalize.parseDate = function( value, formats, culture ) {\n\tculture = this.findClosestCulture( culture );\n\n\tvar date, prop, patterns;\n\tif ( formats ) {\n\t\tif ( typeof formats === \"string\" ) {\n\t\t\tformats = [ formats ];\n\t\t}\n\t\tif ( formats.length ) {\n\t\t\tfor ( var i = 0, l = formats.length; i < l; i++ ) {\n\t\t\t\tvar format = formats[ i ];\n\t\t\t\tif ( format ) {\n\t\t\t\t\tdate = parseExact( value, format, culture );\n\t\t\t\t\tif ( date ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpatterns = culture.calendar.patterns;\n\t\tfor ( prop in patterns ) {\n\t\t\tdate = parseExact( value, patterns[prop], culture );\n\t\t\tif ( date ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn date || null;\n};\n\nGlobalize.parseInt = function( value, radix, cultureSelector ) {\n\treturn truncate( Globalize.parseFloat(value, radix, cultureSelector) );\n};\n\nGlobalize.parseFloat = function( value, radix, cultureSelector ) {\n\t// radix argument is optional\n\tif ( typeof radix !== \"number\" ) {\n\t\tcultureSelector = radix;\n\t\tradix = 10;\n\t}\n\n\tvar culture = this.findClosestCulture( cultureSelector );\n\tvar ret = NaN,\n\t\tnf = culture.numberFormat;\n\n\tif ( value.indexOf(culture.numberFormat.currency.symbol) > -1 ) {\n\t\t// remove currency symbol\n\t\tvalue = value.replace( culture.numberFormat.currency.symbol, \"\" );\n\t\t// replace decimal seperator\n\t\tvalue = value.replace( culture.numberFormat.currency[\".\"], culture.numberFormat[\".\"] );\n\t}\n\n\t//Remove percentage character from number string before parsing\n\tif ( value.indexOf(culture.numberFormat.percent.symbol) > -1){\n\t\tvalue = value.replace( culture.numberFormat.percent.symbol, \"\" );\n\t}\n\n\t// remove spaces: leading, trailing and between - and number. Used for negative currency pt-BR\n\tvalue = value.replace( / /g, \"\" );\n\n\t// allow infinity or hexidecimal\n\tif ( regexInfinity.test(value) ) {\n\t\tret = parseFloat( value );\n\t}\n\telse if ( !radix && regexHex.test(value) ) {\n\t\tret = parseInt( value, 16 );\n\t}\n\telse {\n\n\t\t// determine sign and number\n\t\tvar signInfo = parseNegativePattern( value, nf, nf.pattern[0] ),\n\t\t\tsign = signInfo[ 0 ],\n\t\t\tnum = signInfo[ 1 ];\n\n\t\t// #44 - try parsing as \"(n)\"\n\t\tif ( sign === \"\" && nf.pattern[0] !== \"(n)\" ) {\n\t\t\tsignInfo = parseNegativePattern( value, nf, \"(n)\" );\n\t\t\tsign = signInfo[ 0 ];\n\t\t\tnum = signInfo[ 1 ];\n\t\t}\n\n\t\t// try parsing as \"-n\"\n\t\tif ( sign === \"\" && nf.pattern[0] !== \"-n\" ) {\n\t\t\tsignInfo = parseNegativePattern( value, nf, \"-n\" );\n\t\t\tsign = signInfo[ 0 ];\n\t\t\tnum = signInfo[ 1 ];\n\t\t}\n\n\t\tsign = sign || \"+\";\n\n\t\t// determine exponent and number\n\t\tvar exponent,\n\t\t\tintAndFraction,\n\t\t\texponentPos = num.indexOf( \"e\" );\n\t\tif ( exponentPos < 0 ) exponentPos = num.indexOf( \"E\" );\n\t\tif ( exponentPos < 0 ) {\n\t\t\tintAndFraction = num;\n\t\t\texponent = null;\n\t\t}\n\t\telse {\n\t\t\tintAndFraction = num.substr( 0, exponentPos );\n\t\t\texponent = num.substr( exponentPos + 1 );\n\t\t}\n\t\t// determine decimal position\n\t\tvar integer,\n\t\t\tfraction,\n\t\t\tdecSep = nf[ \".\" ],\n\t\t\tdecimalPos = intAndFraction.indexOf( decSep );\n\t\tif ( decimalPos < 0 ) {\n\t\t\tinteger = intAndFraction;\n\t\t\tfraction = null;\n\t\t}\n\t\telse {\n\t\t\tinteger = intAndFraction.substr( 0, decimalPos );\n\t\t\tfraction = intAndFraction.substr( decimalPos + decSep.length );\n\t\t}\n\t\t// handle groups (e.g. 1,000,000)\n\t\tvar groupSep = nf[ \",\" ];\n\t\tinteger = integer.split( groupSep ).join( \"\" );\n\t\tvar altGroupSep = groupSep.replace( /\\u00A0/g, \" \" );\n\t\tif ( groupSep !== altGroupSep ) {\n\t\t\tinteger = integer.split( altGroupSep ).join( \"\" );\n\t\t}\n\t\t// build a natively parsable number string\n\t\tvar p = sign + integer;\n\t\tif ( fraction !== null ) {\n\t\t\tp += \".\" + fraction;\n\t\t}\n\t\tif ( exponent !== null ) {\n\t\t\t// exponent itself may have a number patternd\n\t\t\tvar expSignInfo = parseNegativePattern( exponent, nf, \"-n\" );\n\t\t\tp += \"e\" + ( expSignInfo[0] || \"+\" ) + expSignInfo[ 1 ];\n\t\t}\n\t\tif ( regexParseFloat.test(p) ) {\n\t\t\tret = parseFloat( p );\n\t\t}\n\t}\n\treturn ret;\n};\n\nGlobalize.culture = function( cultureSelector ) {\n\t// setter\n\tif ( typeof cultureSelector !== \"undefined\" ) {\n\t\tthis.cultureSelector = cultureSelector;\n\t}\n\t// getter\n\treturn this.findClosestCulture( cultureSelector ) || this.cultures[ \"default\" ];\n};\n\n}( this ));\n"]},"metadata":{},"sourceType":"script"}