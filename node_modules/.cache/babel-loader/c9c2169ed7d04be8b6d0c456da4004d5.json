{"ast":null,"code":"import cloneDeep from 'lodash/cloneDeep';\nimport { render } from '../utils/render';\nimport { VIDEO_MIME_TYPES } from \"../utils/internalConstants\";\n\nvar HtmlVideoLayer =\n/** @class */\nfunction () {\n  function HtmlVideoLayer(element, userCloudinaryVideo, sources, plugins, videoAttributes) {\n    var _this = this;\n\n    this.mimeType = 'video';\n    this.mimeSubTypes = VIDEO_MIME_TYPES;\n    this.videoElement = element;\n    this.originalVideo = userCloudinaryVideo;\n    this.htmlPluginState = {\n      cleanupCallbacks: [],\n      pluginEventSubscription: []\n    };\n    var pluginCloudinaryVideo = cloneDeep(userCloudinaryVideo);\n    render(element, userCloudinaryVideo, plugins, this.htmlPluginState).then(function () {\n      _this.htmlPluginState.pluginEventSubscription.forEach(function (fn) {\n        fn();\n      });\n\n      _this.setVideoAttributes(videoAttributes);\n\n      _this.handleSourceToVideo(pluginCloudinaryVideo, sources);\n    });\n  }\n  /**\n   * Handles user supplied sources or default sources\n   * @param userCloudinaryVideo {CloudinaryVideo}\n   * @param sources\n   */\n\n\n  HtmlVideoLayer.prototype.handleSourceToVideo = function (userCloudinaryVideo, sources) {\n    var _this = this; // checks if user supplied sources\n\n\n    if (sources) {\n      this.generateUserSources(userCloudinaryVideo, sources);\n    } else {\n      var defaultTypes = ['webm', 'mp4', 'ogg'];\n      defaultTypes.forEach(function (type) {\n        _this.appendSourceTag(userCloudinaryVideo, type);\n      });\n    }\n  };\n  /**\n   * Generate sources based on user input\n   * @param userCloudinaryVideo {CloudinaryVideo}\n   * @param sources\n   */\n\n\n  HtmlVideoLayer.prototype.generateUserSources = function (userCloudinaryVideo, sources) {\n    var _this = this;\n\n    sources.map(function (_a) {\n      var type = _a.type,\n          codecs = _a.codecs,\n          transcode = _a.transcode;\n      return _this.appendSourceTag(cloneDeep(userCloudinaryVideo).transcode(transcode), type, _this.buildMimeType(type, codecs));\n    });\n  };\n  /**\n   * Appends source tag to html video element\n   * @param userCloudinaryVideo {CloudinaryVideo}\n   * @param type {string}\n   * @param mimeType {string}\n   */\n\n\n  HtmlVideoLayer.prototype.appendSourceTag = function (userCloudinaryVideo, type, mimeType) {\n    var source = document.createElement('source');\n    source.src = userCloudinaryVideo.toURL() + \".\" + type;\n    source.type = mimeType ? mimeType : \"video/\" + type;\n    this.videoElement.appendChild(source);\n  };\n  /**\n   * Determines MIME type of given source type and codecs.\n   * @param type - format of the video\n   * @param codecs - optional information about codecs of the video\n   */\n\n\n  HtmlVideoLayer.prototype.buildMimeType = function (type, codecs) {\n    var mimeType = this.mimeType + \"/\" + (this.mimeSubTypes[type] || type);\n\n    if (codecs) {\n      mimeType += \"; codecs=\" + (Array.isArray(codecs) ? codecs.join(', ') : codecs);\n    }\n\n    return mimeType;\n  };\n\n  ;\n  /**\n   * Iterates through the video attributes and sets to true if passed in by the user.\n   * In case of poster, sets the poster.\n   * @param videoAttributes {object} Supported attributes: controls, loop, muted, poster, preload, autoplay, playsinline\n   */\n\n  HtmlVideoLayer.prototype.setVideoAttributes = function (videoAttributes) {\n    if (!videoAttributes) return;\n\n    for (var _i = 0, _a = Object.entries(videoAttributes); _i < _a.length; _i++) {\n      var _b = _a[_i],\n          key = _b[0],\n          value = _b[1];\n\n      if (value) {\n        if (key === 'poster') {\n          this.videoElement.poster = value;\n        } else {\n          this.videoElement[key] = true;\n        }\n      }\n    }\n  };\n  /**\n   * Called when component is updated. If our video source has changed, a video reload is triggered.\n   * @param updatedCloudinaryVideo\n   * @param sources\n   * @param plugins\n   * @param videoAttributes\n   */\n\n\n  HtmlVideoLayer.prototype.update = function (updatedCloudinaryVideo, sources, plugins, videoAttributes) {\n    var _this = this;\n\n    if (updatedCloudinaryVideo !== this.originalVideo) {\n      var sourcesToDelete = this.videoElement.getElementsByTagName(\"SOURCE\");\n\n      while (sourcesToDelete[0]) sourcesToDelete[0].parentNode.removeChild(sourcesToDelete[0]);\n\n      render(this.videoElement, updatedCloudinaryVideo, plugins, this.htmlPluginState).then(function () {\n        _this.setVideoAttributes(videoAttributes);\n\n        _this.handleSourceToVideo(updatedCloudinaryVideo, sources);\n\n        _this.videoElement.load();\n      });\n    }\n  };\n\n  return HtmlVideoLayer;\n}();\n\nexport { HtmlVideoLayer };","map":{"version":3,"sources":["D:/react-myprojects/dss/node_modules/@cloudinary/html/layers/htmlVideoLayer.js"],"names":["cloneDeep","render","VIDEO_MIME_TYPES","HtmlVideoLayer","element","userCloudinaryVideo","sources","plugins","videoAttributes","_this","mimeType","mimeSubTypes","videoElement","originalVideo","htmlPluginState","cleanupCallbacks","pluginEventSubscription","pluginCloudinaryVideo","then","forEach","fn","setVideoAttributes","handleSourceToVideo","prototype","generateUserSources","defaultTypes","type","appendSourceTag","map","_a","codecs","transcode","buildMimeType","source","document","createElement","src","toURL","appendChild","Array","isArray","join","_i","Object","entries","length","_b","key","value","poster","update","updatedCloudinaryVideo","sourcesToDelete","getElementsByTagName","parentNode","removeChild","load"],"mappings":"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","sourcesContent":["import cloneDeep from 'lodash/cloneDeep';\nimport { render } from '../utils/render';\nimport { VIDEO_MIME_TYPES } from \"../utils/internalConstants\";\nvar HtmlVideoLayer = /** @class */ (function () {\n    function HtmlVideoLayer(element, userCloudinaryVideo, sources, plugins, videoAttributes) {\n        var _this = this;\n        this.mimeType = 'video';\n        this.mimeSubTypes = VIDEO_MIME_TYPES;\n        this.videoElement = element;\n        this.originalVideo = userCloudinaryVideo;\n        this.htmlPluginState = { cleanupCallbacks: [], pluginEventSubscription: [] };\n        var pluginCloudinaryVideo = cloneDeep(userCloudinaryVideo);\n        render(element, userCloudinaryVideo, plugins, this.htmlPluginState)\n            .then(function () {\n            _this.htmlPluginState.pluginEventSubscription.forEach(function (fn) { fn(); });\n            _this.setVideoAttributes(videoAttributes);\n            _this.handleSourceToVideo(pluginCloudinaryVideo, sources);\n        });\n    }\n    /**\n     * Handles user supplied sources or default sources\n     * @param userCloudinaryVideo {CloudinaryVideo}\n     * @param sources\n     */\n    HtmlVideoLayer.prototype.handleSourceToVideo = function (userCloudinaryVideo, sources) {\n        var _this = this;\n        // checks if user supplied sources\n        if (sources) {\n            this.generateUserSources(userCloudinaryVideo, sources);\n        }\n        else {\n            var defaultTypes = ['webm', 'mp4', 'ogg'];\n            defaultTypes.forEach(function (type) {\n                _this.appendSourceTag(userCloudinaryVideo, type);\n            });\n        }\n    };\n    /**\n     * Generate sources based on user input\n     * @param userCloudinaryVideo {CloudinaryVideo}\n     * @param sources\n     */\n    HtmlVideoLayer.prototype.generateUserSources = function (userCloudinaryVideo, sources) {\n        var _this = this;\n        sources.map(function (_a) {\n            var type = _a.type, codecs = _a.codecs, transcode = _a.transcode;\n            return (_this.appendSourceTag(cloneDeep(userCloudinaryVideo)\n                .transcode(transcode), type, _this.buildMimeType(type, codecs)));\n        });\n    };\n    /**\n     * Appends source tag to html video element\n     * @param userCloudinaryVideo {CloudinaryVideo}\n     * @param type {string}\n     * @param mimeType {string}\n     */\n    HtmlVideoLayer.prototype.appendSourceTag = function (userCloudinaryVideo, type, mimeType) {\n        var source = document.createElement('source');\n        source.src = userCloudinaryVideo.toURL() + \".\" + type;\n        source.type = mimeType ? mimeType : \"video/\" + type;\n        this.videoElement.appendChild(source);\n    };\n    /**\n     * Determines MIME type of given source type and codecs.\n     * @param type - format of the video\n     * @param codecs - optional information about codecs of the video\n     */\n    HtmlVideoLayer.prototype.buildMimeType = function (type, codecs) {\n        var mimeType = this.mimeType + \"/\" + (this.mimeSubTypes[type] || type);\n        if (codecs) {\n            mimeType += \"; codecs=\" + (Array.isArray(codecs) ? codecs.join(', ') : codecs);\n        }\n        return mimeType;\n    };\n    ;\n    /**\n     * Iterates through the video attributes and sets to true if passed in by the user.\n     * In case of poster, sets the poster.\n     * @param videoAttributes {object} Supported attributes: controls, loop, muted, poster, preload, autoplay, playsinline\n     */\n    HtmlVideoLayer.prototype.setVideoAttributes = function (videoAttributes) {\n        if (!videoAttributes)\n            return;\n        for (var _i = 0, _a = Object.entries(videoAttributes); _i < _a.length; _i++) {\n            var _b = _a[_i], key = _b[0], value = _b[1];\n            if (value) {\n                if (key === 'poster') {\n                    this.videoElement.poster = value;\n                }\n                else {\n                    this.videoElement[key] = true;\n                }\n            }\n        }\n    };\n    /**\n     * Called when component is updated. If our video source has changed, a video reload is triggered.\n     * @param updatedCloudinaryVideo\n     * @param sources\n     * @param plugins\n     * @param videoAttributes\n     */\n    HtmlVideoLayer.prototype.update = function (updatedCloudinaryVideo, sources, plugins, videoAttributes) {\n        var _this = this;\n        if (updatedCloudinaryVideo !== this.originalVideo) {\n            var sourcesToDelete = this.videoElement.getElementsByTagName(\"SOURCE\");\n            while (sourcesToDelete[0])\n                sourcesToDelete[0].parentNode.removeChild(sourcesToDelete[0]);\n            render(this.videoElement, updatedCloudinaryVideo, plugins, this.htmlPluginState)\n                .then(function () {\n                _this.setVideoAttributes(videoAttributes);\n                _this.handleSourceToVideo(updatedCloudinaryVideo, sources);\n                _this.videoElement.load();\n            });\n        }\n    };\n    return HtmlVideoLayer;\n}());\nexport { HtmlVideoLayer };\n"]},"metadata":{},"sourceType":"module"}