{"ast":null,"code":"import _slicedToArray from \"D:/react-myprojects/hrms-airtable/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:/react-myprojects/hrms-airtable/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/react-myprojects/hrms-airtable/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { FlagQualifier } from \"../qualifiers/flag/FlagQualifier\";\nimport { Qualifier } from \"./qualifier/Qualifier\";\nimport { mapToSortedArray } from \"./utils/dataStructureUtils\";\n/**\n * @summary SDK\n * @memberOf SDK\n * @description Defines the category of transformation to perform.\n */\n\nvar Action = /*#__PURE__*/function () {\n  function Action() {\n    _classCallCheck(this, Action);\n\n    // We're using map, to overwrite existing keys. for example:\n    // addParam(w_100).addQualifier(w_200) should result in w_200. and not w_100,w_200\n    this.qualifiers = new Map(); // Unlike regular qualifiers, there can be multiple flags in each url component /fl_1,fl_2/\n    // If the falgs are added to the qualifiers map, only a single flag could exist in a component (it's a map)\n    // So flags are stored separately until the very end because of that reason\n\n    this.flags = [];\n    this.delimiter = ','; // {qualifier}{delimiter}{qualifier} for example: `${'w_100'}${','}${'c_fill'}`\n\n    this.actionTag = ''; // A custom name tag to identify this action in the future\n  }\n\n  _createClass(Action, [{\n    key: \"prepareQualifiers\",\n    value: function prepareQualifiers() {}\n    /**\n     * @description Returns the custom name tag that was given to this action\n     * @return {string}\n     */\n\n  }, {\n    key: \"getActionTag\",\n    value: function getActionTag() {\n      return this.actionTag;\n    }\n    /**\n     * @description Sets the custom name tag for this action\n     * @return {this}\n     */\n\n  }, {\n    key: \"setActionTag\",\n    value: function setActionTag(tag) {\n      this.actionTag = tag;\n      return this;\n    }\n    /**\n     * @description Calls toString() on all child qualifiers (implicitly by using .join()).\n     * @return {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      this.prepareQualifiers();\n      return mapToSortedArray(this.qualifiers, this.flags).join(this.delimiter);\n    }\n    /**\n     * @description Adds the parameter to the action.\n     * @param {SDK.Qualifier} qualifier\n     * @return {this}\n     */\n\n  }, {\n    key: \"addQualifier\",\n    value: function addQualifier(qualifier) {\n      // if string, find the key and value\n      if (typeof qualifier === 'string') {\n        var _qualifier$toLowerCas = qualifier.toLowerCase().split('_'),\n            _qualifier$toLowerCas2 = _slicedToArray(_qualifier$toLowerCas, 2),\n            key = _qualifier$toLowerCas2[0],\n            value = _qualifier$toLowerCas2[1];\n\n        if (key === 'fl') {\n          // if string qualifier is a flag, store it in the flags arrays\n          this.flags.push(new FlagQualifier(value));\n        } else {\n          // if the string qualifier is not a flag, create a new qualifier from it\n          this.qualifiers.set(key, new Qualifier(key, value));\n        }\n      } else {\n        // if a qualifier object, insert to the qualifiers map\n        this.qualifiers.set(qualifier.key, qualifier);\n      }\n\n      return this;\n    }\n    /**\n     * @description Adds a flag to the current action.\n     * @param {Qualifiers.Flag} flag\n     * @return {this}\n     */\n\n  }, {\n    key: \"addFlag\",\n    value: function addFlag(flag) {\n      if (typeof flag === 'string') {\n        this.flags.push(new FlagQualifier(flag));\n      } else {\n        this.flags.push(flag);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"addValueToQualifier\",\n    value: function addValueToQualifier(qualifierKey, qualifierValue) {\n      this.qualifiers.get(qualifierKey).addValue(qualifierValue);\n      return this;\n    }\n  }]);\n\n  return Action;\n}();\n\nexport { Action };","map":{"version":3,"sources":["D:/react-myprojects/hrms-airtable/node_modules/@cloudinary/base/internal/Action.js"],"names":["FlagQualifier","Qualifier","mapToSortedArray","Action","qualifiers","Map","flags","delimiter","actionTag","tag","prepareQualifiers","join","qualifier","toLowerCase","split","key","value","push","set","flag","qualifierKey","qualifierValue","get","addValue"],"mappings":";;;AAAA,SAASA,aAAT,QAA8B,kCAA9B;AACA,SAASC,SAAT,QAA0B,uBAA1B;AACA,SAASC,gBAAT,QAAiC,4BAAjC;AACA;AACA;AACA;AACA;AACA;;IACMC,M;AACF,oBAAc;AAAA;;AACV;AACA;AACA,SAAKC,UAAL,GAAkB,IAAIC,GAAJ,EAAlB,CAHU,CAIV;AACA;AACA;;AACA,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,SAAL,GAAiB,GAAjB,CARU,CAQY;;AACtB,SAAKC,SAAL,GAAiB,EAAjB,CATU,CASW;AACxB;;;;WACD,6BAAoB,CAAG;AACvB;AACJ;AACA;AACA;;;;WACI,wBAAe;AACX,aAAO,KAAKA,SAAZ;AACH;AACD;AACJ;AACA;AACA;;;;WACI,sBAAaC,GAAb,EAAkB;AACd,WAAKD,SAAL,GAAiBC,GAAjB;AACA,aAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;;;;WACI,oBAAW;AACP,WAAKC,iBAAL;AACA,aAAOR,gBAAgB,CAAC,KAAKE,UAAN,EAAkB,KAAKE,KAAvB,CAAhB,CAA8CK,IAA9C,CAAmD,KAAKJ,SAAxD,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;;WACI,sBAAaK,SAAb,EAAwB;AACpB;AACA,UAAI,OAAOA,SAAP,KAAqB,QAAzB,EAAmC;AAAA,oCACVA,SAAS,CAACC,WAAV,GAAwBC,KAAxB,CAA8B,GAA9B,CADU;AAAA;AAAA,YACxBC,GADwB;AAAA,YACnBC,KADmB;;AAE/B,YAAID,GAAG,KAAK,IAAZ,EAAkB;AACd;AACA,eAAKT,KAAL,CAAWW,IAAX,CAAgB,IAAIjB,aAAJ,CAAkBgB,KAAlB,CAAhB;AACH,SAHD,MAIK;AACD;AACA,eAAKZ,UAAL,CAAgBc,GAAhB,CAAoBH,GAApB,EAAyB,IAAId,SAAJ,CAAcc,GAAd,EAAmBC,KAAnB,CAAzB;AACH;AACJ,OAVD,MAWK;AACD;AACA,aAAKZ,UAAL,CAAgBc,GAAhB,CAAoBN,SAAS,CAACG,GAA9B,EAAmCH,SAAnC;AACH;;AACD,aAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;;WACI,iBAAQO,IAAR,EAAc;AACV,UAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC1B,aAAKb,KAAL,CAAWW,IAAX,CAAgB,IAAIjB,aAAJ,CAAkBmB,IAAlB,CAAhB;AACH,OAFD,MAGK;AACD,aAAKb,KAAL,CAAWW,IAAX,CAAgBE,IAAhB;AACH;;AACD,aAAO,IAAP;AACH;;;WACD,6BAAoBC,YAApB,EAAkCC,cAAlC,EAAkD;AAC9C,WAAKjB,UAAL,CAAgBkB,GAAhB,CAAoBF,YAApB,EAAkCG,QAAlC,CAA2CF,cAA3C;AACA,aAAO,IAAP;AACH;;;;;;AAEL,SAASlB,MAAT","sourcesContent":["import { FlagQualifier } from \"../qualifiers/flag/FlagQualifier\";\nimport { Qualifier } from \"./qualifier/Qualifier\";\nimport { mapToSortedArray } from \"./utils/dataStructureUtils\";\n/**\n * @summary SDK\n * @memberOf SDK\n * @description Defines the category of transformation to perform.\n */\nclass Action {\n    constructor() {\n        // We're using map, to overwrite existing keys. for example:\n        // addParam(w_100).addQualifier(w_200) should result in w_200. and not w_100,w_200\n        this.qualifiers = new Map();\n        // Unlike regular qualifiers, there can be multiple flags in each url component /fl_1,fl_2/\n        // If the falgs are added to the qualifiers map, only a single flag could exist in a component (it's a map)\n        // So flags are stored separately until the very end because of that reason\n        this.flags = [];\n        this.delimiter = ','; // {qualifier}{delimiter}{qualifier} for example: `${'w_100'}${','}${'c_fill'}`\n        this.actionTag = ''; // A custom name tag to identify this action in the future\n    }\n    prepareQualifiers() { }\n    /**\n     * @description Returns the custom name tag that was given to this action\n     * @return {string}\n     */\n    getActionTag() {\n        return this.actionTag;\n    }\n    /**\n     * @description Sets the custom name tag for this action\n     * @return {this}\n     */\n    setActionTag(tag) {\n        this.actionTag = tag;\n        return this;\n    }\n    /**\n     * @description Calls toString() on all child qualifiers (implicitly by using .join()).\n     * @return {string}\n     */\n    toString() {\n        this.prepareQualifiers();\n        return mapToSortedArray(this.qualifiers, this.flags).join(this.delimiter);\n    }\n    /**\n     * @description Adds the parameter to the action.\n     * @param {SDK.Qualifier} qualifier\n     * @return {this}\n     */\n    addQualifier(qualifier) {\n        // if string, find the key and value\n        if (typeof qualifier === 'string') {\n            const [key, value] = qualifier.toLowerCase().split('_');\n            if (key === 'fl') {\n                // if string qualifier is a flag, store it in the flags arrays\n                this.flags.push(new FlagQualifier(value));\n            }\n            else {\n                // if the string qualifier is not a flag, create a new qualifier from it\n                this.qualifiers.set(key, new Qualifier(key, value));\n            }\n        }\n        else {\n            // if a qualifier object, insert to the qualifiers map\n            this.qualifiers.set(qualifier.key, qualifier);\n        }\n        return this;\n    }\n    /**\n     * @description Adds a flag to the current action.\n     * @param {Qualifiers.Flag} flag\n     * @return {this}\n     */\n    addFlag(flag) {\n        if (typeof flag === 'string') {\n            this.flags.push(new FlagQualifier(flag));\n        }\n        else {\n            this.flags.push(flag);\n        }\n        return this;\n    }\n    addValueToQualifier(qualifierKey, qualifierValue) {\n        this.qualifiers.get(qualifierKey).addValue(qualifierValue);\n        return this;\n    }\n}\nexport { Action };\n"]},"metadata":{},"sourceType":"module"}