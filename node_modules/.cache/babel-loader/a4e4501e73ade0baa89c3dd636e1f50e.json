{"ast":null,"code":"/**\n * Globalize v1.7.0\n *\n * https://github.com/globalizejs/globalize\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2021-08-02T11:53Z\n */\n\n/*!\n * Globalize v1.7.0 2021-08-02T11:53Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function (root, factory) {\n  // UMD returnExports\n  if (typeof define === \"function\" && define.amd) {\n    // AMD\n    define([\"cldr\", \"../globalize\", \"cldr/event\", \"cldr/supplemental\"], factory);\n  } else if (typeof exports === \"object\") {\n    // Node, CommonJS\n    module.exports = factory(require(\"cldrjs\"), require(\"../globalize\"));\n  } else {\n    // Global\n    factory(root.Cldr, root.Globalize);\n  }\n})(this, function (Cldr, Globalize) {\n  var createError = Globalize._createError,\n      partsJoin = Globalize._partsJoin,\n      partsPush = Globalize._partsPush,\n      regexpEscape = Globalize._regexpEscape,\n      runtimeBind = Globalize._runtimeBind,\n      stringPad = Globalize._stringPad,\n      validateCldr = Globalize._validateCldr,\n      validateDefaultLocale = Globalize._validateDefaultLocale,\n      validateParameterPresence = Globalize._validateParameterPresence,\n      validateParameterRange = Globalize._validateParameterRange,\n      validateParameterType = Globalize._validateParameterType,\n      validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;\n\n  var createErrorUnsupportedFeature = function (feature) {\n    return createError(\"E_UNSUPPORTED\", \"Unsupported {feature}.\", {\n      feature: feature\n    });\n  };\n\n  var validateParameterTypeNumber = function (value, name) {\n    validateParameterType(value, name, value === undefined || typeof value === \"number\", \"Number\");\n  };\n\n  var validateParameterTypeString = function (value, name) {\n    validateParameterType(value, name, value === undefined || typeof value === \"string\", \"a string\");\n  };\n\n  var numberFormatterFn = function (numberToPartsFormatter) {\n    return function numberFormatter(value) {\n      return partsJoin(numberToPartsFormatter(value));\n    };\n  };\n  /**\n   * NumberingSystem( cldr )\n   *\n   * - http://www.unicode.org/reports/tr35/tr35-numbers.html#otherNumberingSystems\n   * - http://cldr.unicode.org/index/bcp47-extension\n   * - http://www.unicode.org/reports/tr35/#u_Extension\n   */\n\n\n  var numberNumberingSystem = function (cldr) {\n    var nu = cldr.attributes[\"u-nu\"];\n\n    if (nu) {\n      if (nu === \"traditio\") {\n        nu = \"traditional\";\n      }\n\n      if ([\"native\", \"traditional\", \"finance\"].indexOf(nu) !== -1) {\n        // Unicode locale extension `u-nu` is set using either (native, traditional or\n        // finance). So, lookup the respective locale's numberingSystem and return it.\n        return cldr.main([\"numbers/otherNumberingSystems\", nu]);\n      } // Unicode locale extension `u-nu` is set with an explicit numberingSystem. Return it.\n\n\n      return nu;\n    } // Return the default numberingSystem.\n\n\n    return cldr.main(\"numbers/defaultNumberingSystem\");\n  };\n  /**\n   * Compact( name, cldr )\n   *\n   * @compactType [String] Compact mode, `short` or `long`.\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return the localized compact map for the given compact mode.\n   */\n\n\n  var numberCompact = function (compactType, cldr) {\n    var maxExponent = 0;\n    var object = cldr.main([\"numbers/decimalFormats-numberSystem-\" + numberNumberingSystem(cldr), compactType, \"decimalFormat\"]);\n    object = Object.keys(object).reduce(function (newObject, compactKey) {\n      var numberExponent = compactKey.split(\"0\").length - 1;\n      var pluralForm = compactKey.split(\"-\")[2];\n      newObject[numberExponent] = newObject[numberExponent] || {};\n      newObject[numberExponent][pluralForm] = object[compactKey];\n      maxExponent = Math.max(numberExponent, maxExponent);\n      return newObject;\n    }, {});\n    object.maxExponent = maxExponent;\n    return object;\n  };\n  /**\n   * nuMap( cldr )\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return digits map if numbering system is different than `latn`.\n   */\n\n\n  var numberNumberingSystemDigitsMap = function (cldr) {\n    var aux,\n        nu = numberNumberingSystem(cldr);\n\n    if (nu === \"latn\") {\n      return;\n    }\n\n    aux = cldr.supplemental([\"numberingSystems\", nu]);\n\n    if (aux._type !== \"numeric\") {\n      throw createErrorUnsupportedFeature(\"`\" + aux._type + \"` numbering system\");\n    }\n\n    return aux._digits;\n  };\n  /**\n   * EBNF representation:\n   *\n   * number_pattern_re =        prefix?\n   *                            padding?\n   *                            (integer_fraction_pattern | significant_pattern)\n   *                            scientific_notation?\n   *                            suffix?\n   *\n   * prefix =                   non_number_stuff\n   *\n   * padding =                  \"*\" regexp(.)\n   *\n   * integer_fraction_pattern = integer_pattern\n   *                            fraction_pattern?\n   *\n   * integer_pattern =          regexp([#,]*[0,]*0+)\n   *\n   * fraction_pattern =         \".\" regexp(0*[0-9]*#*)\n   *\n   * significant_pattern =      regexp([#,]*@+#*)\n   *\n   * scientific_notation =      regexp(E\\+?0+)\n   *\n   * suffix =                   non_number_stuff\n   *\n   * non_number_stuff =         regexp(('[^']+'|''|[^*#@0,.E])*)\n   *\n   *\n   * Regexp groups:\n   *\n   *  0: number_pattern_re\n   *  1: prefix\n   *  2: -\n   *  3: -\n   *  4: padding\n   *  5: (integer_fraction_pattern | significant_pattern)\n   *  6: integer_fraction_pattern\n   *  7: integer_pattern\n   *  8: fraction_pattern\n   *  9: significant_pattern\n   * 10: scientific_notation\n   * 11: suffix\n   * 12: -\n   */\n\n\n  var numberPatternRe = /^(('([^']|'')*'|[^*#@0,.E])*)(\\*.)?((([#,]*[0,]*0+)(\\.0*[0-9]*#*)?)|([#,]*@+#*))(E\\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/;\n  /**\n   * format( number, pattern )\n   *\n   * @number [Number].\n   *\n   * @pattern [String] raw pattern for numbers.\n   *\n   * Return the formatted number.\n   * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n   */\n\n  var numberPatternProperties = function (pattern) {\n    var aux1, aux2, fractionPattern, integerFractionOrSignificantPattern, integerPattern, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits, minimumIntegerDigits, minimumSignificantDigits, padding, prefix, primaryGroupingSize, roundIncrement, scientificNotation, secondaryGroupingSize, significantPattern, suffix;\n    pattern = pattern.match(numberPatternRe);\n\n    if (!pattern) {\n      throw new Error(\"Invalid pattern: \" + pattern);\n    }\n\n    prefix = pattern[1];\n    padding = pattern[4];\n    integerFractionOrSignificantPattern = pattern[5];\n    significantPattern = pattern[9];\n    scientificNotation = pattern[10];\n    suffix = pattern[11]; // Significant digit format\n\n    if (significantPattern) {\n      significantPattern.replace(/(@+)(#*)/, function (_match, minimumSignificantDigitsMatch, maximumSignificantDigitsMatch) {\n        minimumSignificantDigits = minimumSignificantDigitsMatch.length;\n        maximumSignificantDigits = minimumSignificantDigits + maximumSignificantDigitsMatch.length;\n      }); // Integer and fractional format\n    } else {\n      fractionPattern = pattern[8];\n      integerPattern = pattern[7];\n\n      if (fractionPattern) {\n        // Minimum fraction digits, and rounding.\n        fractionPattern.replace(/[0-9]+/, function (match) {\n          minimumFractionDigits = match;\n        });\n\n        if (minimumFractionDigits) {\n          roundIncrement = +(\"0.\" + minimumFractionDigits);\n          minimumFractionDigits = minimumFractionDigits.length;\n        } else {\n          minimumFractionDigits = 0;\n        } // Maximum fraction digits\n        // 1: ignore decimal character\n\n\n        maximumFractionDigits = fractionPattern.length - 1;\n        /* 1 */\n      } else {\n        minimumFractionDigits = 0;\n        maximumFractionDigits = 0;\n      } // Minimum integer digits\n\n\n      integerPattern.replace(/0+$/, function (match) {\n        minimumIntegerDigits = match.length;\n      });\n    } // Scientific notation\n\n\n    if (scientificNotation) {\n      throw createErrorUnsupportedFeature({\n        feature: \"scientific notation (not implemented)\"\n      });\n    } // Padding\n\n\n    if (padding) {\n      throw createErrorUnsupportedFeature({\n        feature: \"padding (not implemented)\"\n      });\n    } // Grouping\n\n\n    if ((aux1 = integerFractionOrSignificantPattern.lastIndexOf(\",\")) !== -1) {\n      // Primary grouping size is the interval between the last group separator and the end of\n      // the integer (or the end of the significant pattern).\n      aux2 = integerFractionOrSignificantPattern.split(\".\")[0];\n      primaryGroupingSize = aux2.length - aux1 - 1; // Secondary grouping size is the interval between the last two group separators.\n\n      if ((aux2 = integerFractionOrSignificantPattern.lastIndexOf(\",\", aux1 - 1)) !== -1) {\n        secondaryGroupingSize = aux1 - 1 - aux2;\n      }\n    } // Return:\n    //  0: @prefix String\n    //  1: @padding Array [ <character>, <count> ] TODO\n    //  2: @minimumIntegerDigits non-negative integer Number value indicating the minimum integer\n    //        digits to be used. Numbers will be padded with leading zeroes if necessary.\n    //  3: @minimumFractionDigits and\n    //  4: @maximumFractionDigits are non-negative integer Number values indicating the minimum and\n    //        maximum fraction digits to be used. Numbers will be rounded or padded with trailing\n    //        zeroes if necessary.\n    //  5: @minimumSignificantDigits and\n    //  6: @maximumSignificantDigits are positive integer Number values indicating the minimum and\n    //        maximum fraction digits to be shown. Either none or both of these properties are\n    //        present; if they are, they override minimum and maximum integer and fraction digits\n    //        – the formatter uses however many integer and fraction digits are required to display\n    //        the specified number of significant digits.\n    //  7: @roundIncrement Decimal round increment or null\n    //  8: @primaryGroupingSize\n    //  9: @secondaryGroupingSize\n    // 10: @suffix String\n\n\n    return [prefix, padding, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, roundIncrement, primaryGroupingSize, secondaryGroupingSize, suffix];\n  };\n  /**\n   * Symbol( name, cldr )\n   *\n   * @name [String] Symbol name.\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return the localized symbol given its name.\n   */\n\n\n  var numberSymbol = function (name, cldr) {\n    return cldr.main([\"numbers/symbols-numberSystem-\" + numberNumberingSystem(cldr), name]);\n  };\n\n  var numberSymbolName = {\n    \".\": \"decimal\",\n    \",\": \"group\",\n    \"%\": \"percentSign\",\n    \"+\": \"plusSign\",\n    \"-\": \"minusSign\",\n    \"E\": \"exponential\",\n    \"\\u2030\": \"perMille\"\n  };\n  /**\n   * symbolMap( cldr )\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return the (localized symbol, pattern symbol) key value pair, eg. {\n   *   \".\": \"٫\",\n   *   \",\": \"٬\",\n   *   \"%\": \"٪\",\n   *   ...\n   * };\n   */\n\n  var numberSymbolMap = function (cldr) {\n    var symbol,\n        symbolMap = {};\n\n    for (symbol in numberSymbolName) {\n      symbolMap[symbol] = numberSymbol(numberSymbolName[symbol], cldr);\n    }\n\n    return symbolMap;\n  };\n\n  var numberTruncate = function (value) {\n    if (isNaN(value)) {\n      return NaN;\n    }\n\n    return Math[value < 0 ? \"ceil\" : \"floor\"](value);\n  };\n  /**\n   * round( method )\n   *\n   * @method [String] with either \"round\", \"ceil\", \"floor\", or \"truncate\".\n   *\n   * Return function( value, incrementOrExp ):\n   *\n   *   @value [Number] eg. 123.45.\n   *\n   *   @incrementOrExp [Number] optional, eg. 0.1; or\n   *     [Object] Either { increment: <value> } or { exponent: <value> }\n   *\n   *   Return the rounded number, eg:\n   *   - round( \"round\" )( 123.45 ): 123;\n   *   - round( \"ceil\" )( 123.45 ): 124;\n   *   - round( \"floor\" )( 123.45 ): 123;\n   *   - round( \"truncate\" )( 123.45 ): 123;\n   *   - round( \"round\" )( 123.45, 0.1 ): 123.5;\n   *   - round( \"round\" )( 123.45, 10 ): 120;\n   *\n   *   Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\n   *   Ref: #376\n   */\n\n\n  var numberRound = function (method) {\n    method = method || \"round\";\n    method = method === \"truncate\" ? numberTruncate : Math[method];\n    return function (value, incrementOrExp) {\n      var exp, increment;\n      value = +value; // If the value is not a number, return NaN.\n\n      if (isNaN(value)) {\n        return NaN;\n      } // Exponent given.\n\n\n      if (typeof incrementOrExp === \"object\" && incrementOrExp.exponent) {\n        exp = +incrementOrExp.exponent;\n        increment = 1;\n\n        if (exp === 0) {\n          return method(value);\n        } // If the exp is not an integer, return NaN.\n\n\n        if (!(typeof exp === \"number\" && exp % 1 === 0)) {\n          return NaN;\n        } // Increment given.\n\n      } else {\n        increment = +incrementOrExp || 1;\n\n        if (increment === 1) {\n          return method(value);\n        } // If the increment is not a number, return NaN.\n\n\n        if (isNaN(increment)) {\n          return NaN;\n        }\n\n        increment = increment.toExponential().split(\"e\");\n        exp = +increment[1];\n        increment = +increment[0];\n      } // Shift & Round\n\n\n      value = value.toString().split(\"e\");\n      value[0] = +value[0] / increment;\n      value[1] = value[1] ? +value[1] - exp : -exp;\n      value = method(+(value[0] + \"e\" + value[1])); // Shift back\n\n      value = value.toString().split(\"e\");\n      value[0] = +value[0] * increment;\n      value[1] = value[1] ? +value[1] + exp : exp;\n      return +(value[0] + \"e\" + value[1]);\n    };\n  };\n  /**\n   * formatProperties( pattern, cldr [, options] )\n   *\n   * @pattern [String] raw pattern for numbers.\n   *\n   * @cldr [Cldr instance].\n   *\n   * @options [Object]:\n   * - minimumIntegerDigits [Number]\n   * - minimumFractionDigits, maximumFractionDigits [Number]\n   * - minimumSignificantDigits, maximumSignificantDigits [Number]\n   * - round [String] \"ceil\", \"floor\", \"round\" (default), or \"truncate\".\n   * - useGrouping [Boolean] default true.\n   *\n   * Return the processed properties that will be used in number/format.\n   * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n   */\n\n\n  var numberFormatProperties = function (pattern, cldr, options) {\n    var negativePattern, negativePrefix, negativeProperties, negativeSuffix, positivePattern, roundFn, properties;\n\n    function getOptions(attribute, propertyIndex) {\n      if (attribute in options) {\n        properties[propertyIndex] = options[attribute];\n      }\n    }\n\n    options = options || {};\n    pattern = pattern.split(\";\");\n    positivePattern = pattern[0];\n    negativePattern = pattern[1] || \"-\" + positivePattern;\n    negativeProperties = numberPatternProperties(negativePattern);\n    negativePrefix = negativeProperties[0];\n    negativeSuffix = negativeProperties[10]; // Have runtime code to refer to numberRound() instead of including it explicitly.\n\n    roundFn = numberRound(options.round);\n\n    roundFn.generatorString = function () {\n      return \"numberRound(\" + (options.round ? \"\\\"\" + options.round + \"\\\"\" : \"\") + \")\";\n    };\n\n    properties = numberPatternProperties(positivePattern).concat([positivePattern, negativePrefix + positivePattern + negativeSuffix, negativePrefix, negativeSuffix, roundFn, numberSymbol(\"infinity\", cldr), numberSymbol(\"nan\", cldr), numberSymbolMap(cldr), numberNumberingSystemDigitsMap(cldr)]);\n\n    if (options.compact) {\n      // The compact digits number pattern is always `0+`, so override the following properties.\n      // Note: minimumIntegerDigits would actually range from `0` to `000` based on the scale of\n      // the value to be formatted, though we're always using 1 as a simplification, because the\n      // number won't be zero-padded since we chose the right format based on the scale, i.e.,\n      // we'd never see something like `003M` anyway.\n      properties[2] = 1; // minimumIntegerDigits\n\n      properties[3] = 0; // minimumFractionDigits\n\n      properties[4] = 0; // maximumFractionDigits\n\n      properties[5] = // minimumSignificantDigits &\n      properties[6] = undefined; // maximumSignificantDigits\n\n      properties[20] = numberCompact(options.compact, cldr);\n    }\n\n    getOptions(\"minimumIntegerDigits\", 2);\n    getOptions(\"minimumFractionDigits\", 3);\n    getOptions(\"maximumFractionDigits\", 4);\n    getOptions(\"minimumSignificantDigits\", 5);\n    getOptions(\"maximumSignificantDigits\", 6); // Grouping separators\n\n    if (options.useGrouping === false) {\n      properties[8] = null;\n    } // Normalize number of digits if only one of either minimumFractionDigits or\n    // maximumFractionDigits is passed in as an option\n\n\n    if (\"minimumFractionDigits\" in options && !(\"maximumFractionDigits\" in options)) {\n      // maximumFractionDigits = Math.max( minimumFractionDigits, maximumFractionDigits );\n      properties[4] = Math.max(properties[3], properties[4]);\n    } else if (!(\"minimumFractionDigits\" in options) && \"maximumFractionDigits\" in options) {\n      // minimumFractionDigits = Math.min( minimumFractionDigits, maximumFractionDigits );\n      properties[3] = Math.min(properties[3], properties[4]);\n    } // Return:\n    // 0-10: see number/pattern-properties.\n    // 11: @positivePattern [String] Positive pattern.\n    // 12: @negativePattern [String] Negative pattern.\n    // 13: @negativePrefix [String] Negative prefix.\n    // 14: @negativeSuffix [String] Negative suffix.\n    // 15: @round [Function] Round function.\n    // 16: @infinitySymbol [String] Infinity symbol.\n    // 17: @nanSymbol [String] NaN symbol.\n    // 18: @symbolMap [Object] A bunch of other symbols.\n    // 19: @nuDigitsMap [Array] Digits map if numbering system is different than `latn`.\n    // 20: @compactMap [Object] Map of per-digit-count format patterns for specified compact mode.\n\n\n    return properties;\n  };\n  /**\n   * Generated by:\n   *\n   * var regenerate = require( \"regenerate\" );\n   * var formatSymbols = require( \"@unicode/unicode-13.0.0/General_Category/Format/symbols\" );\n   * regenerate().add( formatSymbols ).toString();\n   *\n   * https://github.com/mathiasbynens/regenerate\n   * https://github.com/node-unicode/unicode-13.0.0\n   */\n\n\n  var regexpCfG = /[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u08E2\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804[\\uDCBD\\uDCCD]|\\uD80D[\\uDC30-\\uDC38]|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/g;\n  /**\n   * Generated by:\n   *\n   * var regenerate = require( \"regenerate\" );\n   * var dashSymbols = require( \"https://github.com/node-unicode/unicode-13.0.0/General_Category/Dash_Punctuation/symbols\" );\n   * regenerate().add( dashSymbols ).toString();\n   *\n   * https://github.com/mathiasbynens/regenerate\n   * https://github.com/node-unicode/unicode-13.0.0\n   *\n   * NOTE: In addition to [:dash:],  the below includes MINUS SIGN U+2212.\n   */\n\n  var regexpDashG = /[\\x2D\\u058A\\u05BE\\u1400\\u1806\\u2010-\\u2015\\u2E17\\u2E1A\\u2E3A\\u2E3B\\u2E40\\u301C\\u3030\\u30A0\\uFE31\\uFE32\\uFE58\\uFE63\\uFF0D\\u2212]|\\uD803\\uDEAD/g;\n  /**\n   * Generated by:\n   *\n   * var regenerate = require( \"regenerate\" );\n   * var spaceSeparatorSymbols = require( \"@unicode/unicode-13.0.0/General_Category/Space_Separator/symbols\" );\n   * regenerate().add( spaceSeparatorSymbols ).toString();\n   *\n   * https://github.com/mathiasbynens/regenerate\n   * https://github.com/node-unicode/unicode-13.0.0\n   */\n\n  var regexpZsG = /[ \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/g;\n  /**\n   * Loose Matching:\n   * - Ignore all format characters, which includes RLM, LRM or ALM used to control BIDI\n   *   formatting.\n   * - Map all characters in [:Zs:] to U+0020 SPACE;\n   * - Map all characters in [:Dash:] to U+002D HYPHEN-MINUS;\n   */\n\n  var looseMatching = function (value) {\n    return value.replace(regexpCfG, \"\").replace(regexpDashG, \"-\").replace(regexpZsG, \" \");\n  };\n  /**\n   * parse( value, properties )\n   *\n   * @value [String].\n   *\n   * @properties [Object] Parser properties is a reduced pre-processed cldr\n   * data set returned by numberParserProperties().\n   *\n   * Return the parsed Number (including Infinity) or NaN when value is invalid.\n   * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n   */\n\n\n  var numberParse = function (value, properties) {\n    var grammar, invertedNuDigitsMap, invertedSymbolMap, negative, number, prefix, prefixNSuffix, suffix, tokenizer, valid; // Grammar:\n    // - Value <=           NaN | PositiveNumber | NegativeNumber\n    // - PositiveNumber <=  PositivePrefix NumberOrInf PositiveSufix\n    // - NegativeNumber <=  NegativePrefix NumberOrInf\n    // - NumberOrInf <=     Number | Inf\n\n    grammar = [[\"nan\"], [\"prefix\", \"infinity\", \"suffix\"], [\"prefix\", \"number\", \"suffix\"], [\"negativePrefix\", \"infinity\", \"negativeSuffix\"], [\"negativePrefix\", \"number\", \"negativeSuffix\"]];\n    invertedSymbolMap = properties[0];\n    invertedNuDigitsMap = properties[1] || {};\n    tokenizer = properties[2];\n    value = looseMatching(value);\n\n    function parse(type) {\n      return function (lexeme) {\n        // Reverse localized symbols and numbering system.\n        lexeme = lexeme.split(\"\").map(function (character) {\n          return invertedSymbolMap[character] || invertedNuDigitsMap[character] || character;\n        }).join(\"\");\n\n        switch (type) {\n          case \"infinity\":\n            number = Infinity;\n            break;\n\n          case \"nan\":\n            number = NaN;\n            break;\n\n          case \"number\":\n            // Remove grouping separators.\n            lexeme = lexeme.replace(/,/g, \"\");\n            number = +lexeme;\n            break;\n\n          case \"prefix\":\n          case \"negativePrefix\":\n            prefix = lexeme;\n            break;\n\n          case \"suffix\":\n            suffix = lexeme;\n            break;\n\n          case \"negativeSuffix\":\n            suffix = lexeme;\n            negative = true;\n            break;\n          // This should never be reached.\n\n          default:\n            throw new Error(\"Internal error\");\n        }\n\n        return \"\";\n      };\n    }\n\n    function tokenizeNParse(_value, grammar) {\n      return grammar.some(function (statement) {\n        var value = _value; // The whole grammar statement should be used (i.e., .every() return true) and value be\n        // entirely consumed (i.e., !value.length).\n\n        return statement.every(function (type) {\n          if (value.match(tokenizer[type]) === null) {\n            return false;\n          } // Consume and parse it.\n\n\n          value = value.replace(tokenizer[type], parse(type));\n          return true;\n        }) && !value.length;\n      });\n    }\n\n    valid = tokenizeNParse(value, grammar); // NaN\n\n    if (!valid || isNaN(number)) {\n      return NaN;\n    }\n\n    prefixNSuffix = \"\" + prefix + suffix; // Percent\n\n    if (prefixNSuffix.indexOf(\"%\") !== -1) {\n      number /= 100; // Per mille\n    } else if (prefixNSuffix.indexOf(\"\\u2030\") !== -1) {\n      number /= 1000;\n    } // Negative number\n\n\n    if (negative) {\n      number *= -1;\n    }\n\n    return number;\n  };\n\n  var numberParserFn = function (properties) {\n    return function numberParser(value) {\n      validateParameterPresence(value, \"value\");\n      validateParameterTypeString(value, \"value\");\n      return numberParse(value, properties);\n    };\n  };\n  /**\n   * symbolMap( cldr )\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return the (localized symbol, pattern symbol) key value pair, eg. {\n   *   \"٫\": \".\",\n   *   \"٬\": \",\",\n   *   \"٪\": \"%\",\n   *   ...\n   * };\n   */\n\n\n  var numberSymbolInvertedMap = function (cldr) {\n    var symbol,\n        symbolMap = {};\n\n    for (symbol in numberSymbolName) {\n      symbolMap[numberSymbol(numberSymbolName[symbol], cldr)] = symbol;\n    }\n\n    return symbolMap;\n  };\n  /**\n   * objectMap( object, fn)\n   *\n   * - object\n   *\n   * - fn( pair ) => pair\n   */\n\n\n  var objectMap = function (object, fn) {\n    return Object.keys(object).map(function (key) {\n      return fn([key, object[key]]);\n    }).reduce(function (object, pair) {\n      object[pair[0]] = pair[1];\n      return object;\n    }, {});\n  };\n  /**\n   * removeLiteralQuotes( string )\n   *\n   * Return:\n   * - `'` if input string is `''`.\n   * - `o'clock` if input string is `'o''clock'`.\n   * - `foo` if input string is `foo`, i.e., return the same value in case it isn't a single-quoted\n   *   string.\n   */\n\n\n  var removeLiteralQuotes = function (string) {\n    if (string[0] + string[string.length - 1] !== \"''\") {\n      return string;\n    }\n\n    if (string === \"''\") {\n      return \"'\";\n    }\n\n    return string.replace(/''/g, \"'\").slice(1, -1);\n  };\n  /**\n   * parseProperties( pattern, cldr )\n   *\n   * @pattern [String] raw pattern for numbers.\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return parser properties, used to feed parser function.\n   *\n   * TODO:\n   * - Scientific_notation;\n   * - Padding;\n   */\n\n\n  var numberParseProperties = function (pattern, cldr, options) {\n    var aux,\n        decimalSymbolRe,\n        digitsRe,\n        groupingSeparatorRe,\n        infinitySymbol,\n        invertedNuDigitsMap,\n        invertedSymbolMap,\n        maximumFractionDigits,\n        maximumSignificantDigits,\n        minimumSignificantDigits,\n        nanSymbol,\n        negativePrefix,\n        negativeSuffix,\n        nuDigitsMap,\n        numberTokenizer,\n        prefix,\n        primaryGroupingSize,\n        secondaryGroupingSize,\n        suffix,\n        symbolMap,\n        formatProperties = numberFormatProperties(pattern, cldr, options);\n    prefix = looseMatching(formatProperties[0]);\n    maximumFractionDigits = formatProperties[4];\n    minimumSignificantDigits = formatProperties[5];\n    maximumSignificantDigits = formatProperties[6];\n    primaryGroupingSize = formatProperties[8];\n    secondaryGroupingSize = formatProperties[9];\n    suffix = looseMatching(formatProperties[10]);\n    negativePrefix = looseMatching(formatProperties[13]);\n    negativeSuffix = looseMatching(formatProperties[14]);\n    infinitySymbol = looseMatching(formatProperties[16]);\n    nanSymbol = looseMatching(formatProperties[17]);\n    symbolMap = objectMap(formatProperties[18], function (pair) {\n      return [pair[0], looseMatching(pair[1])];\n    });\n    nuDigitsMap = formatProperties[19];\n    invertedSymbolMap = objectMap(numberSymbolInvertedMap(cldr), function (pair) {\n      return [looseMatching(pair[0]), pair[1]];\n    });\n    digitsRe = nuDigitsMap ? \"[\" + nuDigitsMap + \"]\" : \"\\\\d\";\n    groupingSeparatorRe = regexpEscape(symbolMap[\",\"]);\n    decimalSymbolRe = regexpEscape(symbolMap[\".\"]);\n\n    if (nuDigitsMap) {\n      invertedNuDigitsMap = nuDigitsMap.split(\"\").reduce(function (object, localizedDigit, i) {\n        object[localizedDigit] = String(i);\n        return object;\n      }, {});\n    }\n\n    aux = [prefix, suffix, negativePrefix, negativeSuffix].map(function (value) {\n      return value.replace(/('([^']|'')+'|'')|./g, function (character, literal) {\n        // Literals\n        if (literal) {\n          return removeLiteralQuotes(literal);\n        } // Symbols\n\n\n        character = character.replace(/[\\-+E%\\u2030]/, function (symbol) {\n          return symbolMap[symbol];\n        });\n        return character;\n      });\n    });\n    prefix = aux[0];\n    suffix = aux[1];\n    negativePrefix = aux[2];\n    negativeSuffix = aux[3]; // Number\n    //\n    // number_re =                       integer fraction?\n    //\n    // integer =                         digits | digits_using_grouping_separators\n    //\n    // fraction =                        regexp((.\\d+)?)\n    //\n    // digits =                          regexp(\\d+)\n    //\n    // digits_w_grouping_separators =    digits_w_1_grouping_separators |\n    //                                   digits_w_2_grouping_separators\n    //\n    // digits_w_1_grouping_separators =  regexp(\\d{1,3}(,\\d{3})+)\n    //\n    // digits_w_2_grouping_separators =  regexp(\\d{1,2}((,\\d{2})*(,\\d{3})))\n    // Integer part\n\n    numberTokenizer = digitsRe + \"+\"; // Grouping separators\n\n    if (primaryGroupingSize) {\n      if (secondaryGroupingSize) {\n        aux = digitsRe + \"{1,\" + secondaryGroupingSize + \"}((\" + groupingSeparatorRe + digitsRe + \"{\" + secondaryGroupingSize + \"})*(\" + groupingSeparatorRe + digitsRe + \"{\" + primaryGroupingSize + \"}))\";\n      } else {\n        aux = digitsRe + \"{1,\" + primaryGroupingSize + \"}(\" + groupingSeparatorRe + digitsRe + \"{\" + primaryGroupingSize + \"})+\";\n      }\n\n      numberTokenizer = \"(\" + aux + \"|\" + numberTokenizer + \")\";\n    } // Fraction part? Only included if 1 or 2.\n    // 1: Using significant digit format.\n    // 2: Using integer and fractional format && it has a maximumFractionDigits.\n\n\n    if (!isNaN(minimumSignificantDigits * maximumSignificantDigits) ||\n    /* 1 */\n    maximumFractionDigits\n    /* 2 */\n    ) {\n        // 1: Handle trailing decimal separator, e.g., `\"1.\" => `1``.\n        aux = decimalSymbolRe + digitsRe + \"+\";\n        numberTokenizer = numberTokenizer + \"(\" + aux + \"|\" + decimalSymbolRe\n        /* 1 */\n        + \")?\" + // Handle non-padded decimals, e.g., `\".12\"` => `0.12` by making the integer part\n        // optional.\n        \"|(\" + numberTokenizer + \")?\" + aux;\n        numberTokenizer = \"(\" + numberTokenizer + \")\";\n      } // 0: @invertedSymbolMap [Object] Inverted symbol map.\n    // 1: @invertedNuDigitsMap [Object] Inverted digits map if numbering system is different than\n    //    `latn`.\n    // 2: @tokenizer [Object] Tokenizer map, used by parser to consume input.\n\n\n    return [invertedSymbolMap, invertedNuDigitsMap, {\n      infinity: new RegExp(\"^\" + regexpEscape(infinitySymbol)),\n      nan: new RegExp(\"^\" + regexpEscape(nanSymbol)),\n      negativePrefix: new RegExp(\"^\" + regexpEscape(negativePrefix)),\n      negativeSuffix: new RegExp(\"^\" + regexpEscape(negativeSuffix)),\n      number: new RegExp(\"^\" + numberTokenizer),\n      prefix: new RegExp(\"^\" + regexpEscape(prefix)),\n      suffix: new RegExp(\"^\" + regexpEscape(suffix))\n    }];\n  };\n  /**\n   * Pattern( style )\n   *\n   * @style [String] \"decimal\" (default) or \"percent\".\n   *\n   * @cldr [Cldr instance].\n   */\n\n\n  var numberPattern = function (style, cldr) {\n    if (style !== \"decimal\" && style !== \"percent\") {\n      throw new Error(\"Invalid style\");\n    }\n\n    return cldr.main([\"numbers\", style + \"Formats-numberSystem-\" + numberNumberingSystem(cldr), \"standard\"]);\n  };\n  /**\n   * EBNF representation:\n   *\n   * compact_pattern_re =       prefix?\n   *                            number_pattern_re\n   *                            suffix?\n   *\n   * number_pattern_re =        0+\n   *\n   * Regexp groups:\n   *\n   *  0: compact_pattern_re\n   *  1: prefix\n   *  2: number_pattern_re (the number pattern to use in compact mode)\n   *  3: suffix\n   */\n\n\n  var numberCompactPatternRe = /^([^0]*)(0+)([^0]*)$/;\n  /**\n   * goupingSeparator( number, primaryGroupingSize, secondaryGroupingSize )\n   *\n   * @number [Number].\n   *\n   * @primaryGroupingSize [Number]\n   *\n   * @secondaryGroupingSize [Number]\n   *\n   * Return the formatted number with group separator.\n   */\n\n  var numberFormatGroupingSeparator = function (number, primaryGroupingSize, secondaryGroupingSize) {\n    var index,\n        currentGroupingSize = primaryGroupingSize,\n        ret = \"\",\n        sep = \",\",\n        switchToSecondary = secondaryGroupingSize ? true : false;\n    number = String(number).split(\".\");\n    index = number[0].length;\n\n    while (index > currentGroupingSize) {\n      ret = number[0].slice(index - currentGroupingSize, index) + (ret.length ? sep : \"\") + ret;\n      index -= currentGroupingSize;\n\n      if (switchToSecondary) {\n        currentGroupingSize = secondaryGroupingSize;\n        switchToSecondary = false;\n      }\n    }\n\n    number[0] = number[0].slice(0, index) + (ret.length ? sep : \"\") + ret;\n    return number.join(\".\");\n  };\n  /**\n   * integerFractionDigits( number, minimumIntegerDigits, minimumFractionDigits,\n   * maximumFractionDigits, round, roundIncrement )\n   *\n   * @number [Number]\n   *\n   * @minimumIntegerDigits [Number]\n   *\n   * @minimumFractionDigits [Number]\n   *\n   * @maximumFractionDigits [Number]\n   *\n   * @round [Function]\n   *\n   * @roundIncrement [Function]\n   *\n   * Return the formatted integer and fraction digits.\n   */\n\n\n  var numberFormatIntegerFractionDigits = function (number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round, roundIncrement) {\n    // Fraction\n    if (maximumFractionDigits) {\n      // Rounding\n      if (roundIncrement) {\n        number = round(number, roundIncrement); // Maximum fraction digits\n      } else {\n        number = round(number, {\n          exponent: -maximumFractionDigits\n        });\n      }\n    } else {\n      number = round(number);\n    }\n\n    number = String(number); // Maximum integer digits (post string phase)\n\n    if (maximumFractionDigits && /e-/.test(number)) {\n      // Use toFixed( maximumFractionDigits ) to make sure small numbers like 1e-7 are\n      // displayed using plain digits instead of scientific notation.\n      // 1: Remove leading decimal zeros.\n      // 2: Remove leading decimal separator.\n      // Note: String() is still preferred so it doesn't mess up with a number precision\n      // unnecessarily, e.g., (123456789.123).toFixed(10) === \"123456789.1229999959\",\n      // String(123456789.123) === \"123456789.123\".\n      number = (+number).toFixed(maximumFractionDigits).replace(/0+$/, \"\")\n      /* 1 */\n      .replace(/\\.$/, \"\");\n      /* 2 */\n    } // Minimum fraction digits (post string phase)\n\n\n    if (minimumFractionDigits) {\n      number = number.split(\".\");\n      number[1] = stringPad(number[1] || \"\", minimumFractionDigits, true);\n      number = number.join(\".\");\n    } // Minimum integer digits\n\n\n    if (minimumIntegerDigits) {\n      number = number.split(\".\");\n      number[0] = stringPad(number[0], minimumIntegerDigits);\n      number = number.join(\".\");\n    }\n\n    return number;\n  };\n  /**\n   * toPrecision( number, precision, round )\n   *\n   * @number (Number)\n   *\n   * @precision (Number) significant figures precision (not decimal precision).\n   *\n   * @round (Function)\n   *\n   * Return number.toPrecision( precision ) using the given round function.\n   */\n\n\n  var numberToPrecision = function (number, precision, round) {\n    var roundOrder;\n\n    if (number === 0) {\n      // Fix #706\n      return number;\n    }\n\n    roundOrder = Math.ceil(Math.log(Math.abs(number)) / Math.log(10));\n    roundOrder -= precision;\n    return round(number, {\n      exponent: roundOrder\n    });\n  };\n  /**\n   * toPrecision( number, minimumSignificantDigits, maximumSignificantDigits, round )\n   *\n   * @number [Number]\n   *\n   * @minimumSignificantDigits [Number]\n   *\n   * @maximumSignificantDigits [Number]\n   *\n   * @round [Function]\n   *\n   * Return the formatted significant digits number.\n   */\n\n\n  var numberFormatSignificantDigits = function (number, minimumSignificantDigits, maximumSignificantDigits, round) {\n    var atMinimum, atMaximum; // Sanity check.\n\n    if (minimumSignificantDigits > maximumSignificantDigits) {\n      maximumSignificantDigits = minimumSignificantDigits;\n    }\n\n    atMinimum = numberToPrecision(number, minimumSignificantDigits, round);\n    atMaximum = numberToPrecision(number, maximumSignificantDigits, round); // Use atMaximum only if it has more significant digits than atMinimum.\n\n    number = +atMinimum === +atMaximum ? atMinimum : atMaximum; // Expand integer numbers, eg. 123e5 to 12300.\n\n    number = (+number).toString(10);\n\n    if (/e/.test(number)) {\n      throw createErrorUnsupportedFeature({\n        feature: \"integers out of (1e21, 1e-7)\"\n      });\n    } // Add trailing zeros if necessary.\n\n\n    if (minimumSignificantDigits - number.replace(/^0+|\\./g, \"\").length > 0) {\n      number = number.split(\".\");\n      number[1] = stringPad(number[1] || \"\", minimumSignificantDigits - number[0].replace(/^0+/, \"\").length, true);\n      number = number.join(\".\");\n    }\n\n    return number;\n  };\n  /**\n   * format( number, properties )\n   *\n   * @number [Number].\n   *\n   * @properties [Object] Output of number/format-properties.\n   *\n   * Return the formatted number.\n   * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n   */\n\n\n  var numberFormat = function (number, properties, pluralGenerator) {\n    var aux, compactMap, infinitySymbol, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits, minimumIntegerDigits, minimumSignificantDigits, nanSymbol, nuDigitsMap, prefix, primaryGroupingSize, pattern, round, roundIncrement, secondaryGroupingSize, stringToParts, suffix, symbolMap;\n    minimumIntegerDigits = properties[2];\n    minimumFractionDigits = properties[3];\n    maximumFractionDigits = properties[4];\n    minimumSignificantDigits = properties[5];\n    maximumSignificantDigits = properties[6];\n    roundIncrement = properties[7];\n    primaryGroupingSize = properties[8];\n    secondaryGroupingSize = properties[9];\n    round = properties[15];\n    infinitySymbol = properties[16];\n    nanSymbol = properties[17];\n    symbolMap = properties[18];\n    nuDigitsMap = properties[19];\n    compactMap = properties[20]; // NaN\n\n    if (isNaN(number)) {\n      return [{\n        type: \"nan\",\n        value: nanSymbol\n      }];\n    }\n\n    if (number < 0) {\n      pattern = properties[12];\n      prefix = properties[13];\n      suffix = properties[14];\n    } else {\n      pattern = properties[11];\n      prefix = properties[0];\n      suffix = properties[10];\n    } // For prefix, suffix, and number parts.\n\n\n    stringToParts = function (string) {\n      var numberType = \"integer\",\n          parts = []; // TODO Move the tokenization of all parts that don't depend on number into\n      // format-properties.\n\n      string.replace(/('([^']|'')+'|'')|./g, function (character, literal) {\n        // Literals\n        if (literal) {\n          partsPush(parts, \"literal\", removeLiteralQuotes(literal));\n          return;\n        } // Currency symbol\n\n\n        if (character === \"\\u00A4\") {\n          partsPush(parts, \"currency\", character);\n          return;\n        } // Symbols\n\n\n        character = character.replace(/[.,\\-+E%\\u2030]/, function (symbol) {\n          if (symbol === \".\") {\n            numberType = \"fraction\";\n          }\n\n          partsPush(parts, numberSymbolName[symbol], symbolMap[symbol]); // \"Erase\" handled character.\n\n          return \"\";\n        }); // Number\n\n        character = character.replace(/[0-9]/, function (digit) {\n          // Numbering system\n          if (nuDigitsMap) {\n            digit = nuDigitsMap[+digit];\n          }\n\n          partsPush(parts, numberType, digit); // \"Erase\" handled character.\n\n          return \"\";\n        }); // Etc\n\n        character.replace(/./, function (etc) {\n          partsPush(parts, \"literal\", etc);\n        });\n      });\n      return parts;\n    };\n\n    prefix = stringToParts(prefix);\n    suffix = stringToParts(suffix); // Infinity\n\n    if (!isFinite(number)) {\n      return prefix.concat({\n        type: \"infinity\",\n        value: infinitySymbol\n      }, suffix);\n    } // Percent\n\n\n    if (pattern.indexOf(\"%\") !== -1) {\n      number *= 100; // Per mille\n    } else if (pattern.indexOf(\"\\u2030\") !== -1) {\n      number *= 1000;\n    }\n\n    var compactPattern, compactDigits, compactProperties, divisor, numberExponent, pluralForm; // Compact mode: initial number digit processing\n\n    if (compactMap) {\n      numberExponent = Math.abs(Math.floor(number)).toString().length - 1;\n      numberExponent = Math.min(numberExponent, compactMap.maxExponent); // Use default plural form to perform initial decimal shift\n\n      if (numberExponent >= 3) {\n        compactPattern = compactMap[numberExponent] && compactMap[numberExponent].other;\n      }\n\n      if (compactPattern === \"0\") {\n        compactPattern = null;\n      } else if (compactPattern) {\n        compactDigits = compactPattern.split(\"0\").length - 1;\n        divisor = numberExponent - (compactDigits - 1);\n        number = number / Math.pow(10, divisor);\n      }\n    } // Significant digit format\n\n\n    if (!isNaN(minimumSignificantDigits * maximumSignificantDigits)) {\n      number = numberFormatSignificantDigits(number, minimumSignificantDigits, maximumSignificantDigits, round); // Integer and fractional format\n    } else {\n      number = numberFormatIntegerFractionDigits(number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round, roundIncrement);\n    } // Compact mode: apply formatting\n\n\n    if (compactMap && compactPattern) {\n      // Get plural form after possible roundings\n      pluralForm = pluralGenerator ? pluralGenerator(+number) : \"other\";\n      compactPattern = compactMap[numberExponent][pluralForm] || compactPattern;\n      compactProperties = compactPattern.match(numberCompactPatternRe); // TODO Move the tokenization of all parts that don't depend on number into\n      // format-properties.\n\n      aux = function (string) {\n        var parts = [];\n        string.replace(/(\\s+)|([^\\s0]+)/g, function (_garbage, space, compact) {\n          // Literals\n          if (space) {\n            partsPush(parts, \"literal\", space);\n            return;\n          } // Compact value\n\n\n          if (compact) {\n            partsPush(parts, \"compact\", compact);\n            return;\n          }\n        });\n        return parts;\n      }; // update prefix/suffix with compact prefix/suffix\n\n\n      prefix = prefix.concat(aux(compactProperties[1]));\n      suffix = aux(compactProperties[3]).concat(suffix);\n    } // Remove the possible number minus sign\n\n\n    number = number.replace(/^-/, \"\"); // Grouping separators\n\n    if (primaryGroupingSize) {\n      number = numberFormatGroupingSeparator(number, primaryGroupingSize, secondaryGroupingSize);\n    } // Scientific notation\n    // TODO implement here\n    // Padding/'([^']|'')+'|''|[.,\\-+E%\\u2030]/g\n    // TODO implement here\n\n\n    return prefix.concat(stringToParts(number), suffix);\n  };\n\n  var numberToPartsFormatterFn = function (properties, pluralGenerator) {\n    return function numberToPartsFormatter(value) {\n      validateParameterPresence(value, \"value\");\n      validateParameterTypeNumber(value, \"value\");\n      return numberFormat(value, properties, pluralGenerator);\n    };\n  };\n\n  function validateDigits(properties) {\n    var minimumIntegerDigits = properties[2],\n        minimumFractionDigits = properties[3],\n        maximumFractionDigits = properties[4],\n        minimumSignificantDigits = properties[5],\n        maximumSignificantDigits = properties[6]; // Validate significant digit format properties\n\n    if (!isNaN(minimumSignificantDigits * maximumSignificantDigits)) {\n      validateParameterRange(minimumSignificantDigits, \"minimumSignificantDigits\", 1, 21);\n      validateParameterRange(maximumSignificantDigits, \"maximumSignificantDigits\", minimumSignificantDigits, 21);\n    } else if (!isNaN(minimumSignificantDigits) || !isNaN(maximumSignificantDigits)) {\n      throw new Error(\"Neither or both the minimum and maximum significant digits must be \" + \"present\"); // Validate integer and fractional format\n    } else {\n      validateParameterRange(minimumIntegerDigits, \"minimumIntegerDigits\", 1, 21);\n      validateParameterRange(minimumFractionDigits, \"minimumFractionDigits\", 0, 20);\n      validateParameterRange(maximumFractionDigits, \"maximumFractionDigits\", minimumFractionDigits, 20);\n    }\n  }\n  /**\n   * .numberFormatter( [options] )\n   *\n   * @options [Object]:\n   * - style: [String] \"decimal\" (default) or \"percent\".\n   * - see also number/format options.\n   *\n   * Return a function that formats a number according to the given options and default/instance\n   * locale.\n   */\n\n\n  Globalize.numberFormatter = Globalize.prototype.numberFormatter = function (options) {\n    var args, numberToPartsFormatter, returnFn;\n    validateParameterTypePlainObject(options, \"options\");\n    options = options || {};\n    args = [options];\n    numberToPartsFormatter = this.numberToPartsFormatter(options);\n    returnFn = numberFormatterFn(numberToPartsFormatter);\n    runtimeBind(args, this.cldr, returnFn, [numberToPartsFormatter]);\n    return returnFn;\n  };\n  /**\n   * .numberToPartsFormatter( [options] )\n   *\n   * @options [Object]:\n   * - style: [String] \"symbol\" (default), \"accounting\", \"code\" or \"name\".\n   * - see also number/format options.\n   *\n   * Return a function that formats a number to parts according to the given options and\n   * default/instance locale.\n   */\n\n\n  Globalize.numberToPartsFormatter = Globalize.prototype.numberToPartsFormatter = function (options) {\n    var args, cldr, fnArgs, pattern, properties, returnFn;\n    validateParameterTypePlainObject(options, \"options\");\n    options = options || {};\n    cldr = this.cldr;\n    args = [options];\n    validateDefaultLocale(cldr);\n    cldr.on(\"get\", validateCldr);\n\n    try {\n      if (options.raw) {\n        pattern = options.raw;\n      } else {\n        pattern = numberPattern(options.style || \"decimal\", cldr);\n      }\n\n      properties = numberFormatProperties(pattern, cldr, options);\n      fnArgs = [properties];\n    } finally {\n      cldr.off(\"get\", validateCldr);\n    }\n\n    validateDigits(properties);\n\n    if (options.compact) {\n      fnArgs.push(this.pluralGenerator());\n    }\n\n    returnFn = numberToPartsFormatterFn.apply(null, fnArgs);\n    runtimeBind(args, cldr, returnFn, fnArgs);\n    return returnFn;\n  };\n  /**\n   * .numberParser( [options] )\n   *\n   * @options [Object]:\n   * - style: [String] \"decimal\" (default) or \"percent\".\n   *\n   * Return the number parser according to the default/instance locale.\n   */\n\n\n  Globalize.numberParser = Globalize.prototype.numberParser = function (options) {\n    var args, cldr, pattern, properties, returnFn;\n    validateParameterTypePlainObject(options, \"options\");\n    options = options || {};\n    cldr = this.cldr;\n    args = [options];\n    validateDefaultLocale(cldr);\n\n    if (options.compact) {\n      throw createErrorUnsupportedFeature({\n        feature: \"compact number parsing (not implemented)\"\n      });\n    }\n\n    cldr.on(\"get\", validateCldr);\n\n    if (options.raw) {\n      pattern = options.raw;\n    } else {\n      pattern = numberPattern(options.style || \"decimal\", cldr);\n    }\n\n    properties = numberParseProperties(pattern, cldr, options);\n    cldr.off(\"get\", validateCldr);\n    returnFn = numberParserFn(properties);\n    runtimeBind(args, cldr, returnFn, [properties]);\n    return returnFn;\n  };\n  /**\n   * .formatNumber( value [, options] )\n   *\n   * @value [Number] number to be formatted.\n   *\n   * @options [Object]: see number/format-properties.\n   *\n   * Format a number according to the given options and default/instance locale.\n   */\n\n\n  Globalize.formatNumber = Globalize.prototype.formatNumber = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeNumber(value, \"value\");\n    return this.numberFormatter(options)(value);\n  };\n  /**\n   * .formatNumberToParts( value [, options] )\n   *\n   * @value [Number] number to be formatted.\n   *\n   * @options [Object]: see number/format-properties.\n   *\n   * Format a number to pars according to the given options and default/instance locale.\n   */\n\n\n  Globalize.formatNumberToParts = Globalize.prototype.formatNumberToParts = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeNumber(value, \"value\");\n    return this.numberToPartsFormatter(options)(value);\n  };\n  /**\n   * .parseNumber( value [, options] )\n   *\n   * @value [String]\n   *\n   * @options [Object]: See numberParser().\n   *\n   * Return the parsed Number (including Infinity) or NaN when value is invalid.\n   */\n\n\n  Globalize.parseNumber = Globalize.prototype.parseNumber = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeString(value, \"value\");\n    return this.numberParser(options)(value);\n  };\n  /**\n   * Optimization to avoid duplicating some internal functions across modules.\n   */\n\n\n  Globalize._createErrorUnsupportedFeature = createErrorUnsupportedFeature;\n  Globalize._numberNumberingSystem = numberNumberingSystem;\n  Globalize._numberNumberingSystemDigitsMap = numberNumberingSystemDigitsMap;\n  Globalize._numberPattern = numberPattern;\n  Globalize._numberSymbol = numberSymbol;\n  Globalize._looseMatching = looseMatching;\n  Globalize._removeLiteralQuotes = removeLiteralQuotes;\n  Globalize._stringPad = stringPad;\n  Globalize._validateParameterTypeNumber = validateParameterTypeNumber;\n  Globalize._validateParameterTypeString = validateParameterTypeString;\n  return Globalize;\n});","map":{"version":3,"sources":["D:/react-myprojects/hrms-airtable/node_modules/globalize/dist/globalize/number.js"],"names":["root","factory","define","amd","exports","module","require","Cldr","Globalize","createError","_createError","partsJoin","_partsJoin","partsPush","_partsPush","regexpEscape","_regexpEscape","runtimeBind","_runtimeBind","stringPad","_stringPad","validateCldr","_validateCldr","validateDefaultLocale","_validateDefaultLocale","validateParameterPresence","_validateParameterPresence","validateParameterRange","_validateParameterRange","validateParameterType","_validateParameterType","validateParameterTypePlainObject","_validateParameterTypePlainObject","createErrorUnsupportedFeature","feature","validateParameterTypeNumber","value","name","undefined","validateParameterTypeString","numberFormatterFn","numberToPartsFormatter","numberFormatter","numberNumberingSystem","cldr","nu","attributes","indexOf","main","numberCompact","compactType","maxExponent","object","Object","keys","reduce","newObject","compactKey","numberExponent","split","length","pluralForm","Math","max","numberNumberingSystemDigitsMap","aux","supplemental","_type","_digits","numberPatternRe","numberPatternProperties","pattern","aux1","aux2","fractionPattern","integerFractionOrSignificantPattern","integerPattern","maximumFractionDigits","maximumSignificantDigits","minimumFractionDigits","minimumIntegerDigits","minimumSignificantDigits","padding","prefix","primaryGroupingSize","roundIncrement","scientificNotation","secondaryGroupingSize","significantPattern","suffix","match","Error","replace","_match","minimumSignificantDigitsMatch","maximumSignificantDigitsMatch","lastIndexOf","numberSymbol","numberSymbolName","numberSymbolMap","symbol","symbolMap","numberTruncate","isNaN","NaN","numberRound","method","incrementOrExp","exp","increment","exponent","toExponential","toString","numberFormatProperties","options","negativePattern","negativePrefix","negativeProperties","negativeSuffix","positivePattern","roundFn","properties","getOptions","attribute","propertyIndex","round","generatorString","concat","compact","useGrouping","min","regexpCfG","regexpDashG","regexpZsG","looseMatching","numberParse","grammar","invertedNuDigitsMap","invertedSymbolMap","negative","number","prefixNSuffix","tokenizer","valid","parse","type","lexeme","map","character","join","Infinity","tokenizeNParse","_value","some","statement","every","numberParserFn","numberParser","numberSymbolInvertedMap","objectMap","fn","key","pair","removeLiteralQuotes","string","slice","numberParseProperties","decimalSymbolRe","digitsRe","groupingSeparatorRe","infinitySymbol","nanSymbol","nuDigitsMap","numberTokenizer","formatProperties","localizedDigit","i","String","literal","infinity","RegExp","nan","numberPattern","style","numberCompactPatternRe","numberFormatGroupingSeparator","index","currentGroupingSize","ret","sep","switchToSecondary","numberFormatIntegerFractionDigits","test","toFixed","numberToPrecision","precision","roundOrder","ceil","log","abs","numberFormatSignificantDigits","atMinimum","atMaximum","numberFormat","pluralGenerator","compactMap","stringToParts","numberType","parts","digit","etc","isFinite","compactPattern","compactDigits","compactProperties","divisor","floor","other","pow","_garbage","space","numberToPartsFormatterFn","validateDigits","prototype","args","returnFn","fnArgs","on","raw","off","push","apply","formatNumber","formatNumberToParts","parseNumber","_createErrorUnsupportedFeature","_numberNumberingSystem","_numberNumberingSystemDigitsMap","_numberPattern","_numberSymbol","_looseMatching","_removeLiteralQuotes","_validateParameterTypeNumber","_validateParameterTypeString"],"mappings":"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","sourcesContent":["/**\n * Globalize v1.7.0\n *\n * https://github.com/globalizejs/globalize\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2021-08-02T11:53Z\n */\n/*!\n * Globalize v1.7.0 2021-08-02T11:53Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function( root, factory ) {\n\n\t// UMD returnExports\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD\n\t\tdefine([\n\t\t\t\"cldr\",\n\t\t\t\"../globalize\",\n\t\t\t\"cldr/event\",\n\t\t\t\"cldr/supplemental\"\n\t\t], factory );\n\t} else if ( typeof exports === \"object\" ) {\n\n\t\t// Node, CommonJS\n\t\tmodule.exports = factory( require( \"cldrjs\" ), require( \"../globalize\" ) );\n\t} else {\n\n\t\t// Global\n\t\tfactory( root.Cldr, root.Globalize );\n\t}\n}(this, function( Cldr, Globalize ) {\n\nvar createError = Globalize._createError,\n\tpartsJoin = Globalize._partsJoin,\n\tpartsPush = Globalize._partsPush,\n\tregexpEscape = Globalize._regexpEscape,\n\truntimeBind = Globalize._runtimeBind,\n\tstringPad = Globalize._stringPad,\n\tvalidateCldr = Globalize._validateCldr,\n\tvalidateDefaultLocale = Globalize._validateDefaultLocale,\n\tvalidateParameterPresence = Globalize._validateParameterPresence,\n\tvalidateParameterRange = Globalize._validateParameterRange,\n\tvalidateParameterType = Globalize._validateParameterType,\n\tvalidateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;\n\n\nvar createErrorUnsupportedFeature = function( feature ) {\n\treturn createError( \"E_UNSUPPORTED\", \"Unsupported {feature}.\", {\n\t\tfeature: feature\n\t});\n};\n\n\n\n\nvar validateParameterTypeNumber = function( value, name ) {\n\tvalidateParameterType(\n\t\tvalue,\n\t\tname,\n\t\tvalue === undefined || typeof value === \"number\",\n\t\t\"Number\"\n\t);\n};\n\n\n\n\nvar validateParameterTypeString = function( value, name ) {\n\tvalidateParameterType(\n\t\tvalue,\n\t\tname,\n\t\tvalue === undefined || typeof value === \"string\",\n\t\t\"a string\"\n\t);\n};\n\n\n\n\nvar numberFormatterFn = function( numberToPartsFormatter ) {\n\treturn function numberFormatter( value ) {\n\t\treturn partsJoin( numberToPartsFormatter( value ));\n\t};\n};\n\n\n\n\n/**\n * NumberingSystem( cldr )\n *\n * - http://www.unicode.org/reports/tr35/tr35-numbers.html#otherNumberingSystems\n * - http://cldr.unicode.org/index/bcp47-extension\n * - http://www.unicode.org/reports/tr35/#u_Extension\n */\nvar numberNumberingSystem = function( cldr ) {\n\tvar nu = cldr.attributes[ \"u-nu\" ];\n\n\tif ( nu ) {\n\t\tif ( nu === \"traditio\" ) {\n\t\t\tnu = \"traditional\";\n\t\t}\n\t\tif ( [ \"native\", \"traditional\", \"finance\" ].indexOf( nu ) !== -1 ) {\n\n\t\t\t// Unicode locale extension `u-nu` is set using either (native, traditional or\n\t\t\t// finance). So, lookup the respective locale's numberingSystem and return it.\n\t\t\treturn cldr.main([ \"numbers/otherNumberingSystems\", nu ]);\n\t\t}\n\n\t\t// Unicode locale extension `u-nu` is set with an explicit numberingSystem. Return it.\n\t\treturn nu;\n\t}\n\n\t// Return the default numberingSystem.\n\treturn cldr.main( \"numbers/defaultNumberingSystem\" );\n};\n\n\n\n\n/**\n * Compact( name, cldr )\n *\n * @compactType [String] Compact mode, `short` or `long`.\n *\n * @cldr [Cldr instance].\n *\n * Return the localized compact map for the given compact mode.\n */\nvar numberCompact = function( compactType, cldr ) {\n\tvar maxExponent = 0;\n\n\tvar object = cldr.main([\n\t\t\"numbers/decimalFormats-numberSystem-\" + numberNumberingSystem( cldr ),\n\t\tcompactType,\n\t\t\"decimalFormat\"\n\t]);\n\n\tobject = Object.keys( object ).reduce(function( newObject, compactKey ) {\n\t\tvar numberExponent = compactKey.split( \"0\" ).length - 1;\n\t\tvar pluralForm = compactKey.split( \"-\" )[ 2 ];\n\t\tnewObject[ numberExponent ] = newObject[ numberExponent ] || {};\n\t\tnewObject[ numberExponent ][ pluralForm ] = object[ compactKey ];\n\t\tmaxExponent = Math.max( numberExponent, maxExponent );\n\t\treturn newObject;\n\t}, {});\n\n\tobject.maxExponent = maxExponent;\n\n\treturn object;\n};\n\n\n\n\n/**\n * nuMap( cldr )\n *\n * @cldr [Cldr instance].\n *\n * Return digits map if numbering system is different than `latn`.\n */\nvar numberNumberingSystemDigitsMap = function( cldr ) {\n\tvar aux,\n\t\tnu = numberNumberingSystem( cldr );\n\n\tif ( nu === \"latn\" ) {\n\t\treturn;\n\t}\n\n\taux = cldr.supplemental([ \"numberingSystems\", nu ]);\n\n\tif ( aux._type !== \"numeric\" ) {\n\t\tthrow createErrorUnsupportedFeature( \"`\" + aux._type + \"` numbering system\" );\n\t}\n\n\treturn aux._digits;\n};\n\n\n\n\n/**\n * EBNF representation:\n *\n * number_pattern_re =        prefix?\n *                            padding?\n *                            (integer_fraction_pattern | significant_pattern)\n *                            scientific_notation?\n *                            suffix?\n *\n * prefix =                   non_number_stuff\n *\n * padding =                  \"*\" regexp(.)\n *\n * integer_fraction_pattern = integer_pattern\n *                            fraction_pattern?\n *\n * integer_pattern =          regexp([#,]*[0,]*0+)\n *\n * fraction_pattern =         \".\" regexp(0*[0-9]*#*)\n *\n * significant_pattern =      regexp([#,]*@+#*)\n *\n * scientific_notation =      regexp(E\\+?0+)\n *\n * suffix =                   non_number_stuff\n *\n * non_number_stuff =         regexp(('[^']+'|''|[^*#@0,.E])*)\n *\n *\n * Regexp groups:\n *\n *  0: number_pattern_re\n *  1: prefix\n *  2: -\n *  3: -\n *  4: padding\n *  5: (integer_fraction_pattern | significant_pattern)\n *  6: integer_fraction_pattern\n *  7: integer_pattern\n *  8: fraction_pattern\n *  9: significant_pattern\n * 10: scientific_notation\n * 11: suffix\n * 12: -\n */\nvar numberPatternRe = ( /^(('([^']|'')*'|[^*#@0,.E])*)(\\*.)?((([#,]*[0,]*0+)(\\.0*[0-9]*#*)?)|([#,]*@+#*))(E\\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/ );\n\n\n\n\n/**\n * format( number, pattern )\n *\n * @number [Number].\n *\n * @pattern [String] raw pattern for numbers.\n *\n * Return the formatted number.\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n */\nvar numberPatternProperties = function( pattern ) {\n\tvar aux1, aux2, fractionPattern, integerFractionOrSignificantPattern, integerPattern,\n\t\tmaximumFractionDigits, maximumSignificantDigits, minimumFractionDigits,\n\t\tminimumIntegerDigits, minimumSignificantDigits, padding, prefix, primaryGroupingSize,\n\t\troundIncrement, scientificNotation, secondaryGroupingSize, significantPattern, suffix;\n\n\tpattern = pattern.match( numberPatternRe );\n\tif ( !pattern ) {\n\t\tthrow new Error( \"Invalid pattern: \" + pattern );\n\t}\n\n\tprefix = pattern[ 1 ];\n\tpadding = pattern[ 4 ];\n\tintegerFractionOrSignificantPattern = pattern[ 5 ];\n\tsignificantPattern = pattern[ 9 ];\n\tscientificNotation = pattern[ 10 ];\n\tsuffix = pattern[ 11 ];\n\n\t// Significant digit format\n\tif ( significantPattern ) {\n\t\tsignificantPattern.replace( /(@+)(#*)/, function( _match, minimumSignificantDigitsMatch, maximumSignificantDigitsMatch ) {\n\t\t\tminimumSignificantDigits = minimumSignificantDigitsMatch.length;\n\t\t\tmaximumSignificantDigits = minimumSignificantDigits +\n\t\t\t\tmaximumSignificantDigitsMatch.length;\n\t\t});\n\n\t// Integer and fractional format\n\t} else {\n\t\tfractionPattern = pattern[ 8 ];\n\t\tintegerPattern = pattern[ 7 ];\n\n\t\tif ( fractionPattern ) {\n\n\t\t\t// Minimum fraction digits, and rounding.\n\t\t\tfractionPattern.replace( /[0-9]+/, function( match ) {\n\t\t\t\tminimumFractionDigits = match;\n\t\t\t});\n\t\t\tif ( minimumFractionDigits ) {\n\t\t\t\troundIncrement = +( \"0.\" + minimumFractionDigits );\n\t\t\t\tminimumFractionDigits = minimumFractionDigits.length;\n\t\t\t} else {\n\t\t\t\tminimumFractionDigits = 0;\n\t\t\t}\n\n\t\t\t// Maximum fraction digits\n\t\t\t// 1: ignore decimal character\n\t\t\tmaximumFractionDigits = fractionPattern.length - 1; /* 1 */\n\t\t} else {\n\t\t\tminimumFractionDigits = 0;\n\t\t\tmaximumFractionDigits = 0;\n\t\t}\n\n\t\t// Minimum integer digits\n\t\tintegerPattern.replace( /0+$/, function( match ) {\n\t\t\tminimumIntegerDigits = match.length;\n\t\t});\n\t}\n\n\t// Scientific notation\n\tif ( scientificNotation ) {\n\t\tthrow createErrorUnsupportedFeature({\n\t\t\tfeature: \"scientific notation (not implemented)\"\n\t\t});\n\t}\n\n\t// Padding\n\tif ( padding ) {\n\t\tthrow createErrorUnsupportedFeature({\n\t\t\tfeature: \"padding (not implemented)\"\n\t\t});\n\t}\n\n\t// Grouping\n\tif ( ( aux1 = integerFractionOrSignificantPattern.lastIndexOf( \",\" ) ) !== -1 ) {\n\n\t\t// Primary grouping size is the interval between the last group separator and the end of\n\t\t// the integer (or the end of the significant pattern).\n\t\taux2 = integerFractionOrSignificantPattern.split( \".\" )[ 0 ];\n\t\tprimaryGroupingSize = aux2.length - aux1 - 1;\n\n\t\t// Secondary grouping size is the interval between the last two group separators.\n\t\tif ( ( aux2 = integerFractionOrSignificantPattern.lastIndexOf( \",\", aux1 - 1 ) ) !== -1 ) {\n\t\t\tsecondaryGroupingSize = aux1 - 1 - aux2;\n\t\t}\n\t}\n\n\t// Return:\n\t//  0: @prefix String\n\t//  1: @padding Array [ <character>, <count> ] TODO\n\t//  2: @minimumIntegerDigits non-negative integer Number value indicating the minimum integer\n\t//        digits to be used. Numbers will be padded with leading zeroes if necessary.\n\t//  3: @minimumFractionDigits and\n\t//  4: @maximumFractionDigits are non-negative integer Number values indicating the minimum and\n\t//        maximum fraction digits to be used. Numbers will be rounded or padded with trailing\n\t//        zeroes if necessary.\n\t//  5: @minimumSignificantDigits and\n\t//  6: @maximumSignificantDigits are positive integer Number values indicating the minimum and\n\t//        maximum fraction digits to be shown. Either none or both of these properties are\n\t//        present; if they are, they override minimum and maximum integer and fraction digits\n\t//        – the formatter uses however many integer and fraction digits are required to display\n\t//        the specified number of significant digits.\n\t//  7: @roundIncrement Decimal round increment or null\n\t//  8: @primaryGroupingSize\n\t//  9: @secondaryGroupingSize\n\t// 10: @suffix String\n\treturn [\n\t\tprefix,\n\t\tpadding,\n\t\tminimumIntegerDigits,\n\t\tminimumFractionDigits,\n\t\tmaximumFractionDigits,\n\t\tminimumSignificantDigits,\n\t\tmaximumSignificantDigits,\n\t\troundIncrement,\n\t\tprimaryGroupingSize,\n\t\tsecondaryGroupingSize,\n\t\tsuffix\n\t];\n};\n\n\n\n\n/**\n * Symbol( name, cldr )\n *\n * @name [String] Symbol name.\n *\n * @cldr [Cldr instance].\n *\n * Return the localized symbol given its name.\n */\nvar numberSymbol = function( name, cldr ) {\n\treturn cldr.main([\n\t\t\"numbers/symbols-numberSystem-\" + numberNumberingSystem( cldr ),\n\t\tname\n\t]);\n};\n\n\n\n\nvar numberSymbolName = {\n\t\".\": \"decimal\",\n\t\",\": \"group\",\n\t\"%\": \"percentSign\",\n\t\"+\": \"plusSign\",\n\t\"-\": \"minusSign\",\n\t\"E\": \"exponential\",\n\t\"\\u2030\": \"perMille\"\n};\n\n\n\n\n/**\n * symbolMap( cldr )\n *\n * @cldr [Cldr instance].\n *\n * Return the (localized symbol, pattern symbol) key value pair, eg. {\n *   \".\": \"٫\",\n *   \",\": \"٬\",\n *   \"%\": \"٪\",\n *   ...\n * };\n */\nvar numberSymbolMap = function( cldr ) {\n\tvar symbol,\n\t\tsymbolMap = {};\n\n\tfor ( symbol in numberSymbolName ) {\n\t\tsymbolMap[ symbol ] = numberSymbol( numberSymbolName[ symbol ], cldr );\n\t}\n\n\treturn symbolMap;\n};\n\n\n\n\nvar numberTruncate = function( value ) {\n\tif ( isNaN( value ) ) {\n\t\treturn NaN;\n\t}\n\treturn Math[ value < 0 ? \"ceil\" : \"floor\" ]( value );\n};\n\n\n\n\n/**\n * round( method )\n *\n * @method [String] with either \"round\", \"ceil\", \"floor\", or \"truncate\".\n *\n * Return function( value, incrementOrExp ):\n *\n *   @value [Number] eg. 123.45.\n *\n *   @incrementOrExp [Number] optional, eg. 0.1; or\n *     [Object] Either { increment: <value> } or { exponent: <value> }\n *\n *   Return the rounded number, eg:\n *   - round( \"round\" )( 123.45 ): 123;\n *   - round( \"ceil\" )( 123.45 ): 124;\n *   - round( \"floor\" )( 123.45 ): 123;\n *   - round( \"truncate\" )( 123.45 ): 123;\n *   - round( \"round\" )( 123.45, 0.1 ): 123.5;\n *   - round( \"round\" )( 123.45, 10 ): 120;\n *\n *   Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\n *   Ref: #376\n */\nvar numberRound = function( method ) {\n\tmethod = method || \"round\";\n\tmethod = method === \"truncate\" ? numberTruncate : Math[ method ];\n\n\treturn function( value, incrementOrExp ) {\n\t\tvar exp, increment;\n\n\t\tvalue = +value;\n\n\t\t// If the value is not a number, return NaN.\n\t\tif ( isNaN( value ) ) {\n\t\t\treturn NaN;\n\t\t}\n\n\t\t// Exponent given.\n\t\tif ( typeof incrementOrExp === \"object\" && incrementOrExp.exponent ) {\n\t\t\texp = +incrementOrExp.exponent;\n\t\t\tincrement = 1;\n\n\t\t\tif ( exp === 0 ) {\n\t\t\t\treturn method( value );\n\t\t\t}\n\n\t\t\t// If the exp is not an integer, return NaN.\n\t\t\tif ( !( typeof exp === \"number\" && exp % 1 === 0 ) ) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\n\t\t// Increment given.\n\t\t} else {\n\t\t\tincrement = +incrementOrExp || 1;\n\n\t\t\tif ( increment === 1 ) {\n\t\t\t\treturn method( value );\n\t\t\t}\n\n\t\t\t// If the increment is not a number, return NaN.\n\t\t\tif ( isNaN( increment ) ) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\n\t\t\tincrement = increment.toExponential().split( \"e\" );\n\t\t\texp = +increment[ 1 ];\n\t\t\tincrement = +increment[ 0 ];\n\t\t}\n\n\t\t// Shift & Round\n\t\tvalue = value.toString().split( \"e\" );\n\t\tvalue[ 0 ] = +value[ 0 ] / increment;\n\t\tvalue[ 1 ] = value[ 1 ] ? ( +value[ 1 ] - exp ) : -exp;\n\t\tvalue = method( +( value[ 0 ] + \"e\" + value[ 1 ] ) );\n\n\t\t// Shift back\n\t\tvalue = value.toString().split( \"e\" );\n\t\tvalue[ 0 ] = +value[ 0 ] * increment;\n\t\tvalue[ 1 ] = value[ 1 ] ? ( +value[ 1 ] + exp ) : exp;\n\t\treturn +( value[ 0 ] + \"e\" + value[ 1 ] );\n\t};\n};\n\n\n\n\n/**\n * formatProperties( pattern, cldr [, options] )\n *\n * @pattern [String] raw pattern for numbers.\n *\n * @cldr [Cldr instance].\n *\n * @options [Object]:\n * - minimumIntegerDigits [Number]\n * - minimumFractionDigits, maximumFractionDigits [Number]\n * - minimumSignificantDigits, maximumSignificantDigits [Number]\n * - round [String] \"ceil\", \"floor\", \"round\" (default), or \"truncate\".\n * - useGrouping [Boolean] default true.\n *\n * Return the processed properties that will be used in number/format.\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n */\nvar numberFormatProperties = function( pattern, cldr, options ) {\n\tvar negativePattern, negativePrefix, negativeProperties, negativeSuffix, positivePattern,\n\t\troundFn, properties;\n\n\tfunction getOptions( attribute, propertyIndex ) {\n\t\tif ( attribute in options ) {\n\t\t\tproperties[ propertyIndex ] = options[ attribute ];\n\t\t}\n\t}\n\n\toptions = options || {};\n\tpattern = pattern.split( \";\" );\n\n\tpositivePattern = pattern[ 0 ];\n\n\tnegativePattern = pattern[ 1 ] || \"-\" + positivePattern;\n\tnegativeProperties = numberPatternProperties( negativePattern );\n\tnegativePrefix = negativeProperties[ 0 ];\n\tnegativeSuffix = negativeProperties[ 10 ];\n\n\t// Have runtime code to refer to numberRound() instead of including it explicitly.\n\troundFn = numberRound( options.round );\n\troundFn.generatorString = function() {\n\t\treturn \"numberRound(\" + ( options.round ? \"\\\"\" + options.round + \"\\\"\" : \"\" ) + \")\";\n\t};\n\n\tproperties = numberPatternProperties( positivePattern ).concat([\n\t\tpositivePattern,\n\t\tnegativePrefix + positivePattern + negativeSuffix,\n\t\tnegativePrefix,\n\t\tnegativeSuffix,\n\t\troundFn,\n\t\tnumberSymbol( \"infinity\", cldr ),\n\t\tnumberSymbol( \"nan\", cldr ),\n\t\tnumberSymbolMap( cldr ),\n\t\tnumberNumberingSystemDigitsMap( cldr )\n\t]);\n\n\tif ( options.compact ) {\n\n\t\t// The compact digits number pattern is always `0+`, so override the following properties.\n\t\t// Note: minimumIntegerDigits would actually range from `0` to `000` based on the scale of\n\t\t// the value to be formatted, though we're always using 1 as a simplification, because the\n\t\t// number won't be zero-padded since we chose the right format based on the scale, i.e.,\n\t\t// we'd never see something like `003M` anyway.\n\t\tproperties[ 2 ] = 1; // minimumIntegerDigits\n\t\tproperties[ 3 ] = 0; // minimumFractionDigits\n\t\tproperties[ 4 ] = 0; // maximumFractionDigits\n\t\tproperties[ 5 ] = // minimumSignificantDigits &\n\t\t\tproperties[ 6 ] = undefined; // maximumSignificantDigits\n\n\t\tproperties[ 20 ] = numberCompact( options.compact, cldr );\n\t}\n\n\tgetOptions( \"minimumIntegerDigits\", 2 );\n\tgetOptions( \"minimumFractionDigits\", 3 );\n\tgetOptions( \"maximumFractionDigits\", 4 );\n\tgetOptions( \"minimumSignificantDigits\", 5 );\n\tgetOptions( \"maximumSignificantDigits\", 6 );\n\n\t// Grouping separators\n\tif ( options.useGrouping === false ) {\n\t\tproperties[ 8 ] = null;\n\t}\n\n\t// Normalize number of digits if only one of either minimumFractionDigits or\n\t// maximumFractionDigits is passed in as an option\n\tif ( \"minimumFractionDigits\" in options && !( \"maximumFractionDigits\" in options ) ) {\n\n\t\t// maximumFractionDigits = Math.max( minimumFractionDigits, maximumFractionDigits );\n\t\tproperties[ 4 ] = Math.max( properties[ 3 ], properties[ 4 ] );\n\t} else if ( !( \"minimumFractionDigits\" in options ) &&\n\t\t\t\"maximumFractionDigits\" in options ) {\n\n\t\t// minimumFractionDigits = Math.min( minimumFractionDigits, maximumFractionDigits );\n\t\tproperties[ 3 ] = Math.min( properties[ 3 ], properties[ 4 ] );\n\t}\n\n\t// Return:\n\t// 0-10: see number/pattern-properties.\n\t// 11: @positivePattern [String] Positive pattern.\n\t// 12: @negativePattern [String] Negative pattern.\n\t// 13: @negativePrefix [String] Negative prefix.\n\t// 14: @negativeSuffix [String] Negative suffix.\n\t// 15: @round [Function] Round function.\n\t// 16: @infinitySymbol [String] Infinity symbol.\n\t// 17: @nanSymbol [String] NaN symbol.\n\t// 18: @symbolMap [Object] A bunch of other symbols.\n\t// 19: @nuDigitsMap [Array] Digits map if numbering system is different than `latn`.\n\t// 20: @compactMap [Object] Map of per-digit-count format patterns for specified compact mode.\n\treturn properties;\n};\n\n\n\n\n/**\n * Generated by:\n *\n * var regenerate = require( \"regenerate\" );\n * var formatSymbols = require( \"@unicode/unicode-13.0.0/General_Category/Format/symbols\" );\n * regenerate().add( formatSymbols ).toString();\n *\n * https://github.com/mathiasbynens/regenerate\n * https://github.com/node-unicode/unicode-13.0.0\n */\nvar regexpCfG = /[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u08E2\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804[\\uDCBD\\uDCCD]|\\uD80D[\\uDC30-\\uDC38]|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/g;\n\n\n\n\n/**\n * Generated by:\n *\n * var regenerate = require( \"regenerate\" );\n * var dashSymbols = require( \"https://github.com/node-unicode/unicode-13.0.0/General_Category/Dash_Punctuation/symbols\" );\n * regenerate().add( dashSymbols ).toString();\n *\n * https://github.com/mathiasbynens/regenerate\n * https://github.com/node-unicode/unicode-13.0.0\n *\n * NOTE: In addition to [:dash:],  the below includes MINUS SIGN U+2212.\n */\nvar regexpDashG = /[\\x2D\\u058A\\u05BE\\u1400\\u1806\\u2010-\\u2015\\u2E17\\u2E1A\\u2E3A\\u2E3B\\u2E40\\u301C\\u3030\\u30A0\\uFE31\\uFE32\\uFE58\\uFE63\\uFF0D\\u2212]|\\uD803\\uDEAD/g;\n\n\n\n\n/**\n * Generated by:\n *\n * var regenerate = require( \"regenerate\" );\n * var spaceSeparatorSymbols = require( \"@unicode/unicode-13.0.0/General_Category/Space_Separator/symbols\" );\n * regenerate().add( spaceSeparatorSymbols ).toString();\n *\n * https://github.com/mathiasbynens/regenerate\n * https://github.com/node-unicode/unicode-13.0.0\n */\nvar regexpZsG = /[ \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/g;\n\n\n\n\n/**\n * Loose Matching:\n * - Ignore all format characters, which includes RLM, LRM or ALM used to control BIDI\n *   formatting.\n * - Map all characters in [:Zs:] to U+0020 SPACE;\n * - Map all characters in [:Dash:] to U+002D HYPHEN-MINUS;\n */\nvar looseMatching = function( value ) {\n\treturn value\n\t\t.replace( regexpCfG, \"\" )\n\t\t.replace( regexpDashG, \"-\" )\n\t\t.replace( regexpZsG, \" \" );\n};\n\n\n\n\n/**\n * parse( value, properties )\n *\n * @value [String].\n *\n * @properties [Object] Parser properties is a reduced pre-processed cldr\n * data set returned by numberParserProperties().\n *\n * Return the parsed Number (including Infinity) or NaN when value is invalid.\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n */\nvar numberParse = function( value, properties ) {\n\tvar grammar, invertedNuDigitsMap, invertedSymbolMap, negative, number, prefix, prefixNSuffix,\n\t\tsuffix, tokenizer, valid;\n\n\t// Grammar:\n\t// - Value <=           NaN | PositiveNumber | NegativeNumber\n\t// - PositiveNumber <=  PositivePrefix NumberOrInf PositiveSufix\n\t// - NegativeNumber <=  NegativePrefix NumberOrInf\n\t// - NumberOrInf <=     Number | Inf\n\tgrammar = [\n\t\t[ \"nan\" ],\n\t\t[ \"prefix\", \"infinity\", \"suffix\" ],\n\t\t[ \"prefix\", \"number\", \"suffix\" ],\n\t\t[ \"negativePrefix\", \"infinity\", \"negativeSuffix\" ],\n\t\t[ \"negativePrefix\", \"number\", \"negativeSuffix\" ]\n\t];\n\n\tinvertedSymbolMap = properties[ 0 ];\n\tinvertedNuDigitsMap = properties[ 1 ] || {};\n\ttokenizer = properties[ 2 ];\n\n\tvalue = looseMatching( value );\n\n\tfunction parse( type ) {\n\t\treturn function( lexeme ) {\n\n\t\t\t// Reverse localized symbols and numbering system.\n\t\t\tlexeme = lexeme.split( \"\" ).map(function( character ) {\n\t\t\t\treturn invertedSymbolMap[ character ] ||\n\t\t\t\t\tinvertedNuDigitsMap[ character ] ||\n\t\t\t\t\tcharacter;\n\t\t\t}).join( \"\" );\n\n\t\t\tswitch ( type ) {\n\t\t\t\tcase \"infinity\":\n\t\t\t\t\tnumber = Infinity;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"nan\":\n\t\t\t\t\tnumber = NaN;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"number\":\n\n\t\t\t\t\t// Remove grouping separators.\n\t\t\t\t\tlexeme = lexeme.replace( /,/g, \"\" );\n\n\t\t\t\t\tnumber = +lexeme;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"prefix\":\n\t\t\t\tcase \"negativePrefix\":\n\t\t\t\t\tprefix = lexeme;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"suffix\":\n\t\t\t\t\tsuffix = lexeme;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"negativeSuffix\":\n\t\t\t\t\tsuffix = lexeme;\n\t\t\t\t\tnegative = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// This should never be reached.\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( \"Internal error\" );\n\t\t\t}\n\t\t\treturn \"\";\n\t\t};\n\t}\n\n\tfunction tokenizeNParse( _value, grammar ) {\n\t\treturn grammar.some(function( statement ) {\n\t\t\tvar value = _value;\n\n\t\t\t// The whole grammar statement should be used (i.e., .every() return true) and value be\n\t\t\t// entirely consumed (i.e., !value.length).\n\t\t\treturn statement.every(function( type ) {\n\t\t\t\tif ( value.match( tokenizer[ type ] ) === null ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Consume and parse it.\n\t\t\t\tvalue = value.replace( tokenizer[ type ], parse( type ) );\n\t\t\t\treturn true;\n\t\t\t}) && !value.length;\n\t\t});\n\t}\n\n\tvalid = tokenizeNParse( value, grammar );\n\n\t// NaN\n\tif ( !valid || isNaN( number ) ) {\n\t\treturn NaN;\n\t}\n\n\tprefixNSuffix = \"\" + prefix + suffix;\n\n\t// Percent\n\tif ( prefixNSuffix.indexOf( \"%\" ) !== -1 ) {\n\t\tnumber /= 100;\n\n\t// Per mille\n\t} else if ( prefixNSuffix.indexOf( \"\\u2030\" ) !== -1 ) {\n\t\tnumber /= 1000;\n\t}\n\n\t// Negative number\n\tif ( negative ) {\n\t\tnumber *= -1;\n\t}\n\n\treturn number;\n};\n\n\n\n\nvar numberParserFn = function( properties ) {\n\treturn function numberParser( value ) {\n\t\tvalidateParameterPresence( value, \"value\" );\n\t\tvalidateParameterTypeString( value, \"value\" );\n\n\t\treturn numberParse( value, properties );\n\t};\n\n};\n\n\n\n\n/**\n * symbolMap( cldr )\n *\n * @cldr [Cldr instance].\n *\n * Return the (localized symbol, pattern symbol) key value pair, eg. {\n *   \"٫\": \".\",\n *   \"٬\": \",\",\n *   \"٪\": \"%\",\n *   ...\n * };\n */\nvar numberSymbolInvertedMap = function( cldr ) {\n\tvar symbol,\n\t\tsymbolMap = {};\n\n\tfor ( symbol in numberSymbolName ) {\n\t\tsymbolMap[ numberSymbol( numberSymbolName[ symbol ], cldr ) ] = symbol;\n\t}\n\n\treturn symbolMap;\n};\n\n\n\n\n/**\n * objectMap( object, fn)\n *\n * - object\n *\n * - fn( pair ) => pair\n */\nvar objectMap = function( object, fn ) {\n\treturn Object.keys( object ).map(function( key ) {\n\t\treturn fn([ key, object[ key ] ]);\n\t}).reduce(function( object, pair ) {\n\t\tobject[ pair[ 0 ] ] = pair[ 1 ];\n\t\treturn object;\n\t}, {});\n};\n\n\n\n\n/**\n * removeLiteralQuotes( string )\n *\n * Return:\n * - `'` if input string is `''`.\n * - `o'clock` if input string is `'o''clock'`.\n * - `foo` if input string is `foo`, i.e., return the same value in case it isn't a single-quoted\n *   string.\n */\nvar removeLiteralQuotes = function( string ) {\n\tif ( string[ 0 ] + string[ string.length - 1 ] !== \"''\" ) {\n\t\treturn string;\n\t}\n\tif ( string === \"''\" ) {\n\t\treturn \"'\";\n\t}\n\treturn string.replace( /''/g, \"'\" ).slice( 1, -1 );\n};\n\n\n\n\n/**\n * parseProperties( pattern, cldr )\n *\n * @pattern [String] raw pattern for numbers.\n *\n * @cldr [Cldr instance].\n *\n * Return parser properties, used to feed parser function.\n *\n * TODO:\n * - Scientific_notation;\n * - Padding;\n */\nvar numberParseProperties = function( pattern, cldr, options ) {\n\tvar aux, decimalSymbolRe, digitsRe, groupingSeparatorRe, infinitySymbol, invertedNuDigitsMap,\n\t\tinvertedSymbolMap, maximumFractionDigits, maximumSignificantDigits,\n\t\tminimumSignificantDigits, nanSymbol, negativePrefix, negativeSuffix, nuDigitsMap,\n\t\tnumberTokenizer, prefix, primaryGroupingSize, secondaryGroupingSize, suffix, symbolMap,\n\t\tformatProperties = numberFormatProperties( pattern, cldr, options );\n\n\tprefix = looseMatching( formatProperties[ 0 ] );\n\tmaximumFractionDigits = formatProperties[ 4 ];\n\tminimumSignificantDigits = formatProperties[ 5 ];\n\tmaximumSignificantDigits = formatProperties[ 6 ];\n\tprimaryGroupingSize = formatProperties[ 8 ];\n\tsecondaryGroupingSize = formatProperties[ 9 ];\n\tsuffix = looseMatching( formatProperties[ 10 ] );\n\tnegativePrefix = looseMatching( formatProperties[ 13 ] );\n\tnegativeSuffix = looseMatching( formatProperties[ 14 ] );\n\tinfinitySymbol = looseMatching( formatProperties[ 16 ] );\n\tnanSymbol = looseMatching( formatProperties[ 17 ] );\n\tsymbolMap = objectMap( formatProperties[ 18 ], function( pair ) {\n\t\treturn [ pair[ 0 ], looseMatching( pair[ 1 ] ) ];\n\t});\n\tnuDigitsMap = formatProperties[ 19 ];\n\n\tinvertedSymbolMap = objectMap( numberSymbolInvertedMap( cldr ), function( pair ) {\n\t\treturn [ looseMatching( pair[ 0 ] ), pair[ 1 ] ];\n\t});\n\n\tdigitsRe = nuDigitsMap ? \"[\" + nuDigitsMap + \"]\" : \"\\\\d\";\n\tgroupingSeparatorRe = regexpEscape( symbolMap[ \",\" ] );\n\tdecimalSymbolRe = regexpEscape( symbolMap[ \".\" ] );\n\n\tif ( nuDigitsMap ) {\n\t\tinvertedNuDigitsMap = nuDigitsMap.split( \"\" ).reduce(function( object, localizedDigit, i ) {\n\t\t\tobject[ localizedDigit ] = String( i );\n\t\t\treturn object;\n\t\t}, {} );\n\t}\n\n\taux = [ prefix, suffix, negativePrefix, negativeSuffix ].map(function( value ) {\n\t\treturn value.replace( /('([^']|'')+'|'')|./g, function( character, literal ) {\n\n\t\t\t// Literals\n\t\t\tif ( literal ) {\n\t\t\t\treturn removeLiteralQuotes( literal );\n\t\t\t}\n\n\t\t\t// Symbols\n\t\t\tcharacter = character.replace( /[\\-+E%\\u2030]/, function( symbol ) {\n\t\t\t\treturn symbolMap[ symbol ];\n\t\t\t});\n\n\t\t\treturn character;\n\t\t});\n\t});\n\n\tprefix = aux[ 0 ];\n\tsuffix = aux[ 1 ];\n\tnegativePrefix = aux[ 2 ];\n\tnegativeSuffix = aux[ 3 ];\n\n\t// Number\n\t//\n\t// number_re =                       integer fraction?\n\t//\n\t// integer =                         digits | digits_using_grouping_separators\n\t//\n\t// fraction =                        regexp((.\\d+)?)\n\t//\n\t// digits =                          regexp(\\d+)\n\t//\n\t// digits_w_grouping_separators =    digits_w_1_grouping_separators |\n\t//                                   digits_w_2_grouping_separators\n\t//\n\t// digits_w_1_grouping_separators =  regexp(\\d{1,3}(,\\d{3})+)\n\t//\n\t// digits_w_2_grouping_separators =  regexp(\\d{1,2}((,\\d{2})*(,\\d{3})))\n\n\t// Integer part\n\tnumberTokenizer = digitsRe + \"+\";\n\n\t// Grouping separators\n\tif ( primaryGroupingSize ) {\n\t\tif ( secondaryGroupingSize ) {\n\t\t\taux = digitsRe + \"{1,\" + secondaryGroupingSize + \"}((\" + groupingSeparatorRe +\n\t\t\t\tdigitsRe + \"{\" + secondaryGroupingSize + \"})*(\" + groupingSeparatorRe +\n\t\t\t\tdigitsRe + \"{\" + primaryGroupingSize + \"}))\";\n\t\t} else {\n\t\t\taux = digitsRe + \"{1,\" + primaryGroupingSize + \"}(\" + groupingSeparatorRe +\n\t\t\t\tdigitsRe + \"{\" + primaryGroupingSize + \"})+\";\n\t\t}\n\t\tnumberTokenizer = \"(\" + aux + \"|\" + numberTokenizer + \")\";\n\t}\n\n\t// Fraction part? Only included if 1 or 2.\n\t// 1: Using significant digit format.\n\t// 2: Using integer and fractional format && it has a maximumFractionDigits.\n\tif ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) || /* 1 */\n\t\t\t\tmaximumFractionDigits /* 2 */ ) {\n\n\t\t// 1: Handle trailing decimal separator, e.g., `\"1.\" => `1``.\n\t\taux = decimalSymbolRe + digitsRe + \"+\";\n\t\tnumberTokenizer = numberTokenizer + \"(\" + aux + \"|\" + decimalSymbolRe /* 1 */ + \")?\" +\n\n\t\t\t// Handle non-padded decimals, e.g., `\".12\"` => `0.12` by making the integer part\n\t\t\t// optional.\n\t\t\t\"|(\" + numberTokenizer + \")?\" + aux;\n\n\t\tnumberTokenizer = \"(\" + numberTokenizer + \")\";\n\t}\n\n\t// 0: @invertedSymbolMap [Object] Inverted symbol map.\n\t// 1: @invertedNuDigitsMap [Object] Inverted digits map if numbering system is different than\n\t//    `latn`.\n\t// 2: @tokenizer [Object] Tokenizer map, used by parser to consume input.\n\treturn [\n\t\tinvertedSymbolMap,\n\t\tinvertedNuDigitsMap,\n\t\t{\n\t\t\tinfinity: new RegExp( \"^\" + regexpEscape( infinitySymbol ) ),\n\t\t\tnan: new RegExp( \"^\" + regexpEscape( nanSymbol ) ),\n\t\t\tnegativePrefix: new RegExp( \"^\" + regexpEscape( negativePrefix ) ),\n\t\t\tnegativeSuffix: new RegExp( \"^\" + regexpEscape( negativeSuffix ) ),\n\t\t\tnumber: new RegExp( \"^\" + numberTokenizer ),\n\t\t\tprefix: new RegExp( \"^\" + regexpEscape( prefix ) ),\n\t\t\tsuffix: new RegExp( \"^\" + regexpEscape( suffix ) )\n\t\t}\n\t];\n\n};\n\n\n\n\n/**\n * Pattern( style )\n *\n * @style [String] \"decimal\" (default) or \"percent\".\n *\n * @cldr [Cldr instance].\n */\nvar numberPattern = function( style, cldr ) {\n\tif ( style !== \"decimal\" && style !== \"percent\" ) {\n\t\tthrow new Error( \"Invalid style\" );\n\t}\n\n\treturn cldr.main([\n\t\t\"numbers\",\n\t\tstyle + \"Formats-numberSystem-\" + numberNumberingSystem( cldr ),\n\t\t\"standard\"\n\t]);\n};\n\n\n\n\n/**\n * EBNF representation:\n *\n * compact_pattern_re =       prefix?\n *                            number_pattern_re\n *                            suffix?\n *\n * number_pattern_re =        0+\n *\n * Regexp groups:\n *\n *  0: compact_pattern_re\n *  1: prefix\n *  2: number_pattern_re (the number pattern to use in compact mode)\n *  3: suffix\n */\nvar numberCompactPatternRe = ( /^([^0]*)(0+)([^0]*)$/ );\n\n\n\n\n/**\n * goupingSeparator( number, primaryGroupingSize, secondaryGroupingSize )\n *\n * @number [Number].\n *\n * @primaryGroupingSize [Number]\n *\n * @secondaryGroupingSize [Number]\n *\n * Return the formatted number with group separator.\n */\nvar numberFormatGroupingSeparator = function( number, primaryGroupingSize, secondaryGroupingSize ) {\n\tvar index,\n\t\tcurrentGroupingSize = primaryGroupingSize,\n\t\tret = \"\",\n\t\tsep = \",\",\n\t\tswitchToSecondary = secondaryGroupingSize ? true : false;\n\n\tnumber = String( number ).split( \".\" );\n\tindex = number[ 0 ].length;\n\n\twhile ( index > currentGroupingSize ) {\n\t\tret = number[ 0 ].slice( index - currentGroupingSize, index ) +\n\t\t\t( ret.length ? sep : \"\" ) + ret;\n\t\tindex -= currentGroupingSize;\n\t\tif ( switchToSecondary ) {\n\t\t\tcurrentGroupingSize = secondaryGroupingSize;\n\t\t\tswitchToSecondary = false;\n\t\t}\n\t}\n\n\tnumber[ 0 ] = number[ 0 ].slice( 0, index ) + ( ret.length ? sep : \"\" ) + ret;\n\treturn number.join( \".\" );\n};\n\n\n\n\n/**\n * integerFractionDigits( number, minimumIntegerDigits, minimumFractionDigits,\n * maximumFractionDigits, round, roundIncrement )\n *\n * @number [Number]\n *\n * @minimumIntegerDigits [Number]\n *\n * @minimumFractionDigits [Number]\n *\n * @maximumFractionDigits [Number]\n *\n * @round [Function]\n *\n * @roundIncrement [Function]\n *\n * Return the formatted integer and fraction digits.\n */\nvar numberFormatIntegerFractionDigits = function( number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round,\n\troundIncrement ) {\n\n\t// Fraction\n\tif ( maximumFractionDigits ) {\n\n\t\t// Rounding\n\t\tif ( roundIncrement ) {\n\t\t\tnumber = round( number, roundIncrement );\n\n\t\t// Maximum fraction digits\n\t\t} else {\n\t\t\tnumber = round( number, { exponent: -maximumFractionDigits } );\n\t\t}\n\n\t} else {\n\t\tnumber = round( number );\n\t}\n\n\tnumber = String( number );\n\n\t// Maximum integer digits (post string phase)\n\tif ( maximumFractionDigits && /e-/.test( number ) ) {\n\n\t\t// Use toFixed( maximumFractionDigits ) to make sure small numbers like 1e-7 are\n\t\t// displayed using plain digits instead of scientific notation.\n\t\t// 1: Remove leading decimal zeros.\n\t\t// 2: Remove leading decimal separator.\n\t\t// Note: String() is still preferred so it doesn't mess up with a number precision\n\t\t// unnecessarily, e.g., (123456789.123).toFixed(10) === \"123456789.1229999959\",\n\t\t// String(123456789.123) === \"123456789.123\".\n\t\tnumber = ( +number ).toFixed( maximumFractionDigits )\n\t\t\t.replace( /0+$/, \"\" ) /* 1 */\n\t\t\t.replace( /\\.$/, \"\" ); /* 2 */\n\t}\n\n\t// Minimum fraction digits (post string phase)\n\tif ( minimumFractionDigits ) {\n\t\tnumber = number.split( \".\" );\n\t\tnumber[ 1 ] = stringPad( number[ 1 ] || \"\", minimumFractionDigits, true );\n\t\tnumber = number.join( \".\" );\n\t}\n\n\t// Minimum integer digits\n\tif ( minimumIntegerDigits ) {\n\t\tnumber = number.split( \".\" );\n\t\tnumber[ 0 ] = stringPad( number[ 0 ], minimumIntegerDigits );\n\t\tnumber = number.join( \".\" );\n\t}\n\n\treturn number;\n};\n\n\n\n\n/**\n * toPrecision( number, precision, round )\n *\n * @number (Number)\n *\n * @precision (Number) significant figures precision (not decimal precision).\n *\n * @round (Function)\n *\n * Return number.toPrecision( precision ) using the given round function.\n */\nvar numberToPrecision = function( number, precision, round ) {\n\tvar roundOrder;\n\n\tif ( number === 0 ) {  // Fix #706\n\t\treturn number;\n\t}\n\n\troundOrder = Math.ceil( Math.log( Math.abs( number ) ) / Math.log( 10 ) );\n\troundOrder -= precision;\n\n\treturn round( number, { exponent: roundOrder } );\n};\n\n\n\n\n/**\n * toPrecision( number, minimumSignificantDigits, maximumSignificantDigits, round )\n *\n * @number [Number]\n *\n * @minimumSignificantDigits [Number]\n *\n * @maximumSignificantDigits [Number]\n *\n * @round [Function]\n *\n * Return the formatted significant digits number.\n */\nvar numberFormatSignificantDigits = function( number, minimumSignificantDigits, maximumSignificantDigits, round ) {\n\tvar atMinimum, atMaximum;\n\n\t// Sanity check.\n\tif ( minimumSignificantDigits > maximumSignificantDigits ) {\n\t\tmaximumSignificantDigits = minimumSignificantDigits;\n\t}\n\n\tatMinimum = numberToPrecision( number, minimumSignificantDigits, round );\n\tatMaximum = numberToPrecision( number, maximumSignificantDigits, round );\n\n\t// Use atMaximum only if it has more significant digits than atMinimum.\n\tnumber = +atMinimum === +atMaximum ? atMinimum : atMaximum;\n\n\t// Expand integer numbers, eg. 123e5 to 12300.\n\tnumber = ( +number ).toString( 10 );\n\n\tif ( ( /e/ ).test( number ) ) {\n\t\tthrow createErrorUnsupportedFeature({\n\t\t\tfeature: \"integers out of (1e21, 1e-7)\"\n\t\t});\n\t}\n\n\t// Add trailing zeros if necessary.\n\tif ( minimumSignificantDigits - number.replace( /^0+|\\./g, \"\" ).length > 0 ) {\n\t\tnumber = number.split( \".\" );\n\t\tnumber[ 1 ] = stringPad( number[ 1 ] || \"\", minimumSignificantDigits - number[ 0 ].replace( /^0+/, \"\" ).length, true );\n\t\tnumber = number.join( \".\" );\n\t}\n\n\treturn number;\n};\n\n\n\n\n/**\n * format( number, properties )\n *\n * @number [Number].\n *\n * @properties [Object] Output of number/format-properties.\n *\n * Return the formatted number.\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n */\nvar numberFormat = function( number, properties, pluralGenerator ) {\n\tvar aux, compactMap, infinitySymbol, maximumFractionDigits, maximumSignificantDigits,\n\t\tminimumFractionDigits, minimumIntegerDigits, minimumSignificantDigits, nanSymbol,\n\t\tnuDigitsMap, prefix, primaryGroupingSize, pattern, round, roundIncrement,\n\t\tsecondaryGroupingSize, stringToParts, suffix, symbolMap;\n\n\tminimumIntegerDigits = properties[ 2 ];\n\tminimumFractionDigits = properties[ 3 ];\n\tmaximumFractionDigits = properties[ 4 ];\n\tminimumSignificantDigits = properties[ 5 ];\n\tmaximumSignificantDigits = properties[ 6 ];\n\troundIncrement = properties[ 7 ];\n\tprimaryGroupingSize = properties[ 8 ];\n\tsecondaryGroupingSize = properties[ 9 ];\n\tround = properties[ 15 ];\n\tinfinitySymbol = properties[ 16 ];\n\tnanSymbol = properties[ 17 ];\n\tsymbolMap = properties[ 18 ];\n\tnuDigitsMap = properties[ 19 ];\n\tcompactMap = properties[ 20 ];\n\n\t// NaN\n\tif ( isNaN( number ) ) {\n\t\treturn [ { type: \"nan\", value: nanSymbol } ];\n\t}\n\n\tif ( number < 0 ) {\n\t\tpattern = properties[ 12 ];\n\t\tprefix = properties[ 13 ];\n\t\tsuffix = properties[ 14 ];\n\t} else {\n\t\tpattern = properties[ 11 ];\n\t\tprefix = properties[ 0 ];\n\t\tsuffix = properties[ 10 ];\n\t}\n\n\t// For prefix, suffix, and number parts.\n\tstringToParts = function( string ) {\n\t\tvar numberType = \"integer\",\n\t\t\tparts = [];\n\n\t\t// TODO Move the tokenization of all parts that don't depend on number into\n\t\t// format-properties.\n\t\tstring.replace( /('([^']|'')+'|'')|./g, function( character, literal ) {\n\n\t\t\t// Literals\n\t\t\tif ( literal ) {\n\t\t\t\tpartsPush( parts, \"literal\", removeLiteralQuotes( literal ) );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Currency symbol\n\t\t\tif ( character === \"\\u00A4\" ) {\n\t\t\t\tpartsPush( parts, \"currency\", character );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Symbols\n\t\t\tcharacter = character.replace( /[.,\\-+E%\\u2030]/, function( symbol ) {\n\t\t\t\tif ( symbol === \".\" ) {\n\t\t\t\t\tnumberType = \"fraction\";\n\t\t\t\t}\n\t\t\t\tpartsPush( parts, numberSymbolName[ symbol ], symbolMap[ symbol ] );\n\n\t\t\t\t// \"Erase\" handled character.\n\t\t\t\treturn \"\";\n\t\t\t});\n\n\t\t\t// Number\n\t\t\tcharacter = character.replace( /[0-9]/, function( digit ) {\n\n\t\t\t\t// Numbering system\n\t\t\t\tif ( nuDigitsMap ) {\n\t\t\t\t\tdigit = nuDigitsMap[ +digit ];\n\t\t\t\t}\n\t\t\t\tpartsPush( parts, numberType, digit );\n\n\t\t\t\t// \"Erase\" handled character.\n\t\t\t\treturn \"\";\n\t\t\t});\n\n\t\t\t// Etc\n\t\t\tcharacter.replace( /./, function( etc ) {\n\t\t\t\tpartsPush( parts, \"literal\", etc );\n\t\t\t});\n\t\t});\n\t\treturn parts;\n\t};\n\n\tprefix = stringToParts( prefix );\n\tsuffix = stringToParts( suffix );\n\n\t// Infinity\n\tif ( !isFinite( number ) ) {\n\t\treturn prefix.concat(\n\t\t\t{ type: \"infinity\", value: infinitySymbol },\n\t\t\tsuffix\n\t\t);\n\t}\n\n\t// Percent\n\tif ( pattern.indexOf( \"%\" ) !== -1 ) {\n\t\tnumber *= 100;\n\n\t// Per mille\n\t} else if ( pattern.indexOf( \"\\u2030\" ) !== -1 ) {\n\t\tnumber *= 1000;\n\t}\n\n\tvar compactPattern, compactDigits, compactProperties, divisor, numberExponent, pluralForm;\n\n\t// Compact mode: initial number digit processing\n\tif ( compactMap ) {\n\t\tnumberExponent = Math.abs( Math.floor( number ) ).toString().length - 1;\n\t\tnumberExponent = Math.min( numberExponent, compactMap.maxExponent );\n\n\t\t// Use default plural form to perform initial decimal shift\n\t\tif ( numberExponent >= 3 ) {\n\t\t\tcompactPattern = compactMap[ numberExponent ] && compactMap[ numberExponent ].other;\n\t\t}\n\n\t\tif ( compactPattern === \"0\" ) {\n\t\t\tcompactPattern = null;\n\t\t} else if ( compactPattern ) {\n\t\t\tcompactDigits = compactPattern.split( \"0\" ).length - 1;\n\t\t\tdivisor = numberExponent - ( compactDigits - 1 );\n\t\t\tnumber = number / Math.pow( 10, divisor );\n\t\t}\n\t}\n\n\t// Significant digit format\n\tif ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) ) {\n\t\tnumber = numberFormatSignificantDigits( number, minimumSignificantDigits,\n\t\t\tmaximumSignificantDigits, round );\n\n\t// Integer and fractional format\n\t} else {\n\t\tnumber = numberFormatIntegerFractionDigits( number, minimumIntegerDigits,\n\t\t\tminimumFractionDigits, maximumFractionDigits, round, roundIncrement );\n\t}\n\n\t// Compact mode: apply formatting\n\tif ( compactMap && compactPattern ) {\n\n\t\t// Get plural form after possible roundings\n\t\tpluralForm = pluralGenerator ? pluralGenerator( +number ) : \"other\";\n\n\t\tcompactPattern = compactMap[ numberExponent ][ pluralForm ] || compactPattern;\n\t\tcompactProperties = compactPattern.match( numberCompactPatternRe );\n\n\t\t// TODO Move the tokenization of all parts that don't depend on number into\n\t\t// format-properties.\n\t\taux = function( string ) {\n\t\t\tvar parts = [];\n\t\t\tstring.replace( /(\\s+)|([^\\s0]+)/g, function( _garbage, space, compact ) {\n\n\t\t\t\t// Literals\n\t\t\t\tif ( space ) {\n\t\t\t\t\tpartsPush( parts, \"literal\", space );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Compact value\n\t\t\t\tif ( compact ) {\n\t\t\t\t\tpartsPush( parts, \"compact\", compact );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn parts;\n\t\t};\n\n\t\t// update prefix/suffix with compact prefix/suffix\n\t\tprefix = prefix.concat( aux( compactProperties[ 1 ] ) );\n\t\tsuffix = aux( compactProperties[ 3 ] ).concat( suffix );\n\t}\n\n\t// Remove the possible number minus sign\n\tnumber = number.replace( /^-/, \"\" );\n\n\t// Grouping separators\n\tif ( primaryGroupingSize ) {\n\t\tnumber = numberFormatGroupingSeparator( number, primaryGroupingSize,\n\t\t\tsecondaryGroupingSize );\n\t}\n\n\t// Scientific notation\n\t// TODO implement here\n\n\t// Padding/'([^']|'')+'|''|[.,\\-+E%\\u2030]/g\n\t// TODO implement here\n\n\treturn prefix.concat(\n\t\tstringToParts( number ),\n\t\tsuffix\n\t);\n};\n\n\n\n\nvar numberToPartsFormatterFn = function( properties, pluralGenerator ) {\n\treturn function numberToPartsFormatter( value ) {\n\t\tvalidateParameterPresence( value, \"value\" );\n\t\tvalidateParameterTypeNumber( value, \"value\" );\n\n\t\treturn numberFormat( value, properties, pluralGenerator );\n\t};\n};\n\n\n\n\nfunction validateDigits( properties ) {\n\tvar minimumIntegerDigits = properties[ 2 ],\n\t\tminimumFractionDigits = properties[ 3 ],\n\t\tmaximumFractionDigits = properties[ 4 ],\n\t\tminimumSignificantDigits = properties[ 5 ],\n\t\tmaximumSignificantDigits = properties[ 6 ];\n\n\t// Validate significant digit format properties\n\tif ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) ) {\n\t\tvalidateParameterRange( minimumSignificantDigits, \"minimumSignificantDigits\", 1, 21 );\n\t\tvalidateParameterRange( maximumSignificantDigits, \"maximumSignificantDigits\",\n\t\t\tminimumSignificantDigits, 21 );\n\n\t} else if ( !isNaN( minimumSignificantDigits ) || !isNaN( maximumSignificantDigits ) ) {\n\t\tthrow new Error( \"Neither or both the minimum and maximum significant digits must be \" +\n\t\t\t\"present\" );\n\n\t// Validate integer and fractional format\n\t} else {\n\t\tvalidateParameterRange( minimumIntegerDigits, \"minimumIntegerDigits\", 1, 21 );\n\t\tvalidateParameterRange( minimumFractionDigits, \"minimumFractionDigits\", 0, 20 );\n\t\tvalidateParameterRange( maximumFractionDigits, \"maximumFractionDigits\",\n\t\t\tminimumFractionDigits, 20 );\n\t}\n}\n\n/**\n * .numberFormatter( [options] )\n *\n * @options [Object]:\n * - style: [String] \"decimal\" (default) or \"percent\".\n * - see also number/format options.\n *\n * Return a function that formats a number according to the given options and default/instance\n * locale.\n */\nGlobalize.numberFormatter =\nGlobalize.prototype.numberFormatter = function( options ) {\n\tvar args, numberToPartsFormatter, returnFn;\n\n\tvalidateParameterTypePlainObject( options, \"options\" );\n\n\toptions = options || {};\n\targs = [ options ];\n\n\tnumberToPartsFormatter = this.numberToPartsFormatter( options );\n\treturnFn = numberFormatterFn( numberToPartsFormatter );\n\truntimeBind( args, this.cldr, returnFn, [ numberToPartsFormatter ] );\n\n\treturn returnFn;\n};\n\n/**\n * .numberToPartsFormatter( [options] )\n *\n * @options [Object]:\n * - style: [String] \"symbol\" (default), \"accounting\", \"code\" or \"name\".\n * - see also number/format options.\n *\n * Return a function that formats a number to parts according to the given options and\n * default/instance locale.\n */\nGlobalize.numberToPartsFormatter =\nGlobalize.prototype.numberToPartsFormatter = function( options ) {\n\tvar args, cldr, fnArgs, pattern, properties, returnFn;\n\n\tvalidateParameterTypePlainObject( options, \"options\" );\n\n\toptions = options || {};\n\tcldr = this.cldr;\n\n\targs = [ options ];\n\n\tvalidateDefaultLocale( cldr );\n\n\tcldr.on( \"get\", validateCldr );\n\ttry {\n\t\tif ( options.raw ) {\n\t\t\tpattern = options.raw;\n\t\t} else {\n\t\t\tpattern = numberPattern( options.style || \"decimal\", cldr );\n\t\t}\n\n\t\tproperties = numberFormatProperties( pattern, cldr, options );\n\t\tfnArgs = [ properties ];\n\t} finally {\n\t\tcldr.off( \"get\", validateCldr );\n\t}\n\n\tvalidateDigits( properties );\n\n\tif ( options.compact ) {\n\t\tfnArgs.push( this.pluralGenerator() );\n\t}\n\treturnFn = numberToPartsFormatterFn.apply( null, fnArgs );\n\truntimeBind( args, cldr, returnFn, fnArgs );\n\n\treturn returnFn;\n};\n\n/**\n * .numberParser( [options] )\n *\n * @options [Object]:\n * - style: [String] \"decimal\" (default) or \"percent\".\n *\n * Return the number parser according to the default/instance locale.\n */\nGlobalize.numberParser =\nGlobalize.prototype.numberParser = function( options ) {\n\tvar args, cldr, pattern, properties, returnFn;\n\n\tvalidateParameterTypePlainObject( options, \"options\" );\n\n\toptions = options || {};\n\tcldr = this.cldr;\n\n\targs = [ options ];\n\n\tvalidateDefaultLocale( cldr );\n\tif ( options.compact ) {\n\t\tthrow createErrorUnsupportedFeature({\n\t\t\tfeature: \"compact number parsing (not implemented)\"\n\t\t});\n\t}\n\n\tcldr.on( \"get\", validateCldr );\n\n\tif ( options.raw ) {\n\t\tpattern = options.raw;\n\t} else {\n\t\tpattern = numberPattern( options.style || \"decimal\", cldr );\n\t}\n\n\tproperties = numberParseProperties( pattern, cldr, options );\n\n\tcldr.off( \"get\", validateCldr );\n\n\treturnFn = numberParserFn( properties );\n\n\truntimeBind( args, cldr, returnFn, [ properties ] );\n\n\treturn returnFn;\n};\n\n/**\n * .formatNumber( value [, options] )\n *\n * @value [Number] number to be formatted.\n *\n * @options [Object]: see number/format-properties.\n *\n * Format a number according to the given options and default/instance locale.\n */\nGlobalize.formatNumber =\nGlobalize.prototype.formatNumber = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeNumber( value, \"value\" );\n\n\treturn this.numberFormatter( options )( value );\n};\n\n/**\n * .formatNumberToParts( value [, options] )\n *\n * @value [Number] number to be formatted.\n *\n * @options [Object]: see number/format-properties.\n *\n * Format a number to pars according to the given options and default/instance locale.\n */\nGlobalize.formatNumberToParts =\nGlobalize.prototype.formatNumberToParts = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeNumber( value, \"value\" );\n\n\treturn this.numberToPartsFormatter( options )( value );\n};\n\n/**\n * .parseNumber( value [, options] )\n *\n * @value [String]\n *\n * @options [Object]: See numberParser().\n *\n * Return the parsed Number (including Infinity) or NaN when value is invalid.\n */\nGlobalize.parseNumber =\nGlobalize.prototype.parseNumber = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeString( value, \"value\" );\n\n\treturn this.numberParser( options )( value );\n};\n\n/**\n * Optimization to avoid duplicating some internal functions across modules.\n */\nGlobalize._createErrorUnsupportedFeature = createErrorUnsupportedFeature;\nGlobalize._numberNumberingSystem = numberNumberingSystem;\nGlobalize._numberNumberingSystemDigitsMap = numberNumberingSystemDigitsMap;\nGlobalize._numberPattern = numberPattern;\nGlobalize._numberSymbol = numberSymbol;\nGlobalize._looseMatching = looseMatching;\nGlobalize._removeLiteralQuotes = removeLiteralQuotes;\nGlobalize._stringPad = stringPad;\nGlobalize._validateParameterTypeNumber = validateParameterTypeNumber;\nGlobalize._validateParameterTypeString = validateParameterTypeString;\n\nreturn Globalize;\n\n\n\n\n}));\n"]},"metadata":{},"sourceType":"script"}