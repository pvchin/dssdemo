{"ast":null,"code":"import { V1_PREDEFINED_VARS, V1_CONDITIONAL_OPERATORS } from \"../consts\";\n/**\n * Normalize an offset value\n * @param {String} expression a decimal value which may have a 'p' or '%' postfix. E.g. '35%', '0.4p'\n * @return {Object|String} a normalized String of the input value if possible otherwise the value itself\n */\n\nexport function v1NormalizeExpression(expression) {\n  if (typeof expression !== 'string' || expression.length === 0 || expression.match(/^!.+!$/)) {\n    return expression;\n  }\n\n  var operators = \"\\\\|\\\\||>=|<=|&&|!=|>|=|<|/|-|\\\\^|\\\\+|\\\\*\";\n  var operatorsPattern = \"((\" + operators + \")(?=[ _]))\";\n  var operatorsReplaceRE = new RegExp(operatorsPattern, \"g\");\n  expression = expression.replace(operatorsReplaceRE, function (match) {\n    return V1_CONDITIONAL_OPERATORS[match];\n  });\n  var predefinedVarsPattern = \"(\" + Object.keys(V1_PREDEFINED_VARS).join(\"|\") + \")\";\n  var predefinedVarsReplaceRE = new RegExp(predefinedVarsPattern, \"g\"); // @ts-ignore\n\n  expression = expression.replace(predefinedVarsReplaceRE, function (match, p1, offset) {\n    return expression[offset - 1] === '$' ? match : V1_PREDEFINED_VARS[match];\n  });\n  return expression.replace(/[ _]+/g, '_');\n}","map":{"version":3,"sources":["D:/react-myprojects/hrms-airtable/node_modules/@cloudinary/base/backwards/utils/v1NormalizeExpression.js"],"names":["V1_PREDEFINED_VARS","V1_CONDITIONAL_OPERATORS","v1NormalizeExpression","expression","length","match","operators","operatorsPattern","operatorsReplaceRE","RegExp","replace","predefinedVarsPattern","Object","keys","join","predefinedVarsReplaceRE","p1","offset"],"mappings":"AAAA,SAASA,kBAAT,EAA6BC,wBAA7B,QAA6D,WAA7D;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,qBAAT,CAA+BC,UAA/B,EAA2C;AAC9C,MAAI,OAAOA,UAAP,KAAsB,QAAtB,IAAkCA,UAAU,CAACC,MAAX,KAAsB,CAAxD,IAA6DD,UAAU,CAACE,KAAX,CAAiB,QAAjB,CAAjE,EAA6F;AACzF,WAAOF,UAAP;AACH;;AACD,MAAMG,SAAS,GAAG,0CAAlB;AACA,MAAMC,gBAAgB,GAAG,OAAOD,SAAP,GAAmB,YAA5C;AACA,MAAME,kBAAkB,GAAG,IAAIC,MAAJ,CAAWF,gBAAX,EAA6B,GAA7B,CAA3B;AACAJ,EAAAA,UAAU,GAAGA,UAAU,CAACO,OAAX,CAAmBF,kBAAnB,EAAuC,UAACH,KAAD,EAAW;AAC3D,WAAOJ,wBAAwB,CAACI,KAAD,CAA/B;AACH,GAFY,CAAb;AAGA,MAAMM,qBAAqB,GAAG,MAAMC,MAAM,CAACC,IAAP,CAAYb,kBAAZ,EAAgCc,IAAhC,CAAqC,GAArC,CAAN,GAAkD,GAAhF;AACA,MAAMC,uBAAuB,GAAG,IAAIN,MAAJ,CAAWE,qBAAX,EAAkC,GAAlC,CAAhC,CAX8C,CAY9C;;AACAR,EAAAA,UAAU,GAAGA,UAAU,CAACO,OAAX,CAAmBK,uBAAnB,EAA4C,UAACV,KAAD,EAAQW,EAAR,EAAYC,MAAZ;AAAA,WAAwBd,UAAU,CAACc,MAAM,GAAG,CAAV,CAAV,KAA2B,GAA3B,GAAiCZ,KAAjC,GAAyCL,kBAAkB,CAACK,KAAD,CAAnF;AAAA,GAA5C,CAAb;AACA,SAAOF,UAAU,CAACO,OAAX,CAAmB,QAAnB,EAA6B,GAA7B,CAAP;AACH","sourcesContent":["import { V1_PREDEFINED_VARS, V1_CONDITIONAL_OPERATORS } from \"../consts\";\n/**\n * Normalize an offset value\n * @param {String} expression a decimal value which may have a 'p' or '%' postfix. E.g. '35%', '0.4p'\n * @return {Object|String} a normalized String of the input value if possible otherwise the value itself\n */\nexport function v1NormalizeExpression(expression) {\n    if (typeof expression !== 'string' || expression.length === 0 || expression.match(/^!.+!$/)) {\n        return expression;\n    }\n    const operators = \"\\\\|\\\\||>=|<=|&&|!=|>|=|<|/|-|\\\\^|\\\\+|\\\\*\";\n    const operatorsPattern = \"((\" + operators + \")(?=[ _]))\";\n    const operatorsReplaceRE = new RegExp(operatorsPattern, \"g\");\n    expression = expression.replace(operatorsReplaceRE, (match) => {\n        return V1_CONDITIONAL_OPERATORS[match];\n    });\n    const predefinedVarsPattern = \"(\" + Object.keys(V1_PREDEFINED_VARS).join(\"|\") + \")\";\n    const predefinedVarsReplaceRE = new RegExp(predefinedVarsPattern, \"g\");\n    // @ts-ignore\n    expression = expression.replace(predefinedVarsReplaceRE, (match, p1, offset) => (expression[offset - 1] === '$' ? match : V1_PREDEFINED_VARS[match]));\n    return expression.replace(/[ _]+/g, '_');\n}\n"]},"metadata":{},"sourceType":"module"}