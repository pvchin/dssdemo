{"ast":null,"code":"import { encodeVersion } from \"./encodeVersion\";\nimport { getAnalyticsOptions } from \"./getAnalyticsOptions\";\nimport pkg from '../package.json';\n/**\n * @private\n * @description Try to get the node version out of process, if browser just return 0.0.0\n */\n\nfunction getNodeVersion() {\n  var failedVersion = '0.0.0';\n\n  if (typeof window !== 'undefined') {\n    return failedVersion;\n  } else {\n    // node env\n    try {\n      return process.versions.node || failedVersion;\n    } catch (e) {\n      return failedVersion;\n    }\n  }\n}\n/**\n * @private\n * @description Ensure that all values ITrackedPropertiesThroughAnalytics are populated.\n * Accept a partial map of values and returns the complete interface of ITrackedPropertiesThroughAnalytics\n * @param {ITrackedPropertiesThroughAnalytics} trackedAnalytics\n * @param {ITrackedPropertiesThroughAnalytics} trackedAnalytics\n */\n\n\nfunction ensureShapeOfTrackedProperties(trackedAnalytics) {\n  // try to get the process version from node, but if we're on the client return 0.0.0\n  var defaults = {\n    techVersion: getNodeVersion(),\n    sdkCode: 'T',\n    sdkSemver: pkg.version.split('-')[0],\n    responsive: false,\n    placeholder: false,\n    lazyload: false,\n    accessibility: false\n  };\n\n  if (!trackedAnalytics) {\n    return defaults;\n  } else {\n    return Object.assign(Object.assign({}, defaults), trackedAnalytics);\n  }\n}\n/**\n * @private\n * @description Creates the complete SDK signature by using all the values provided by ITrackedPropertiesThroughAnalytics\n *              Creation of the signature\n *              - Set the AlgoVersion of the encoding, this is an internal letter that represents the version\n *                of our encoding algorithm, it will allow us to perform breaking changes if we'll need them.\n *              - Take the constant SDK code (Arbitrary letter chosen for each SDK, for Base that letter is 'T')\n *                this is used to tell apart which SDK is being tracked.\n *              - Take the {major.minor} versions of the node version (techVersion) (14.2, 16.2 etc.)\n *              - Take the full semver of the SDK you wish to track\n *              - Take the features used(lazy, placeholder etc.) and turn them to a letter (for example accessibility -> D)\n *              - Before appending the string, the Versions must be encoded, see the function `encodeVersion` for more details\n *              - Append all the variables to a single string\n *              - In any case of an error, return the single letter 'E'\n *\n * @return {string} sdkAnalyticsSignature\n */\n\n\nexport function getSDKAnalyticsSignature(_trackedAnalytics) {\n  var trackedAnalytics = ensureShapeOfTrackedProperties(_trackedAnalytics);\n  var analyticsOptions = getAnalyticsOptions(trackedAnalytics);\n\n  try {\n    var twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);\n    var encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);\n    var encodedTechVersion = encodeVersion(twoPartVersion);\n    var featureCode = analyticsOptions.feature;\n    var SDKCode = analyticsOptions.sdkCode;\n    var algoVersion = 'A'; // The algo version is determined here, it should not be an argument\n\n    return \"\".concat(algoVersion).concat(SDKCode).concat(encodedSDKVersion).concat(encodedTechVersion).concat(featureCode);\n  } catch (e) {\n    // Either SDK or Node versions were unparsable\n    return 'E';\n  }\n}\n/**\n * @private\n * @description Removes patch version from the semver if it exists\n *              Turns x.y.z OR x.y into x.y\n * @param {'x.y.z' | 'x.y' | string} semVerStr\n */\n\nfunction removePatchFromSemver(semVerStr) {\n  var parts = semVerStr.split('.');\n  return \"\".concat(parts[0], \".\").concat(parts[1]);\n}","map":{"version":3,"sources":["D:/react-myprojects/hrms-airtable/node_modules/@cloudinary/base/sdkAnalytics/getSDKAnalyticsSignature.js"],"names":["encodeVersion","getAnalyticsOptions","pkg","getNodeVersion","failedVersion","window","process","versions","node","e","ensureShapeOfTrackedProperties","trackedAnalytics","defaults","techVersion","sdkCode","sdkSemver","version","split","responsive","placeholder","lazyload","accessibility","Object","assign","getSDKAnalyticsSignature","_trackedAnalytics","analyticsOptions","twoPartVersion","removePatchFromSemver","encodedSDKVersion","encodedTechVersion","featureCode","feature","SDKCode","algoVersion","semVerStr","parts"],"mappings":"AAAA,SAASA,aAAT,QAA8B,iBAA9B;AACA,SAASC,mBAAT,QAAoC,uBAApC;AACA,OAAOC,GAAP,MAAgB,iBAAhB;AACA;AACA;AACA;AACA;;AACA,SAASC,cAAT,GAA0B;AACtB,MAAMC,aAAa,GAAG,OAAtB;;AACA,MAAI,OAAOC,MAAP,KAAkB,WAAtB,EAAmC;AAC/B,WAAOD,aAAP;AACH,GAFD,MAGK;AACD;AACA,QAAI;AACA,aAAOE,OAAO,CAACC,QAAR,CAAiBC,IAAjB,IAAyBJ,aAAhC;AACH,KAFD,CAGA,OAAOK,CAAP,EAAU;AACN,aAAOL,aAAP;AACH;AACJ;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASM,8BAAT,CAAwCC,gBAAxC,EAA0D;AACtD;AACA,MAAMC,QAAQ,GAAG;AACbC,IAAAA,WAAW,EAAEV,cAAc,EADd;AAEbW,IAAAA,OAAO,EAAE,GAFI;AAGbC,IAAAA,SAAS,EAAEb,GAAG,CAACc,OAAJ,CAAYC,KAAZ,CAAkB,GAAlB,EAAuB,CAAvB,CAHE;AAIbC,IAAAA,UAAU,EAAE,KAJC;AAKbC,IAAAA,WAAW,EAAE,KALA;AAMbC,IAAAA,QAAQ,EAAE,KANG;AAObC,IAAAA,aAAa,EAAE;AAPF,GAAjB;;AASA,MAAI,CAACV,gBAAL,EAAuB;AACnB,WAAOC,QAAP;AACH,GAFD,MAGK;AACD,WAAOU,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBX,QAAlB,CAAd,EAA2CD,gBAA3C,CAAP;AACH;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASa,wBAAT,CAAkCC,iBAAlC,EAAqD;AACxD,MAAMd,gBAAgB,GAAGD,8BAA8B,CAACe,iBAAD,CAAvD;AACA,MAAMC,gBAAgB,GAAGzB,mBAAmB,CAACU,gBAAD,CAA5C;;AACA,MAAI;AACA,QAAMgB,cAAc,GAAGC,qBAAqB,CAACF,gBAAgB,CAACb,WAAlB,CAA5C;AACA,QAAMgB,iBAAiB,GAAG7B,aAAa,CAAC0B,gBAAgB,CAACX,SAAlB,CAAvC;AACA,QAAMe,kBAAkB,GAAG9B,aAAa,CAAC2B,cAAD,CAAxC;AACA,QAAMI,WAAW,GAAGL,gBAAgB,CAACM,OAArC;AACA,QAAMC,OAAO,GAAGP,gBAAgB,CAACZ,OAAjC;AACA,QAAMoB,WAAW,GAAG,GAApB,CANA,CAMyB;;AACzB,qBAAUA,WAAV,SAAwBD,OAAxB,SAAkCJ,iBAAlC,SAAsDC,kBAAtD,SAA2EC,WAA3E;AACH,GARD,CASA,OAAOtB,CAAP,EAAU;AACN;AACA,WAAO,GAAP;AACH;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;;AACA,SAASmB,qBAAT,CAA+BO,SAA/B,EAA0C;AACtC,MAAMC,KAAK,GAAGD,SAAS,CAAClB,KAAV,CAAgB,GAAhB,CAAd;AACA,mBAAUmB,KAAK,CAAC,CAAD,CAAf,cAAsBA,KAAK,CAAC,CAAD,CAA3B;AACH","sourcesContent":["import { encodeVersion } from \"./encodeVersion\";\nimport { getAnalyticsOptions } from \"./getAnalyticsOptions\";\nimport pkg from '../package.json';\n/**\n * @private\n * @description Try to get the node version out of process, if browser just return 0.0.0\n */\nfunction getNodeVersion() {\n    const failedVersion = '0.0.0';\n    if (typeof window !== 'undefined') {\n        return failedVersion;\n    }\n    else {\n        // node env\n        try {\n            return process.versions.node || failedVersion;\n        }\n        catch (e) {\n            return failedVersion;\n        }\n    }\n}\n/**\n * @private\n * @description Ensure that all values ITrackedPropertiesThroughAnalytics are populated.\n * Accept a partial map of values and returns the complete interface of ITrackedPropertiesThroughAnalytics\n * @param {ITrackedPropertiesThroughAnalytics} trackedAnalytics\n * @param {ITrackedPropertiesThroughAnalytics} trackedAnalytics\n */\nfunction ensureShapeOfTrackedProperties(trackedAnalytics) {\n    // try to get the process version from node, but if we're on the client return 0.0.0\n    const defaults = {\n        techVersion: getNodeVersion(),\n        sdkCode: 'T',\n        sdkSemver: pkg.version.split('-')[0],\n        responsive: false,\n        placeholder: false,\n        lazyload: false,\n        accessibility: false\n    };\n    if (!trackedAnalytics) {\n        return defaults;\n    }\n    else {\n        return Object.assign(Object.assign({}, defaults), trackedAnalytics);\n    }\n}\n/**\n * @private\n * @description Creates the complete SDK signature by using all the values provided by ITrackedPropertiesThroughAnalytics\n *              Creation of the signature\n *              - Set the AlgoVersion of the encoding, this is an internal letter that represents the version\n *                of our encoding algorithm, it will allow us to perform breaking changes if we'll need them.\n *              - Take the constant SDK code (Arbitrary letter chosen for each SDK, for Base that letter is 'T')\n *                this is used to tell apart which SDK is being tracked.\n *              - Take the {major.minor} versions of the node version (techVersion) (14.2, 16.2 etc.)\n *              - Take the full semver of the SDK you wish to track\n *              - Take the features used(lazy, placeholder etc.) and turn them to a letter (for example accessibility -> D)\n *              - Before appending the string, the Versions must be encoded, see the function `encodeVersion` for more details\n *              - Append all the variables to a single string\n *              - In any case of an error, return the single letter 'E'\n *\n * @return {string} sdkAnalyticsSignature\n */\nexport function getSDKAnalyticsSignature(_trackedAnalytics) {\n    const trackedAnalytics = ensureShapeOfTrackedProperties(_trackedAnalytics);\n    const analyticsOptions = getAnalyticsOptions(trackedAnalytics);\n    try {\n        const twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);\n        const encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);\n        const encodedTechVersion = encodeVersion(twoPartVersion);\n        const featureCode = analyticsOptions.feature;\n        const SDKCode = analyticsOptions.sdkCode;\n        const algoVersion = 'A'; // The algo version is determined here, it should not be an argument\n        return `${algoVersion}${SDKCode}${encodedSDKVersion}${encodedTechVersion}${featureCode}`;\n    }\n    catch (e) {\n        // Either SDK or Node versions were unparsable\n        return 'E';\n    }\n}\n/**\n * @private\n * @description Removes patch version from the semver if it exists\n *              Turns x.y.z OR x.y into x.y\n * @param {'x.y.z' | 'x.y' | string} semVerStr\n */\nfunction removePatchFromSemver(semVerStr) {\n    const parts = semVerStr.split('.');\n    return `${parts[0]}.${parts[1]}`;\n}\n"]},"metadata":{},"sourceType":"module"}