{"ast":null,"code":"import _classCallCheck from \"D:/react-myprojects/hrms-airtable/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/react-myprojects/hrms-airtable/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { getUrlPrefix, getUrlVersion, handleAssetType, handleStorageType } from \"../internal/url/cloudinaryURL\";\nimport URLConfig from \"../config/URLConfig\";\nimport { getSDKAnalyticsSignature } from \"../sdkAnalytics/getSDKAnalyticsSignature\";\n/**\n * This const contains all the valid combination of asset/storage for URL shortening purposes\n * It's exported because it's used in a test, but it's not really shared enough to belong in a separate file\n */\n\nexport var SEO_TYPES = {\n  \"image/upload\": \"images\",\n  \"image/private\": \"private_images\",\n  \"image/authenticated\": \"authenticated_images\",\n  \"raw/upload\": \"files\",\n  \"video/upload\": \"videos\"\n};\n/**\n * @desc Cloudinary file without a transformation\n * @summary SDK\n * @memberOf SDK\n */\n\nvar CloudinaryFile = /*#__PURE__*/function () {\n  function CloudinaryFile(publicID) {\n    var cloudConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var urlConfig = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, CloudinaryFile);\n\n    this.setPublicID(publicID);\n    this.cloudName = cloudConfig.cloudName;\n    this.apiKey = cloudConfig.apiKey;\n    this.apiSecret = cloudConfig.apiSecret;\n    this.authToken = cloudConfig.authToken;\n    this.urlConfig = new URLConfig(urlConfig);\n  }\n\n  _createClass(CloudinaryFile, [{\n    key: \"setPublicID\",\n    value: function setPublicID(publicID) {\n      // PublicID must be a string!\n      this.publicID = publicID ? publicID.toString() : '';\n      return this;\n    }\n  }, {\n    key: \"setStorageType\",\n    value: function setStorageType(newType) {\n      this.storageType = newType;\n      return this;\n    }\n  }, {\n    key: \"setSuffix\",\n    value: function setSuffix(newSuffix) {\n      this.suffix = newSuffix;\n      return this;\n    }\n  }, {\n    key: \"setSignature\",\n    value: function setSignature(signature) {\n      this.signature = signature;\n      return this;\n    }\n  }, {\n    key: \"setVersion\",\n    value: function setVersion(newVersion) {\n      if (newVersion) {\n        this.version = newVersion;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setAssetType\",\n    value: function setAssetType(newType) {\n      if (newType) {\n        this.assetType = newType;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"sign\",\n    value: function sign() {\n      return this;\n    }\n  }, {\n    key: \"toURL\",\n    value: function toURL() {\n      var overwriteOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.createCloudinaryURL(null, overwriteOptions.trackedAnalytics);\n    }\n    /**\n     * @description Validate various options before attempting to create a URL\n     * The function will throw in case a violation\n     * @throws Validation errors\n     */\n\n  }, {\n    key: \"validateAssetForURLCreation\",\n    value: function validateAssetForURLCreation() {\n      if (typeof this.cloudName === 'undefined') {\n        throw 'You must supply a cloudName in either toURL() or when initializing the asset';\n      }\n\n      var suffixContainsDot = this.suffix && this.suffix.indexOf('.') >= 0;\n      var suffixContainsSlash = this.suffix && this.suffix.indexOf('/') >= 0;\n\n      if (suffixContainsDot || suffixContainsSlash) {\n        throw '`suffix`` should not include . or /';\n      }\n    }\n    /**\n     * @description return an SEO friendly name for a combination of asset/storage, some examples:\n     * * image/upload -> images\n     * * video/upload -> videos\n     * If no match is found, return `{asset}/{storage}`\n     */\n\n  }, {\n    key: \"getResourceType\",\n    value: function getResourceType() {\n      var assetType = handleAssetType(this.assetType);\n      var storageType = handleStorageType(this.storageType);\n      var hasSuffix = !!this.suffix;\n      var regularSEOType = \"\".concat(assetType, \"/\").concat(storageType);\n      var shortSEOType = SEO_TYPES[\"\".concat(assetType, \"/\").concat(storageType)];\n      var useRootPath = this.urlConfig.useRootPath;\n      var shorten = this.urlConfig.shorten; // Quick exit incase of useRootPath\n\n      if (useRootPath) {\n        if (regularSEOType === 'image/upload') {\n          return ''; // For image/upload we're done, just return nothing\n        } else {\n          throw new Error(\"useRootPath can only be used with assetType: 'image' and storageType: 'upload'. Provided: \".concat(regularSEOType, \" instead\"));\n        }\n      }\n\n      if (shorten && regularSEOType === 'image/upload') {\n        return 'iu';\n      }\n\n      if (hasSuffix) {\n        if (shortSEOType) {\n          return shortSEOType;\n        } else {\n          throw new Error(\"URL Suffix only supported for \".concat(Object.keys(SEO_TYPES).join(', '), \", Provided: \").concat(regularSEOType, \" instead\"));\n        }\n      } // If all else fails, return the regular image/upload combination (asset/storage)\n\n\n      return regularSEOType;\n    }\n  }, {\n    key: \"getSignature\",\n    value: function getSignature() {\n      if (this.signature) {\n        return \"s--\".concat(this.signature, \"--\");\n      } else {\n        return '';\n      }\n    }\n    /**\n     *\n     * @description Creates a fully qualified CloudinaryURL\n     * @return {string} CloudinaryURL\n     * @throws Validation Errors\n     */\n\n  }, {\n    key: \"createCloudinaryURL\",\n    value: function createCloudinaryURL(transformation, trackedAnalytics) {\n      // In accordance with the existing implementation, if no publicID exists we should return nothing.\n      if (!this.publicID) {\n        return '';\n      } // Throws if some options are mis-configured\n      // See the function for more information on when it throws\n\n\n      this.validateAssetForURLCreation();\n      var prefix = getUrlPrefix(this.cloudName, this.urlConfig);\n      var transformationString = transformation ? transformation.toString() : '';\n      var version = getUrlVersion(this.publicID, this.version, this.urlConfig.forceVersion);\n      var publicID = this.publicID // Serialize the publicID, but leave slashes alone.\n      // we can't use serializeCloudinaryCharacters because that does both things (, and /)\n      .replace(/,/g, '%2C'); // Resource type is a mixture of assetType, storageType and various URL Configurations\n      // Note how `suffix` changes both image/upload (resourceType) and also is appended at the end\n\n      var url = [prefix, this.getResourceType(), this.getSignature(), transformationString, version, publicID, this.suffix].filter(function (a) {\n        return a;\n      }).join('/');\n\n      if (typeof transformation === 'string') {\n        return url;\n      } else {\n        var safeURL = encodeURI(url).replace(/\\?/g, '%3F').replace(/=/g, '%3D'); // True by default, has to be explicitly set to false to overwrite\n\n        if (this.urlConfig.analytics !== false) {\n          return \"\".concat(safeURL, \"?_a=\").concat(getSDKAnalyticsSignature(trackedAnalytics));\n        } else {\n          return safeURL;\n        }\n      }\n    }\n  }]);\n\n  return CloudinaryFile;\n}();\n\nexport { CloudinaryFile };","map":{"version":3,"sources":["D:/react-myprojects/hrms-airtable/node_modules/@cloudinary/base/assets/CloudinaryFile.js"],"names":["getUrlPrefix","getUrlVersion","handleAssetType","handleStorageType","URLConfig","getSDKAnalyticsSignature","SEO_TYPES","CloudinaryFile","publicID","cloudConfig","urlConfig","setPublicID","cloudName","apiKey","apiSecret","authToken","toString","newType","storageType","newSuffix","suffix","signature","newVersion","version","assetType","overwriteOptions","createCloudinaryURL","trackedAnalytics","suffixContainsDot","indexOf","suffixContainsSlash","hasSuffix","regularSEOType","shortSEOType","useRootPath","shorten","Error","Object","keys","join","transformation","validateAssetForURLCreation","prefix","transformationString","forceVersion","replace","url","getResourceType","getSignature","filter","a","safeURL","encodeURI","analytics"],"mappings":"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","sourcesContent":["import { getUrlPrefix, getUrlVersion, handleAssetType, handleStorageType } from \"../internal/url/cloudinaryURL\";\nimport URLConfig from \"../config/URLConfig\";\nimport { getSDKAnalyticsSignature } from \"../sdkAnalytics/getSDKAnalyticsSignature\";\n/**\n * This const contains all the valid combination of asset/storage for URL shortening purposes\n * It's exported because it's used in a test, but it's not really shared enough to belong in a separate file\n */\nexport const SEO_TYPES = {\n    \"image/upload\": \"images\",\n    \"image/private\": \"private_images\",\n    \"image/authenticated\": \"authenticated_images\",\n    \"raw/upload\": \"files\",\n    \"video/upload\": \"videos\"\n};\n/**\n * @desc Cloudinary file without a transformation\n * @summary SDK\n * @memberOf SDK\n */\nclass CloudinaryFile {\n    constructor(publicID, cloudConfig = {}, urlConfig) {\n        this.setPublicID(publicID);\n        this.cloudName = cloudConfig.cloudName;\n        this.apiKey = cloudConfig.apiKey;\n        this.apiSecret = cloudConfig.apiSecret;\n        this.authToken = cloudConfig.authToken;\n        this.urlConfig = new URLConfig(urlConfig);\n    }\n    setPublicID(publicID) {\n        // PublicID must be a string!\n        this.publicID = publicID ? publicID.toString() : '';\n        return this;\n    }\n    setStorageType(newType) {\n        this.storageType = newType;\n        return this;\n    }\n    setSuffix(newSuffix) {\n        this.suffix = newSuffix;\n        return this;\n    }\n    setSignature(signature) {\n        this.signature = signature;\n        return this;\n    }\n    setVersion(newVersion) {\n        if (newVersion) {\n            this.version = newVersion;\n        }\n        return this;\n    }\n    setAssetType(newType) {\n        if (newType) {\n            this.assetType = newType;\n        }\n        return this;\n    }\n    sign() {\n        return this;\n    }\n    toURL(overwriteOptions = {}) {\n        return this.createCloudinaryURL(null, overwriteOptions.trackedAnalytics);\n    }\n    /**\n     * @description Validate various options before attempting to create a URL\n     * The function will throw in case a violation\n     * @throws Validation errors\n     */\n    validateAssetForURLCreation() {\n        if (typeof this.cloudName === 'undefined') {\n            throw 'You must supply a cloudName in either toURL() or when initializing the asset';\n        }\n        const suffixContainsDot = this.suffix && this.suffix.indexOf('.') >= 0;\n        const suffixContainsSlash = this.suffix && this.suffix.indexOf('/') >= 0;\n        if (suffixContainsDot || suffixContainsSlash) {\n            throw '`suffix`` should not include . or /';\n        }\n    }\n    /**\n     * @description return an SEO friendly name for a combination of asset/storage, some examples:\n     * * image/upload -> images\n     * * video/upload -> videos\n     * If no match is found, return `{asset}/{storage}`\n     */\n    getResourceType() {\n        const assetType = handleAssetType(this.assetType);\n        const storageType = handleStorageType(this.storageType);\n        const hasSuffix = !!this.suffix;\n        const regularSEOType = `${assetType}/${storageType}`;\n        const shortSEOType = SEO_TYPES[`${assetType}/${storageType}`];\n        const useRootPath = this.urlConfig.useRootPath;\n        const shorten = this.urlConfig.shorten;\n        // Quick exit incase of useRootPath\n        if (useRootPath) {\n            if (regularSEOType === 'image/upload') {\n                return ''; // For image/upload we're done, just return nothing\n            }\n            else {\n                throw new Error(`useRootPath can only be used with assetType: 'image' and storageType: 'upload'. Provided: ${regularSEOType} instead`);\n            }\n        }\n        if (shorten && regularSEOType === 'image/upload') {\n            return 'iu';\n        }\n        if (hasSuffix) {\n            if (shortSEOType) {\n                return shortSEOType;\n            }\n            else {\n                throw new Error(`URL Suffix only supported for ${Object.keys(SEO_TYPES).join(', ')}, Provided: ${regularSEOType} instead`);\n            }\n        }\n        // If all else fails, return the regular image/upload combination (asset/storage)\n        return regularSEOType;\n    }\n    getSignature() {\n        if (this.signature) {\n            return `s--${this.signature}--`;\n        }\n        else {\n            return '';\n        }\n    }\n    /**\n     *\n     * @description Creates a fully qualified CloudinaryURL\n     * @return {string} CloudinaryURL\n     * @throws Validation Errors\n     */\n    createCloudinaryURL(transformation, trackedAnalytics) {\n        // In accordance with the existing implementation, if no publicID exists we should return nothing.\n        if (!this.publicID) {\n            return '';\n        }\n        // Throws if some options are mis-configured\n        // See the function for more information on when it throws\n        this.validateAssetForURLCreation();\n        const prefix = getUrlPrefix(this.cloudName, this.urlConfig);\n        const transformationString = transformation ? transformation.toString() : '';\n        const version = getUrlVersion(this.publicID, this.version, this.urlConfig.forceVersion);\n        const publicID = this.publicID\n            // Serialize the publicID, but leave slashes alone.\n            // we can't use serializeCloudinaryCharacters because that does both things (, and /)\n            .replace(/,/g, '%2C');\n        // Resource type is a mixture of assetType, storageType and various URL Configurations\n        // Note how `suffix` changes both image/upload (resourceType) and also is appended at the end\n        const url = [prefix, this.getResourceType(), this.getSignature(), transformationString, version, publicID, this.suffix]\n            .filter((a) => a)\n            .join('/');\n        if (typeof transformation === 'string') {\n            return url;\n        }\n        else {\n            const safeURL = encodeURI(url)\n                .replace(/\\?/g, '%3F')\n                .replace(/=/g, '%3D');\n            // True by default, has to be explicitly set to false to overwrite\n            if (this.urlConfig.analytics !== false) {\n                return `${safeURL}?_a=${getSDKAnalyticsSignature(trackedAnalytics)}`;\n            }\n            else {\n                return safeURL;\n            }\n        }\n    }\n}\nexport { CloudinaryFile };\n"]},"metadata":{},"sourceType":"module"}