{"ast":null,"code":"/**\n * Globalize v1.7.0\n *\n * https://github.com/globalizejs/globalize\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2021-08-02T11:53Z\n */\n\n/*!\n * Globalize v1.7.0 2021-08-02T11:53Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function (root, factory) {\n  // UMD returnExports\n  if (typeof define === \"function\" && define.amd) {\n    // AMD\n    define([\"cldr\", \"../globalize\", \"./number\", \"cldr/event\", \"cldr/supplemental\"], factory);\n  } else if (typeof exports === \"object\") {\n    // Node, CommonJS\n    module.exports = factory(require(\"cldrjs\"), require(\"../globalize\"));\n  } else {\n    // Extend global\n    factory(root.Cldr, root.Globalize);\n  }\n})(this, function (Cldr, Globalize) {\n  var createError = Globalize._createError,\n      createErrorUnsupportedFeature = Globalize._createErrorUnsupportedFeature,\n      formatMessage = Globalize._formatMessage,\n      isPlainObject = Globalize._isPlainObject,\n      looseMatching = Globalize._looseMatching,\n      numberNumberingSystemDigitsMap = Globalize._numberNumberingSystemDigitsMap,\n      numberSymbol = Globalize._numberSymbol,\n      partsJoin = Globalize._partsJoin,\n      partsPush = Globalize._partsPush,\n      regexpEscape = Globalize._regexpEscape,\n      removeLiteralQuotes = Globalize._removeLiteralQuotes,\n      runtimeBind = Globalize._runtimeBind,\n      stringPad = Globalize._stringPad,\n      validate = Globalize._validate,\n      validateCldr = Globalize._validateCldr,\n      validateDefaultLocale = Globalize._validateDefaultLocale,\n      validateParameterPresence = Globalize._validateParameterPresence,\n      validateParameterType = Globalize._validateParameterType,\n      validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject,\n      validateParameterTypeString = Globalize._validateParameterTypeString;\n\n  var validateParameterTypeDate = function (value, name) {\n    validateParameterType(value, name, value === undefined || value instanceof Date, \"Date\");\n  };\n\n  var createErrorInvalidParameterValue = function (name, value) {\n    return createError(\"E_INVALID_PAR_VALUE\", \"Invalid `{name}` value ({value}).\", {\n      name: name,\n      value: value\n    });\n  };\n  /**\n   * Create a map between the skeleton fields and their positions, e.g.,\n   * {\n   *   G: 0\n   *   y: 1\n   *   ...\n   * }\n   */\n\n\n  var validateSkeletonFieldsPosMap = \"GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx\".split(\"\").reduce(function (memo, item, i) {\n    memo[item] = i;\n    return memo;\n  }, {});\n  /**\n   * validateSkeleton( skeleton )\n   *\n   * skeleton: Assume `j` has already been converted into a localized hour field.\n   */\n\n  var validateSkeleton = function validateSkeleton(skeleton) {\n    var last,\n        // Using easier to read variable.\n    fieldsPosMap = validateSkeletonFieldsPosMap; // \"The fields are from the Date Field Symbol Table in Date Format Patterns\"\n    // Ref: http://www.unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n    // I.e., check for invalid characters.\n\n    skeleton.replace(/[^GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx]/, function (field) {\n      throw createError(\"E_INVALID_OPTIONS\", \"Invalid field `{invalidField}` of skeleton `{value}`\", {\n        invalidField: field,\n        type: \"skeleton\",\n        value: skeleton\n      });\n    }); // \"The canonical order is from top to bottom in that table; that is, yM not My\".\n    // http://www.unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n    // I.e., check for invalid order.\n\n    skeleton.split(\"\").every(function (field) {\n      if (fieldsPosMap[field] < last) {\n        throw createError(\"E_INVALID_OPTIONS\", \"Invalid order `{invalidField}` of skeleton `{value}`\", {\n          invalidField: field,\n          type: \"skeleton\",\n          value: skeleton\n        });\n      }\n\n      last = fieldsPosMap[field];\n      return true;\n    });\n  };\n  /**\n   * Returns a new object created by using `object`'s values as keys, and the keys as values.\n   */\n\n\n  var objectInvert = function (object, fn) {\n    fn = fn || function (object, key, value) {\n      object[value] = key;\n      return object;\n    };\n\n    return Object.keys(object).reduce(function (newObject, key) {\n      return fn(newObject, key, object[key]);\n    }, {});\n  }; // Invert key and values, e.g., {\"e\": \"eEc\"} ==> {\"e\": \"e\", \"E\": \"e\", \"c\": \"e\"}.\n\n\n  var dateExpandPatternSimilarFieldsMap = objectInvert({\n    \"e\": \"eEc\",\n    \"L\": \"ML\"\n  }, function (object, key, value) {\n    value.split(\"\").forEach(function (field) {\n      object[field] = key;\n    });\n    return object;\n  });\n\n  var dateExpandPatternNormalizePatternType = function (character) {\n    return dateExpandPatternSimilarFieldsMap[character] || character;\n  };\n\n  var datePatternRe = /([a-z])\\1*|'([^']|'')+'|''|./ig;\n\n  var stringRepeat = function (str, count) {\n    var i,\n        result = \"\";\n\n    for (i = 0; i < count; i++) {\n      result = result + str;\n    }\n\n    return result;\n  };\n\n  function expandBestMatchFormat(skeletonWithoutFractionalSeconds, bestMatchFormat) {\n    var i,\n        j,\n        bestMatchFormatParts,\n        matchedType,\n        matchedLength,\n        requestedType,\n        requestedLength,\n        requestedSkeletonParts,\n        // Using an easier to read variable.\n    normalizePatternType = dateExpandPatternNormalizePatternType;\n    requestedSkeletonParts = skeletonWithoutFractionalSeconds.match(datePatternRe);\n    bestMatchFormatParts = bestMatchFormat.match(datePatternRe);\n\n    for (i = 0; i < bestMatchFormatParts.length; i++) {\n      matchedType = bestMatchFormatParts[i].charAt(0);\n      matchedLength = bestMatchFormatParts[i].length;\n\n      for (j = 0; j < requestedSkeletonParts.length; j++) {\n        requestedType = requestedSkeletonParts[j].charAt(0);\n        requestedLength = requestedSkeletonParts[j].length;\n\n        if (normalizePatternType(matchedType) === normalizePatternType(requestedType) && matchedLength < requestedLength) {\n          bestMatchFormatParts[i] = stringRepeat(matchedType, requestedLength);\n        }\n      }\n    }\n\n    return bestMatchFormatParts.join(\"\");\n  } // See: http://www.unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\n\n\n  var dateExpandPatternAugmentFormat = function (requestedSkeleton, bestMatchFormat, decimalSeparator) {\n    var countOfFractionalSeconds, fractionalSecondMatch, lastSecondIdx, skeletonWithoutFractionalSeconds;\n    fractionalSecondMatch = requestedSkeleton.match(/S/g);\n    countOfFractionalSeconds = fractionalSecondMatch ? fractionalSecondMatch.length : 0;\n    skeletonWithoutFractionalSeconds = requestedSkeleton.replace(/S/g, \"\");\n    bestMatchFormat = expandBestMatchFormat(skeletonWithoutFractionalSeconds, bestMatchFormat);\n    lastSecondIdx = bestMatchFormat.lastIndexOf(\"s\");\n\n    if (lastSecondIdx !== -1 && countOfFractionalSeconds !== 0) {\n      bestMatchFormat = bestMatchFormat.slice(0, lastSecondIdx + 1) + decimalSeparator + stringRepeat(\"S\", countOfFractionalSeconds) + bestMatchFormat.slice(lastSecondIdx + 1);\n    }\n\n    return bestMatchFormat;\n  };\n\n  var dateExpandPatternCompareFormats = function (formatA, formatB) {\n    var a,\n        b,\n        distance,\n        lenA,\n        lenB,\n        typeA,\n        typeB,\n        i,\n        j,\n        // Using easier to read variables.\n    normalizePatternType = dateExpandPatternNormalizePatternType;\n\n    if (formatA === formatB) {\n      return 0;\n    }\n\n    formatA = formatA.match(datePatternRe);\n    formatB = formatB.match(datePatternRe);\n\n    if (formatA.length !== formatB.length) {\n      return -1;\n    }\n\n    distance = 1;\n\n    for (i = 0; i < formatA.length; i++) {\n      a = formatA[i].charAt(0);\n      typeA = normalizePatternType(a);\n      typeB = null;\n\n      for (j = 0; j < formatB.length; j++) {\n        b = formatB[j].charAt(0);\n        typeB = normalizePatternType(b);\n\n        if (typeA === typeB) {\n          break;\n        } else {\n          typeB = null;\n        }\n      }\n\n      if (typeB === null) {\n        return -1;\n      }\n\n      lenA = formatA[i].length;\n      lenB = formatB[j].length;\n      distance = distance + Math.abs(lenA - lenB); // Most symbols have a small distance from each other, e.g., M ≅ L; E ≅ c; a ≅ b ≅ B;\n      // H ≅ k ≅ h ≅ K; ...\n\n      if (a !== b) {\n        distance += 1;\n      } // Numeric (l<3) and text fields (l>=3) are given a larger distance from each other.\n\n\n      if (lenA < 3 && lenB >= 3 || lenA >= 3 && lenB < 3) {\n        distance += 20;\n      }\n    }\n\n    return distance;\n  };\n\n  var dateExpandPatternGetBestMatchPattern = function (cldr, askedSkeleton) {\n    var availableFormats,\n        decimalSeparator,\n        pattern,\n        ratedFormats,\n        skeleton,\n        path = \"dates/calendars/gregorian/dateTimeFormats/availableFormats\",\n        // Using easier to read variables.\n    augmentFormat = dateExpandPatternAugmentFormat,\n        compareFormats = dateExpandPatternCompareFormats;\n    pattern = cldr.main([path, askedSkeleton]);\n\n    if (askedSkeleton && !pattern) {\n      availableFormats = cldr.main([path]);\n      ratedFormats = [];\n\n      for (skeleton in availableFormats) {\n        ratedFormats.push({\n          skeleton: skeleton,\n          pattern: availableFormats[skeleton],\n          rate: compareFormats(askedSkeleton, skeleton)\n        });\n      }\n\n      ratedFormats = ratedFormats.filter(function (format) {\n        return format.rate > -1;\n      }).sort(function (formatA, formatB) {\n        return formatA.rate - formatB.rate;\n      });\n\n      if (ratedFormats.length) {\n        decimalSeparator = numberSymbol(\"decimal\", cldr);\n        pattern = augmentFormat(askedSkeleton, ratedFormats[0].pattern, decimalSeparator);\n      }\n    }\n\n    return pattern;\n  };\n  /**\n   * expandPattern( options, cldr )\n   *\n   * @options [Object] if String, it's considered a skeleton. Object accepts:\n   * - skeleton: [String] lookup availableFormat;\n   * - date: [String] ( \"full\" | \"long\" | \"medium\" | \"short\" );\n   * - time: [String] ( \"full\" | \"long\" | \"medium\" | \"short\" );\n   * - datetime: [String] ( \"full\" | \"long\" | \"medium\" | \"short\" );\n   * - raw: [String] For more info see datetime/format.js.\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return the corresponding pattern.\n   * Eg for \"en\":\n   * - \"GyMMMd\" returns \"MMM d, y G\";\n   * - { skeleton: \"GyMMMd\" } returns \"MMM d, y G\";\n   * - { date: \"full\" } returns \"EEEE, MMMM d, y\";\n   * - { time: \"full\" } returns \"h:mm:ss a zzzz\";\n   * - { datetime: \"full\" } returns \"EEEE, MMMM d, y 'at' h:mm:ss a zzzz\";\n   * - { raw: \"dd/mm\" } returns \"dd/mm\";\n   */\n\n\n  var dateExpandPattern = function (options, cldr) {\n    var dateSkeleton,\n        result,\n        skeleton,\n        timeSkeleton,\n        type,\n        // Using easier to read variables.\n    getBestMatchPattern = dateExpandPatternGetBestMatchPattern;\n\n    function combineDateTime(type, datePattern, timePattern) {\n      return formatMessage(cldr.main([\"dates/calendars/gregorian/dateTimeFormats\", type]), [timePattern, datePattern]);\n    }\n\n    switch (true) {\n      case \"skeleton\" in options:\n        skeleton = options.skeleton; // Preferred hour (j).\n\n        skeleton = skeleton.replace(/j/g, function () {\n          return cldr.supplemental.timeData.preferred();\n        });\n        validateSkeleton(skeleton); // Try direct map (note that getBestMatchPattern handles it).\n        // ... or, try to \"best match\" the whole skeleton.\n\n        result = getBestMatchPattern(cldr, skeleton);\n\n        if (result) {\n          break;\n        } // ... or, try to \"best match\" the date and time parts individually.\n\n\n        timeSkeleton = skeleton.split(/[^hHKkmsSAzZOvVXx]/).slice(-1)[0];\n        dateSkeleton = skeleton.split(/[^GyYuUrQqMLlwWdDFgEec]/)[0];\n        dateSkeleton = getBestMatchPattern(cldr, dateSkeleton);\n        timeSkeleton = getBestMatchPattern(cldr, timeSkeleton);\n\n        if (/(MMMM|LLLL).*[Ec]/.test(dateSkeleton)) {\n          type = \"full\";\n        } else if (/MMMM|LLLL/.test(dateSkeleton)) {\n          type = \"long\";\n        } else if (/MMM|LLL/.test(dateSkeleton)) {\n          type = \"medium\";\n        } else {\n          type = \"short\";\n        }\n\n        if (dateSkeleton && timeSkeleton) {\n          result = combineDateTime(type, dateSkeleton, timeSkeleton);\n        } else {\n          result = dateSkeleton || timeSkeleton;\n        }\n\n        break;\n\n      case \"date\" in options:\n      case \"time\" in options:\n        result = cldr.main([\"dates/calendars/gregorian\", \"date\" in options ? \"dateFormats\" : \"timeFormats\", options.date || options.time]);\n        break;\n\n      case \"datetime\" in options:\n        result = combineDateTime(options.datetime, cldr.main([\"dates/calendars/gregorian/dateFormats\", options.datetime]), cldr.main([\"dates/calendars/gregorian/timeFormats\", options.datetime]));\n        break;\n\n      case \"raw\" in options:\n        result = options.raw;\n        break;\n\n      default:\n        throw createErrorInvalidParameterValue({\n          name: \"options\",\n          value: options\n        });\n    }\n\n    return result;\n  };\n\n  var dateWeekDays = [\"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\"];\n  /**\n   * firstDayOfWeek\n   */\n\n  var dateFirstDayOfWeek = function (cldr) {\n    return dateWeekDays.indexOf(cldr.supplemental.weekData.firstDay());\n  };\n  /**\n   * getTimeZoneName( length, type )\n   */\n\n\n  var dateGetTimeZoneName = function (length, type, timeZone, cldr) {\n    var metaZone, result;\n\n    if (!timeZone) {\n      return;\n    }\n\n    result = cldr.main([\"dates/timeZoneNames/zone\", timeZone, length < 4 ? \"short\" : \"long\", type]);\n\n    if (result) {\n      return result;\n    } // The latest metazone data of the metazone array.\n    // TODO expand to support the historic metazones based on the given date.\n\n\n    metaZone = cldr.supplemental([\"metaZones/metazoneInfo/timezone\", timeZone, 0, \"usesMetazone/_mzone\"]);\n    return cldr.main([\"dates/timeZoneNames/metazone\", metaZone, length < 4 ? \"short\" : \"long\", type]);\n  };\n  /**\n   * timezoneHourFormatShortH( hourFormat )\n   *\n   * @hourFormat [String]\n   *\n   * Unofficial deduction of the short hourFormat given time zone `hourFormat` element.\n   * Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293\n   *\n   * Example:\n   * - \"+HH.mm;-HH.mm\" => \"+H;-H\"\n   * - \"+HH:mm;-HH:mm\" => \"+H;-H\"\n   * - \"+HH:mm;−HH:mm\" => \"+H;−H\" (Note MINUS SIGN \\u2212)\n   * - \"+HHmm;-HHmm\" => \"+H:-H\"\n   */\n\n\n  var dateTimezoneHourFormatH = function (hourFormat) {\n    return hourFormat.split(\";\").map(function (format) {\n      return format.slice(0, format.indexOf(\"H\") + 1);\n    }).join(\";\");\n  };\n  /**\n   * timezoneHourFormatLongHm( hourFormat )\n   *\n   * @hourFormat [String]\n   *\n   * Unofficial deduction of the short hourFormat given time zone `hourFormat` element.\n   * Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293\n   *\n   * Example (hFormat === \"H\"): (used for short Hm)\n   * - \"+HH.mm;-HH.mm\" => \"+H.mm;-H.mm\"\n   * - \"+HH:mm;-HH:mm\" => \"+H:mm;-H:mm\"\n   * - \"+HH:mm;−HH:mm\" => \"+H:mm;−H:mm\" (Note MINUS SIGN \\u2212)\n   * - \"+HHmm;-HHmm\" => \"+Hmm:-Hmm\"\n   *\n   * Example (hFormat === \"HH\": (used for long Hm)\n   * - \"+HH.mm;-HH.mm\" => \"+HH.mm;-HH.mm\"\n   * - \"+HH:mm;-HH:mm\" => \"+HH:mm;-HH:mm\"\n   * - \"+H:mm;-H:mm\"   => \"+HH:mm;-HH:mm\"\n   * - \"+HH:mm;−HH:mm\" => \"+HH:mm;−HH:mm\" (Note MINUS SIGN \\u2212)\n   * - \"+HHmm;-HHmm\" => \"+HHmm:-HHmm\"\n   */\n\n\n  var dateTimezoneHourFormatHm = function (hourFormat, hFormat) {\n    return hourFormat.split(\";\").map(function (format) {\n      var parts = format.split(/H+/);\n      parts.splice(1, 0, hFormat);\n      return parts.join(\"\");\n    }).join(\";\");\n  };\n\n  var runtimeCacheDataBind = function (key, data) {\n    var fn = function () {\n      return data;\n    };\n\n    fn.dataCacheKey = key;\n    return fn;\n  };\n  /**\n   * properties( pattern, cldr )\n   *\n   * @pattern [String] raw pattern.\n   * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return the properties given the pattern and cldr.\n   *\n   * TODO Support other calendar types.\n   */\n\n\n  var dateFormatProperties = function (pattern, cldr, timeZone) {\n    var properties = {\n      numberFormatters: {},\n      pattern: pattern,\n      timeSeparator: numberSymbol(\"timeSeparator\", cldr)\n    },\n        widths = [\"abbreviated\", \"wide\", \"narrow\"];\n\n    function setNumberFormatterPattern(pad) {\n      properties.numberFormatters[pad] = stringPad(\"\", pad);\n    }\n\n    if (timeZone) {\n      properties.timeZoneData = runtimeCacheDataBind(\"iana/\" + timeZone, {\n        offsets: cldr.get([\"globalize-iana/zoneData\", timeZone, \"offsets\"]),\n        untils: cldr.get([\"globalize-iana/zoneData\", timeZone, \"untils\"]),\n        isdsts: cldr.get([\"globalize-iana/zoneData\", timeZone, \"isdsts\"])\n      });\n    }\n\n    pattern.replace(datePatternRe, function (current) {\n      var aux, chr, daylightTzName, formatNumber, genericTzName, length, standardTzName;\n      chr = current.charAt(0);\n      length = current.length;\n\n      if (chr === \"j\") {\n        // Locale preferred hHKk.\n        // http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\n        properties.preferredTime = chr = cldr.supplemental.timeData.preferred();\n      } // ZZZZ: same as \"OOOO\".\n\n\n      if (chr === \"Z\" && length === 4) {\n        chr = \"O\";\n        length = 4;\n      } // z...zzz: \"{shortRegion}\", eg. \"PST\" or \"PDT\".\n      // zzzz: \"{regionName} {Standard Time}\" or \"{regionName} {Daylight Time}\",\n      //       e.g., \"Pacific Standard Time\" or \"Pacific Daylight Time\".\n      // http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\n\n      if (chr === \"z\") {\n        standardTzName = dateGetTimeZoneName(length, \"standard\", timeZone, cldr);\n        daylightTzName = dateGetTimeZoneName(length, \"daylight\", timeZone, cldr);\n\n        if (standardTzName) {\n          properties.standardTzName = standardTzName;\n        }\n\n        if (daylightTzName) {\n          properties.daylightTzName = daylightTzName;\n        } // Fall through the \"O\" format in case one name is missing.\n\n\n        if (!standardTzName || !daylightTzName) {\n          chr = \"O\";\n\n          if (length < 4) {\n            length = 1;\n          }\n        }\n      } // v...vvv: \"{shortRegion}\", eg. \"PT\".\n      // vvvv: \"{regionName} {Time}\" or \"{regionName} {Time}\",\n      // e.g., \"Pacific Time\"\n      // http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\n\n      if (chr === \"v\") {\n        genericTzName = dateGetTimeZoneName(length, \"generic\", timeZone, cldr); // Fall back to \"V\" format.\n\n        if (!genericTzName) {\n          chr = \"V\";\n          length = 4;\n        }\n      }\n\n      switch (chr) {\n        // Era\n        case \"G\":\n          properties.eras = cldr.main([\"dates/calendars/gregorian/eras\", length <= 3 ? \"eraAbbr\" : length === 4 ? \"eraNames\" : \"eraNarrow\"]);\n          break;\n        // Year\n\n        case \"y\":\n          // Plain year.\n          formatNumber = true;\n          break;\n\n        case \"Y\":\n          // Year in \"Week of Year\"\n          properties.firstDay = dateFirstDayOfWeek(cldr);\n          properties.minDays = cldr.supplemental.weekData.minDays();\n          formatNumber = true;\n          break;\n\n        case \"u\": // Extended year. Need to be implemented.\n\n        case \"U\":\n          // Cyclic year name. Need to be implemented.\n          throw createErrorUnsupportedFeature({\n            feature: \"year pattern `\" + chr + \"`\"\n          });\n        // Quarter\n\n        case \"Q\":\n        case \"q\":\n          if (length > 2) {\n            if (!properties.quarters) {\n              properties.quarters = {};\n            }\n\n            if (!properties.quarters[chr]) {\n              properties.quarters[chr] = {};\n            }\n\n            properties.quarters[chr][length] = cldr.main([\"dates/calendars/gregorian/quarters\", chr === \"Q\" ? \"format\" : \"stand-alone\", widths[length - 3]]);\n          } else {\n            formatNumber = true;\n          }\n\n          break;\n        // Month\n\n        case \"M\":\n        case \"L\":\n          if (length > 2) {\n            if (!properties.months) {\n              properties.months = {};\n            }\n\n            if (!properties.months[chr]) {\n              properties.months[chr] = {};\n            }\n\n            properties.months[chr][length] = cldr.main([\"dates/calendars/gregorian/months\", chr === \"M\" ? \"format\" : \"stand-alone\", widths[length - 3]]);\n          } else {\n            formatNumber = true;\n          }\n\n          break;\n        // Week - Week of Year (w) or Week of Month (W).\n\n        case \"w\":\n        case \"W\":\n          properties.firstDay = dateFirstDayOfWeek(cldr);\n          properties.minDays = cldr.supplemental.weekData.minDays();\n          formatNumber = true;\n          break;\n        // Day\n\n        case \"d\":\n        case \"D\":\n        case \"F\":\n          formatNumber = true;\n          break;\n\n        case \"g\":\n          // Modified Julian day. Need to be implemented.\n          throw createErrorUnsupportedFeature({\n            feature: \"Julian day pattern `g`\"\n          });\n        // Week day\n\n        case \"e\":\n        case \"c\":\n          if (length <= 2) {\n            properties.firstDay = dateFirstDayOfWeek(cldr);\n            formatNumber = true;\n            break;\n          }\n\n        /* falls through */\n\n        case \"E\":\n          if (!properties.days) {\n            properties.days = {};\n          }\n\n          if (!properties.days[chr]) {\n            properties.days[chr] = {};\n          }\n\n          if (length === 6) {\n            // If short day names are not explicitly specified, abbreviated day names are\n            // used instead.\n            // http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras\n            // http://unicode.org/cldr/trac/ticket/6790\n            properties.days[chr][length] = cldr.main([\"dates/calendars/gregorian/days\", chr === \"c\" ? \"stand-alone\" : \"format\", \"short\"]) || cldr.main([\"dates/calendars/gregorian/days\", chr === \"c\" ? \"stand-alone\" : \"format\", \"abbreviated\"]);\n          } else {\n            properties.days[chr][length] = cldr.main([\"dates/calendars/gregorian/days\", chr === \"c\" ? \"stand-alone\" : \"format\", widths[length < 3 ? 0 : length - 3]]);\n          }\n\n          break;\n        // Period (AM or PM)\n\n        case \"a\":\n          properties.dayPeriods = {\n            am: cldr.main(\"dates/calendars/gregorian/dayPeriods/format/wide/am\"),\n            pm: cldr.main(\"dates/calendars/gregorian/dayPeriods/format/wide/pm\")\n          };\n          break;\n        // Hour\n\n        case \"h\": // 1-12\n\n        case \"H\": // 0-23\n\n        case \"K\": // 0-11\n\n        case \"k\": // 1-24\n        // Minute\n\n        case \"m\": // Second\n\n        case \"s\":\n        case \"S\":\n        case \"A\":\n          formatNumber = true;\n          break;\n        // Zone\n\n        case \"v\":\n          if (length !== 1 && length !== 4) {\n            throw createErrorUnsupportedFeature({\n              feature: \"timezone pattern `\" + pattern + \"`\"\n            });\n          }\n\n          properties.genericTzName = genericTzName;\n          break;\n\n        case \"V\":\n          if (length === 1) {\n            throw createErrorUnsupportedFeature({\n              feature: \"timezone pattern `\" + pattern + \"`\"\n            });\n          }\n\n          if (timeZone) {\n            if (length === 2) {\n              properties.timeZoneName = timeZone;\n              break;\n            }\n\n            var timeZoneName,\n                exemplarCity = cldr.main([\"dates/timeZoneNames/zone\", timeZone, \"exemplarCity\"]);\n\n            if (length === 3) {\n              if (!exemplarCity) {\n                exemplarCity = cldr.main([\"dates/timeZoneNames/zone/Etc/Unknown/exemplarCity\"]);\n              }\n\n              timeZoneName = exemplarCity;\n            }\n\n            if (exemplarCity && length === 4) {\n              timeZoneName = formatMessage(cldr.main(\"dates/timeZoneNames/regionFormat\"), [exemplarCity]);\n            }\n\n            if (timeZoneName) {\n              properties.timeZoneName = timeZoneName;\n              break;\n            }\n          }\n\n          if (current === \"v\") {\n            length = 1;\n          }\n\n        /* falls through */\n\n        case \"O\":\n          // O: \"{gmtFormat}+H;{gmtFormat}-H\" or \"{gmtZeroFormat}\", eg. \"GMT-8\" or \"GMT\".\n          // OOOO: \"{gmtFormat}{hourFormat}\" or \"{gmtZeroFormat}\", eg. \"GMT-08:00\" or \"GMT\".\n          properties.gmtFormat = cldr.main(\"dates/timeZoneNames/gmtFormat\");\n          properties.gmtZeroFormat = cldr.main(\"dates/timeZoneNames/gmtZeroFormat\"); // Unofficial deduction of the hourFormat variations.\n          // Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293\n\n          aux = cldr.main(\"dates/timeZoneNames/hourFormat\");\n          properties.hourFormat = length < 4 ? [dateTimezoneHourFormatH(aux), dateTimezoneHourFormatHm(aux, \"H\")] : dateTimezoneHourFormatHm(aux, \"HH\");\n\n        /* falls through */\n\n        case \"Z\":\n        case \"X\":\n        case \"x\":\n          setNumberFormatterPattern(1);\n          setNumberFormatterPattern(2);\n          break;\n      }\n\n      if (formatNumber) {\n        setNumberFormatterPattern(length);\n      }\n    });\n    return properties;\n  };\n\n  var dateFormatterFn = function (dateToPartsFormatter) {\n    return function dateFormatter(value) {\n      return partsJoin(dateToPartsFormatter(value));\n    };\n  };\n  /**\n   * parseProperties( cldr )\n   *\n   * @cldr [Cldr instance].\n   *\n   * @timeZone [String] FIXME.\n   *\n   * Return parser properties.\n   */\n\n\n  var dateParseProperties = function (cldr, timeZone) {\n    var properties = {\n      preferredTimeData: cldr.supplemental.timeData.preferred()\n    };\n\n    if (timeZone) {\n      properties.timeZoneData = runtimeCacheDataBind(\"iana/\" + timeZone, {\n        offsets: cldr.get([\"globalize-iana/zoneData\", timeZone, \"offsets\"]),\n        untils: cldr.get([\"globalize-iana/zoneData\", timeZone, \"untils\"]),\n        isdsts: cldr.get([\"globalize-iana/zoneData\", timeZone, \"isdsts\"])\n      });\n    }\n\n    return properties;\n  };\n\n  var ZonedDateTime = function () {\n    function definePrivateProperty(object, property, value) {\n      Object.defineProperty(object, property, {\n        value: value\n      });\n    }\n\n    function getUntilsIndex(original, untils) {\n      var index = 0;\n      var originalTime = original.getTime(); // TODO Should we do binary search for improved performance?\n\n      while (index < untils.length - 1 && originalTime >= untils[index]) {\n        index++;\n      }\n\n      return index;\n    }\n\n    function setWrap(fn) {\n      var offset1 = this.getTimezoneOffset();\n      var ret = fn();\n      this.original.setTime(new Date(this.getTime()));\n      var offset2 = this.getTimezoneOffset();\n\n      if (offset2 - offset1) {\n        this.original.setMinutes(this.original.getMinutes() + offset2 - offset1);\n      }\n\n      return ret;\n    }\n\n    var ZonedDateTime = function (date, timeZoneData) {\n      definePrivateProperty(this, \"original\", new Date(date.getTime()));\n      definePrivateProperty(this, \"local\", new Date(date.getTime()));\n      definePrivateProperty(this, \"timeZoneData\", timeZoneData);\n      definePrivateProperty(this, \"setWrap\", setWrap);\n\n      if (!(timeZoneData.untils && timeZoneData.offsets && timeZoneData.isdsts)) {\n        throw new Error(\"Invalid IANA data\");\n      }\n\n      this.setTime(this.local.getTime() - this.getTimezoneOffset() * 60 * 1000);\n    };\n\n    ZonedDateTime.prototype.clone = function () {\n      return new ZonedDateTime(this.original, this.timeZoneData);\n    }; // Date field getters.\n\n\n    [\"getFullYear\", \"getMonth\", \"getDate\", \"getDay\", \"getHours\", \"getMinutes\", \"getSeconds\", \"getMilliseconds\"].forEach(function (method) {\n      // Corresponding UTC method, e.g., \"getUTCFullYear\" if method === \"getFullYear\".\n      var utcMethod = \"getUTC\" + method.substr(3);\n\n      ZonedDateTime.prototype[method] = function () {\n        return this.local[utcMethod]();\n      };\n    }); // Note: Define .valueOf = .getTime for arithmetic operations like date1 - date2.\n\n    ZonedDateTime.prototype.valueOf = ZonedDateTime.prototype.getTime = function () {\n      return this.local.getTime() + this.getTimezoneOffset() * 60 * 1000;\n    };\n\n    ZonedDateTime.prototype.getTimezoneOffset = function () {\n      var index = getUntilsIndex(this.original, this.timeZoneData.untils);\n      return this.timeZoneData.offsets[index];\n    }; // Date field setters.\n\n\n    [\"setFullYear\", \"setMonth\", \"setDate\", \"setHours\", \"setMinutes\", \"setSeconds\", \"setMilliseconds\"].forEach(function (method) {\n      // Corresponding UTC method, e.g., \"setUTCFullYear\" if method === \"setFullYear\".\n      var utcMethod = \"setUTC\" + method.substr(3);\n\n      ZonedDateTime.prototype[method] = function (value) {\n        var local = this.local; // Note setWrap is needed for seconds and milliseconds just because\n        // abs(value) could be >= a minute.\n\n        return this.setWrap(function () {\n          return local[utcMethod](value);\n        });\n      };\n    });\n\n    ZonedDateTime.prototype.setTime = function (time) {\n      return this.local.setTime(time);\n    };\n\n    ZonedDateTime.prototype.isDST = function () {\n      var index = getUntilsIndex(this.original, this.timeZoneData.untils);\n      return Boolean(this.timeZoneData.isdsts[index]);\n    };\n\n    ZonedDateTime.prototype.inspect = function () {\n      var index = getUntilsIndex(this.original, this.timeZoneData.untils);\n      var abbrs = this.timeZoneData.abbrs;\n      return this.local.toISOString().replace(/Z$/, \"\") + \" \" + (abbrs && abbrs[index] + \" \" || this.getTimezoneOffset() * -1 + \" \") + (this.isDST() ? \"(daylight savings)\" : \"\");\n    };\n\n    ZonedDateTime.prototype.toDate = function () {\n      return new Date(this.getTime());\n    }; // Type cast getters.\n\n\n    [\"toISOString\", \"toJSON\", \"toUTCString\"].forEach(function (method) {\n      ZonedDateTime.prototype[method] = function () {\n        return this.toDate()[method]();\n      };\n    });\n    return ZonedDateTime;\n  }();\n  /**\n   * isLeapYear( year )\n   *\n   * @year [Number]\n   *\n   * Returns an indication whether the specified year is a leap year.\n   */\n\n\n  var dateIsLeapYear = function (year) {\n    return new Date(year, 1, 29).getMonth() === 1;\n  };\n  /**\n   * lastDayOfMonth( date )\n   *\n   * @date [Date]\n   *\n   * Return the last day of the given date's month\n   */\n\n\n  var dateLastDayOfMonth = function (date) {\n    return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n  };\n  /**\n   * startOf changes the input to the beginning of the given unit.\n   *\n   * For example, starting at the start of a day, resets hours, minutes\n   * seconds and milliseconds to 0. Starting at the month does the same, but\n   * also sets the date to 1.\n   *\n   * Returns the modified date\n   */\n\n\n  var dateStartOf = function (date, unit) {\n    date = date instanceof ZonedDateTime ? date.clone() : new Date(date.getTime());\n\n    switch (unit) {\n      case \"year\":\n        date.setMonth(0);\n\n      /* falls through */\n\n      case \"month\":\n        date.setDate(1);\n\n      /* falls through */\n\n      case \"day\":\n        date.setHours(0);\n\n      /* falls through */\n\n      case \"hour\":\n        date.setMinutes(0);\n\n      /* falls through */\n\n      case \"minute\":\n        date.setSeconds(0);\n\n      /* falls through */\n\n      case \"second\":\n        date.setMilliseconds(0);\n    }\n\n    return date;\n  };\n  /**\n   * Differently from native date.setDate(), this function returns a date whose\n   * day remains inside the month boundaries. For example:\n   *\n   * setDate( FebDate, 31 ): a \"Feb 28\" date.\n   * setDate( SepDate, 31 ): a \"Sep 30\" date.\n   */\n\n\n  var dateSetDate = function (date, day) {\n    var lastDay = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n    date.setDate(day < 1 ? 1 : day < lastDay ? day : lastDay);\n  };\n  /**\n   * Differently from native date.setMonth(), this function adjusts date if\n   * needed, so final month is always the one set.\n   *\n   * setMonth( Jan31Date, 1 ): a \"Feb 28\" date.\n   * setDate( Jan31Date, 8 ): a \"Sep 30\" date.\n   */\n\n\n  var dateSetMonth = function (date, month) {\n    var originalDate = date.getDate();\n    date.setDate(1);\n    date.setMonth(month);\n    dateSetDate(date, originalDate);\n  };\n\n  var outOfRange = function (value, low, high) {\n    return value < low || value > high;\n  };\n  /**\n   * parse( value, tokens, properties )\n   *\n   * @value [String] string date.\n   *\n   * @tokens [Object] tokens returned by date/tokenizer.\n   *\n   * @properties [Object] output returned by date/tokenizer-properties.\n   *\n   * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n   */\n\n\n  var dateParse = function (_value, tokens, properties) {\n    var amPm,\n        day,\n        daysOfYear,\n        month,\n        era,\n        hour,\n        hour12,\n        timezoneOffset,\n        valid,\n        YEAR = 0,\n        MONTH = 1,\n        DAY = 2,\n        HOUR = 3,\n        MINUTE = 4,\n        SECOND = 5,\n        MILLISECONDS = 6,\n        date = new Date(),\n        truncateAt = [],\n        units = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"milliseconds\"]; // Create globalize date with given timezone data.\n\n    if (properties.timeZoneData) {\n      date = new ZonedDateTime(date, properties.timeZoneData());\n    }\n\n    if (!tokens.length) {\n      return null;\n    }\n\n    valid = tokens.every(function (token) {\n      var century, chr, value, length;\n\n      if (token.type === \"literal\") {\n        // continue\n        return true;\n      }\n\n      chr = token.type.charAt(0);\n      length = token.type.length;\n\n      if (chr === \"j\") {\n        // Locale preferred hHKk.\n        // http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\n        chr = properties.preferredTimeData;\n      }\n\n      switch (chr) {\n        // Era\n        case \"G\":\n          truncateAt.push(YEAR);\n          era = +token.value;\n          break;\n        // Year\n\n        case \"y\":\n          value = token.value;\n\n          if (length === 2) {\n            if (outOfRange(value, 0, 99)) {\n              return false;\n            } // mimic dojo/date/locale: choose century to apply, according to a sliding\n            // window of 80 years before and 20 years after present year.\n\n\n            century = Math.floor(date.getFullYear() / 100) * 100;\n            value += century;\n\n            if (value > date.getFullYear() + 20) {\n              value -= 100;\n            }\n          }\n\n          date.setFullYear(value);\n          truncateAt.push(YEAR);\n          break;\n\n        case \"Y\":\n          // Year in \"Week of Year\"\n          throw createErrorUnsupportedFeature({\n            feature: \"year pattern `\" + chr + \"`\"\n          });\n        // Quarter (skip)\n\n        case \"Q\":\n        case \"q\":\n          break;\n        // Month\n\n        case \"M\":\n        case \"L\":\n          if (length <= 2) {\n            value = token.value;\n          } else {\n            value = +token.value;\n          }\n\n          if (outOfRange(value, 1, 12)) {\n            return false;\n          } // Setting the month later so that we have the correct year and can determine\n          // the correct last day of February in case of leap year.\n\n\n          month = value;\n          truncateAt.push(MONTH);\n          break;\n        // Week (skip)\n\n        case \"w\": // Week of Year.\n\n        case \"W\":\n          // Week of Month.\n          break;\n        // Day\n\n        case \"d\":\n          day = token.value;\n          truncateAt.push(DAY);\n          break;\n\n        case \"D\":\n          daysOfYear = token.value;\n          truncateAt.push(DAY);\n          break;\n\n        case \"F\":\n          // Day of Week in month. eg. 2nd Wed in July.\n          // Skip\n          break;\n        // Week day\n\n        case \"e\":\n        case \"c\":\n        case \"E\":\n          // Skip.\n          // value = arrayIndexOf( dateWeekDays, token.value );\n          break;\n        // Period (AM or PM)\n\n        case \"a\":\n          amPm = token.value;\n          break;\n        // Hour\n\n        case \"h\":\n          // 1-12\n          value = token.value;\n\n          if (outOfRange(value, 1, 12)) {\n            return false;\n          }\n\n          hour = hour12 = true;\n          date.setHours(value === 12 ? 0 : value);\n          truncateAt.push(HOUR);\n          break;\n\n        case \"K\":\n          // 0-11\n          value = token.value;\n\n          if (outOfRange(value, 0, 11)) {\n            return false;\n          }\n\n          hour = hour12 = true;\n          date.setHours(value);\n          truncateAt.push(HOUR);\n          break;\n\n        case \"k\":\n          // 1-24\n          value = token.value;\n\n          if (outOfRange(value, 1, 24)) {\n            return false;\n          }\n\n          hour = true;\n          date.setHours(value === 24 ? 0 : value);\n          truncateAt.push(HOUR);\n          break;\n\n        case \"H\":\n          // 0-23\n          value = token.value;\n\n          if (outOfRange(value, 0, 23)) {\n            return false;\n          }\n\n          hour = true;\n          date.setHours(value);\n          truncateAt.push(HOUR);\n          break;\n        // Minute\n\n        case \"m\":\n          value = token.value;\n\n          if (outOfRange(value, 0, 59)) {\n            return false;\n          }\n\n          date.setMinutes(value);\n          truncateAt.push(MINUTE);\n          break;\n        // Second\n\n        case \"s\":\n          value = token.value;\n\n          if (outOfRange(value, 0, 59)) {\n            return false;\n          }\n\n          date.setSeconds(value);\n          truncateAt.push(SECOND);\n          break;\n\n        case \"A\":\n          date.setHours(0);\n          date.setMinutes(0);\n          date.setSeconds(0);\n\n        /* falls through */\n\n        case \"S\":\n          value = Math.round(token.value * Math.pow(10, 3 - length));\n          date.setMilliseconds(value);\n          truncateAt.push(MILLISECONDS);\n          break;\n        // Zone\n\n        case \"z\":\n        case \"Z\":\n        case \"O\":\n        case \"v\":\n        case \"V\":\n        case \"X\":\n        case \"x\":\n          if (typeof token.value === \"number\") {\n            timezoneOffset = token.value;\n          }\n\n          break;\n      }\n\n      return true;\n    });\n\n    if (!valid) {\n      return null;\n    } // 12-hour format needs AM or PM, 24-hour format doesn't, ie. return null\n    // if amPm && !hour12 || !amPm && hour12.\n\n\n    if (hour && !(!amPm ^ hour12)) {\n      return null;\n    }\n\n    if (era === 0) {\n      // 1 BC = year 0\n      date.setFullYear(date.getFullYear() * -1 + 1);\n    }\n\n    if (month !== undefined) {\n      dateSetMonth(date, month - 1);\n    }\n\n    if (day !== undefined) {\n      if (outOfRange(day, 1, dateLastDayOfMonth(date))) {\n        return null;\n      }\n\n      date.setDate(day);\n    } else if (daysOfYear !== undefined) {\n      if (outOfRange(daysOfYear, 1, dateIsLeapYear(date.getFullYear()) ? 366 : 365)) {\n        return null;\n      }\n\n      date.setMonth(0);\n      date.setDate(daysOfYear);\n    }\n\n    if (hour12 && amPm === \"pm\") {\n      date.setHours(date.getHours() + 12);\n    }\n\n    if (timezoneOffset !== undefined) {\n      date.setMinutes(date.getMinutes() + timezoneOffset - date.getTimezoneOffset());\n    } // Truncate date at the most precise unit defined. Eg.\n    // If value is \"12/31\", and pattern is \"MM/dd\":\n    // => new Date( <current Year>, 12, 31, 0, 0, 0, 0 );\n\n\n    truncateAt = Math.max.apply(null, truncateAt);\n    date = dateStartOf(date, units[truncateAt]); // Get date back from globalize date.\n\n    if (date instanceof ZonedDateTime) {\n      date = date.toDate();\n    }\n\n    return date;\n  };\n  /* eslint-disable no-unused-expressions */\n\n  /**\n   * tokenizer( value, numberParser, properties )\n   *\n   * @value [String] string date.\n   *\n   * @numberParser [Function]\n   *\n   * @properties [Object] output returned by date/tokenizer-properties.\n   *\n   * Returns an Array of tokens, eg. value \"5 o'clock PM\", pattern \"h 'o''clock' a\":\n   * [{\n   *   type: \"h\",\n   *   lexeme: \"5\"\n   * }, {\n   *   type: \"literal\",\n   *   lexeme: \" \"\n   * }, {\n   *   type: \"literal\",\n   *   lexeme: \"o'clock\"\n   * }, {\n   *   type: \"literal\",\n   *   lexeme: \" \"\n   * }, {\n   *   type: \"a\",\n   *   lexeme: \"PM\",\n   *   value: \"pm\"\n   * }]\n   *\n   * OBS: lexeme's are always String and may return invalid ranges depending of the token type.\n   * Eg. \"99\" for month number.\n   *\n   * Return an empty Array when not successfully parsed.\n   */\n\n\n  var dateTokenizer = function (value, numberParser, properties) {\n    var digitsRe,\n        valid,\n        tokens = [],\n        widths = [\"abbreviated\", \"wide\", \"narrow\"];\n    digitsRe = properties.digitsRe;\n    value = looseMatching(value);\n    valid = properties.pattern.match(datePatternRe).every(function (current) {\n      var aux,\n          chr,\n          length,\n          numeric,\n          tokenRe,\n          token = {};\n\n      function hourFormatParse(tokenRe, numberParser) {\n        var aux,\n            isPositive,\n            match = value.match(tokenRe);\n\n        numberParser = numberParser || function (value) {\n          return +value;\n        };\n\n        if (!match) {\n          return false;\n        }\n\n        isPositive = match[1]; // hourFormat containing H only, e.g., `+H;-H`\n\n        if (match.length < 6) {\n          aux = isPositive ? 1 : 3;\n          token.value = numberParser(match[aux]) * 60; // hourFormat containing H and m, e.g., `+HHmm;-HHmm`\n        } else if (match.length < 10) {\n          aux = isPositive ? [1, 3] : [5, 7];\n          token.value = numberParser(match[aux[0]]) * 60 + numberParser(match[aux[1]]); // hourFormat containing H, m, and s e.g., `+HHmmss;-HHmmss`\n        } else {\n          aux = isPositive ? [1, 3, 5] : [7, 9, 11];\n          token.value = numberParser(match[aux[0]]) * 60 + numberParser(match[aux[1]]) + numberParser(match[aux[2]]) / 60;\n        }\n\n        if (isPositive) {\n          token.value *= -1;\n        }\n\n        return true;\n      }\n\n      function oneDigitIfLengthOne() {\n        if (length === 1) {\n          // Unicode equivalent to /\\d/\n          numeric = true;\n          return tokenRe = digitsRe;\n        }\n      }\n\n      function oneOrTwoDigitsIfLengthOne() {\n        if (length === 1) {\n          // Unicode equivalent to /\\d\\d?/\n          numeric = true;\n          return tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){1,2}\");\n        }\n      }\n\n      function oneOrTwoDigitsIfLengthOneOrTwo() {\n        if (length === 1 || length === 2) {\n          // Unicode equivalent to /\\d\\d?/\n          numeric = true;\n          return tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){1,2}\");\n        }\n      }\n\n      function twoDigitsIfLengthTwo() {\n        if (length === 2) {\n          // Unicode equivalent to /\\d\\d/\n          numeric = true;\n          return tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){2}\");\n        }\n      } // Brute-force test every locale entry in an attempt to match the given value.\n      // Return the first found one (and set token accordingly), or null.\n\n\n      function lookup(path) {\n        var array = properties[path.join(\"/\")];\n\n        if (!array) {\n          return null;\n        } // array of pairs [key, value] sorted by desc value length.\n\n\n        array.some(function (item) {\n          var valueRe = item[1];\n\n          if (valueRe.test(value)) {\n            token.value = item[0];\n            tokenRe = item[1];\n            return true;\n          }\n        });\n        return null;\n      }\n\n      token.type = current;\n      chr = current.charAt(0);\n      length = current.length;\n\n      if (chr === \"Z\") {\n        // Z..ZZZ: same as \"xxxx\".\n        if (length < 4) {\n          chr = \"x\";\n          length = 4; // ZZZZ: same as \"OOOO\".\n        } else if (length < 5) {\n          chr = \"O\";\n          length = 4; // ZZZZZ: same as \"XXXXX\"\n        } else {\n          chr = \"X\";\n          length = 5;\n        }\n      }\n\n      if (chr === \"z\") {\n        if (properties.standardOrDaylightTzName) {\n          token.value = null;\n          tokenRe = properties.standardOrDaylightTzName;\n        }\n      } // v...vvv: \"{shortRegion}\", eg. \"PT\".\n      // vvvv: \"{regionName} {Time}\" or \"{regionName} {Time}\",\n      // e.g., \"Pacific Time\"\n      // http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\n\n      if (chr === \"v\") {\n        if (properties.genericTzName) {\n          token.value = null;\n          tokenRe = properties.genericTzName; // Fall back to \"V\" format.\n        } else {\n          chr = \"V\";\n          length = 4;\n        }\n      }\n\n      if (chr === \"V\" && properties.timeZoneName) {\n        token.value = length === 2 ? properties.timeZoneName : null;\n        tokenRe = properties.timeZoneNameRe;\n      }\n\n      switch (chr) {\n        // Era\n        case \"G\":\n          lookup([\"gregorian/eras\", length <= 3 ? \"eraAbbr\" : length === 4 ? \"eraNames\" : \"eraNarrow\"]);\n          break;\n        // Year\n\n        case \"y\":\n        case \"Y\":\n          numeric = true; // number l=1:+, l=2:{2}, l=3:{3,}, l=4:{4,}, ...\n\n          if (length === 1) {\n            // Unicode equivalent to /\\d+/.\n            tokenRe = new RegExp(\"^(\" + digitsRe.source + \")+\");\n          } else if (length === 2) {\n            // Lenient parsing: there's no year pattern to indicate non-zero-padded 2-digits\n            // year, so parser accepts both zero-padded and non-zero-padded for `yy`.\n            //\n            // Unicode equivalent to /\\d\\d?/\n            tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){1,2}\");\n          } else {\n            // Unicode equivalent to /\\d{length,}/\n            tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){\" + length + \",}\");\n          }\n\n          break;\n        // Quarter\n\n        case \"Q\":\n        case \"q\":\n          // number l=1:{1}, l=2:{2}.\n          // lookup l=3...\n          oneDigitIfLengthOne() || twoDigitsIfLengthTwo() || lookup([\"gregorian/quarters\", chr === \"Q\" ? \"format\" : \"stand-alone\", widths[length - 3]]);\n          break;\n        // Month\n\n        case \"M\":\n        case \"L\":\n          // number l=1:{1,2}, l=2:{2}.\n          // lookup l=3...\n          //\n          // Lenient parsing: skeleton \"yMd\" (i.e., one M) may include MM for the pattern,\n          // therefore parser accepts both zero-padded and non-zero-padded for M and MM.\n          // Similar for L.\n          oneOrTwoDigitsIfLengthOneOrTwo() || lookup([\"gregorian/months\", chr === \"M\" ? \"format\" : \"stand-alone\", widths[length - 3]]);\n          break;\n        // Day\n\n        case \"D\":\n          // number {l,3}.\n          if (length <= 3) {\n            // Equivalent to /\\d{length,3}/\n            numeric = true;\n            tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){\" + length + \",3}\");\n          }\n\n          break;\n\n        case \"W\":\n        case \"F\":\n          // number l=1:{1}.\n          oneDigitIfLengthOne();\n          break;\n        // Week day\n\n        case \"e\":\n        case \"c\":\n          // number l=1:{1}, l=2:{2}.\n          // lookup for length >=3.\n          if (length <= 2) {\n            oneDigitIfLengthOne() || twoDigitsIfLengthTwo();\n            break;\n          }\n\n        /* falls through */\n\n        case \"E\":\n          if (length === 6) {\n            // Note: if short day names are not explicitly specified, abbreviated day\n            // names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras\n            lookup([\"gregorian/days\", [chr === \"c\" ? \"stand-alone\" : \"format\"], \"short\"]) || lookup([\"gregorian/days\", [chr === \"c\" ? \"stand-alone\" : \"format\"], \"abbreviated\"]);\n          } else {\n            lookup([\"gregorian/days\", [chr === \"c\" ? \"stand-alone\" : \"format\"], widths[length < 3 ? 0 : length - 3]]);\n          }\n\n          break;\n        // Period (AM or PM)\n\n        case \"a\":\n          lookup([\"gregorian/dayPeriods/format/wide\"]);\n          break;\n        // Week\n\n        case \"w\":\n          // number l1:{1,2}, l2:{2}.\n          oneOrTwoDigitsIfLengthOne() || twoDigitsIfLengthTwo();\n          break;\n        // Day, Hour, Minute, or Second\n\n        case \"d\":\n        case \"h\":\n        case \"H\":\n        case \"K\":\n        case \"k\":\n        case \"j\":\n        case \"m\":\n        case \"s\":\n          // number l1:{1,2}, l2:{2}.\n          //\n          // Lenient parsing:\n          // - skeleton \"hms\" (i.e., one m) always includes mm for the pattern, i.e., it's\n          //   impossible to use a different skeleton to parse non-zero-padded minutes,\n          //   therefore parser accepts both zero-padded and non-zero-padded for m. Similar\n          //   for seconds s.\n          // - skeleton \"hms\" (i.e., one h) may include h or hh for the pattern, i.e., it's\n          //   impossible to use a different skeleton to parser non-zero-padded hours for some\n          //   locales, therefore parser accepts both zero-padded and non-zero-padded for h.\n          //   Similar for d (in skeleton yMd).\n          oneOrTwoDigitsIfLengthOneOrTwo();\n          break;\n\n        case \"S\":\n          // number {l}.\n          // Unicode equivalent to /\\d{length}/\n          numeric = true;\n          tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){\" + length + \"}\");\n          break;\n\n        case \"A\":\n          // number {l+5}.\n          // Unicode equivalent to /\\d{length+5}/\n          numeric = true;\n          tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){\" + (length + 5) + \"}\");\n          break;\n        // Zone\n\n        case \"v\":\n        case \"V\":\n        case \"z\":\n          if (tokenRe && tokenRe.test(value)) {\n            break;\n          }\n\n          if (chr === \"V\" && length === 2) {\n            break;\n          }\n\n        /* falls through */\n\n        case \"O\":\n          // O: \"{gmtFormat}+H;{gmtFormat}-H\" or \"{gmtZeroFormat}\", eg. \"GMT-8\" or \"GMT\".\n          // OOOO: \"{gmtFormat}{hourFormat}\" or \"{gmtZeroFormat}\", eg. \"GMT-08:00\" or \"GMT\".\n          if (value === properties[\"timeZoneNames/gmtZeroFormat\"]) {\n            token.value = 0;\n            tokenRe = properties[\"timeZoneNames/gmtZeroFormatRe\"];\n          } else {\n            aux = properties[\"timeZoneNames/hourFormat\"].some(function (hourFormatRe) {\n              if (hourFormatParse(hourFormatRe, numberParser)) {\n                tokenRe = hourFormatRe;\n                return true;\n              }\n            });\n\n            if (!aux) {\n              return null;\n            }\n          }\n\n          break;\n\n        case \"X\":\n          // Same as x*, except it uses \"Z\" for zero offset.\n          if (value === \"Z\") {\n            token.value = 0;\n            tokenRe = /^Z/;\n            break;\n          }\n\n        /* falls through */\n\n        case \"x\":\n          // x: hourFormat(\"+HH[mm];-HH[mm]\")\n          // xx: hourFormat(\"+HHmm;-HHmm\")\n          // xxx: hourFormat(\"+HH:mm;-HH:mm\")\n          // xxxx: hourFormat(\"+HHmm[ss];-HHmm[ss]\")\n          // xxxxx: hourFormat(\"+HH:mm[:ss];-HH:mm[:ss]\")\n          aux = properties.x.some(function (hourFormatRe) {\n            if (hourFormatParse(hourFormatRe)) {\n              tokenRe = hourFormatRe;\n              return true;\n            }\n          });\n\n          if (!aux) {\n            return null;\n          }\n\n          break;\n\n        case \"'\":\n          token.type = \"literal\";\n          tokenRe = new RegExp(\"^\" + regexpEscape(removeLiteralQuotes(current)));\n          break;\n\n        default:\n          token.type = \"literal\";\n          tokenRe = new RegExp(\"^\" + regexpEscape(current));\n      }\n\n      if (!tokenRe) {\n        return false;\n      } // Get lexeme and consume it.\n\n\n      value = value.replace(tokenRe, function (lexeme) {\n        token.lexeme = lexeme;\n\n        if (numeric) {\n          token.value = numberParser(lexeme);\n        }\n\n        return \"\";\n      });\n\n      if (!token.lexeme) {\n        return false;\n      }\n\n      if (numeric && isNaN(token.value)) {\n        return false;\n      }\n\n      tokens.push(token);\n      return true;\n    });\n\n    if (value !== \"\") {\n      valid = false;\n    }\n\n    return valid ? tokens : [];\n  };\n\n  var dateParserFn = function (numberParser, parseProperties, tokenizerProperties) {\n    return function dateParser(value) {\n      var tokens;\n      validateParameterPresence(value, \"value\");\n      validateParameterTypeString(value, \"value\");\n      tokens = dateTokenizer(value, numberParser, tokenizerProperties);\n      return dateParse(value, tokens, parseProperties) || null;\n    };\n  };\n\n  var objectFilter = function (object, testRe) {\n    var key,\n        copy = {};\n\n    for (key in object) {\n      if (testRe.test(key)) {\n        copy[key] = object[key];\n      }\n    }\n\n    return copy;\n  };\n  /**\n   * tokenizerProperties( pattern, cldr )\n   *\n   * @pattern [String] raw pattern.\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return Object with data that will be used by tokenizer.\n   */\n\n\n  var dateTokenizerProperties = function (pattern, cldr, timeZone) {\n    var digitsReSource,\n        properties = {\n      pattern: looseMatching(pattern)\n    },\n        timeSeparator = numberSymbol(\"timeSeparator\", cldr),\n        widths = [\"abbreviated\", \"wide\", \"narrow\"];\n    digitsReSource = numberNumberingSystemDigitsMap(cldr);\n    digitsReSource = digitsReSource ? \"[\" + digitsReSource + \"]\" : \"\\\\d\";\n    properties.digitsRe = new RegExp(digitsReSource); // Transform:\n    // - \"+H;-H\" -> /\\+(\\d\\d?)|-(\\d\\d?)/\n    // - \"+HH;-HH\" -> /\\+(\\d\\d)|-(\\d\\d)/\n    // - \"+HHmm;-HHmm\" -> /\\+(\\d\\d)(\\d\\d)|-(\\d\\d)(\\d\\d)/\n    // - \"+HH:mm;-HH:mm\" -> /\\+(\\d\\d):(\\d\\d)|-(\\d\\d):(\\d\\d)/\n    //\n    // If gmtFormat is GMT{0}, the regexp must fill {0} in each side, e.g.:\n    // - \"+H;-H\" -> /GMT\\+(\\d\\d?)|GMT-(\\d\\d?)/\n\n    function hourFormatRe(hourFormat, gmtFormat, digitsReSource, timeSeparator) {\n      var re;\n\n      if (!digitsReSource) {\n        digitsReSource = \"\\\\d\";\n      }\n\n      if (!gmtFormat) {\n        gmtFormat = \"{0}\";\n      }\n\n      re = hourFormat.replace(\"+\", \"\\\\+\") // Unicode equivalent to (\\\\d\\\\d)\n      .replace(/HH|mm|ss/g, \"((\" + digitsReSource + \"){2})\") // Unicode equivalent to (\\\\d\\\\d?)\n      .replace(/H|m/g, \"((\" + digitsReSource + \"){1,2})\");\n\n      if (timeSeparator) {\n        re = re.replace(/:/g, timeSeparator);\n      }\n\n      re = re.split(\";\").map(function (part) {\n        return gmtFormat.replace(\"{0}\", part);\n      }).join(\"|\");\n      return new RegExp(\"^\" + re);\n    }\n\n    function populateProperties(path, value) {\n      // Skip\n      var skipRe = /(timeZoneNames\\/zone|supplemental\\/metaZones|timeZoneNames\\/metazone|timeZoneNames\\/regionFormat|timeZoneNames\\/gmtFormat)/;\n\n      if (skipRe.test(path)) {\n        return;\n      }\n\n      if (!value) {\n        return;\n      } // The `dates` and `calendars` trim's purpose is to reduce properties' key size only.\n\n\n      path = path.replace(/^.*\\/dates\\//, \"\").replace(/calendars\\//, \"\"); // Specific filter for \"gregorian/dayPeriods/format/wide\".\n\n      if (path === \"gregorian/dayPeriods/format/wide\") {\n        value = objectFilter(value, /^am|^pm/);\n      } // Transform object into array of pairs [key, /value/], sort by desc value length.\n\n\n      if (isPlainObject(value)) {\n        value = Object.keys(value).map(function (key) {\n          return [key, new RegExp(\"^\" + regexpEscape(looseMatching(value[key])))];\n        }).sort(function (a, b) {\n          return b[1].source.length - a[1].source.length;\n        }); // If typeof value === \"string\".\n      } else {\n        value = looseMatching(value);\n      }\n\n      properties[path] = value;\n    }\n\n    function regexpSourceSomeTerm(terms) {\n      return \"(\" + terms.filter(function (item) {\n        return item;\n      }).reduce(function (memo, item) {\n        return memo + \"|\" + item;\n      }) + \")\";\n    }\n\n    cldr.on(\"get\", populateProperties);\n    pattern.match(datePatternRe).forEach(function (current) {\n      var aux, chr, daylightTzName, gmtFormat, length, standardTzName;\n      chr = current.charAt(0);\n      length = current.length;\n\n      if (chr === \"Z\") {\n        if (length < 5) {\n          chr = \"O\";\n          length = 4;\n        } else {\n          chr = \"X\";\n          length = 5;\n        }\n      } // z...zzz: \"{shortRegion}\", eg. \"PST\" or \"PDT\".\n      // zzzz: \"{regionName} {Standard Time}\" or \"{regionName} {Daylight Time}\",\n      //       e.g., \"Pacific Standard Time\" or \"Pacific Daylight Time\".\n      // http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\n\n      if (chr === \"z\") {\n        standardTzName = dateGetTimeZoneName(length, \"standard\", timeZone, cldr);\n        daylightTzName = dateGetTimeZoneName(length, \"daylight\", timeZone, cldr);\n\n        if (standardTzName) {\n          standardTzName = regexpEscape(looseMatching(standardTzName));\n        }\n\n        if (daylightTzName) {\n          daylightTzName = regexpEscape(looseMatching(daylightTzName));\n        }\n\n        if (standardTzName || daylightTzName) {\n          properties.standardOrDaylightTzName = new RegExp(\"^\" + regexpSourceSomeTerm([standardTzName, daylightTzName]));\n        } // Fall through the \"O\" format in case one name is missing.\n\n\n        if (!standardTzName || !daylightTzName) {\n          chr = \"O\";\n\n          if (length < 4) {\n            length = 1;\n          }\n        }\n      } // v...vvv: \"{shortRegion}\", eg. \"PT\".\n      // vvvv: \"{regionName} {Time}\" or \"{regionName} {Time}\",\n      // e.g., \"Pacific Time\"\n      // http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\n\n      if (chr === \"v\") {\n        if (length !== 1 && length !== 4) {\n          throw createErrorUnsupportedFeature({\n            feature: \"timezone pattern `\" + pattern + \"`\"\n          });\n        }\n\n        var genericTzName = dateGetTimeZoneName(length, \"generic\", timeZone, cldr);\n\n        if (genericTzName) {\n          properties.genericTzName = new RegExp(\"^\" + regexpEscape(looseMatching(genericTzName)));\n          chr = \"O\"; // Fall back to \"V\" format.\n        } else {\n          chr = \"V\";\n          length = 4;\n        }\n      }\n\n      switch (chr) {\n        // Era\n        case \"G\":\n          cldr.main([\"dates/calendars/gregorian/eras\", length <= 3 ? \"eraAbbr\" : length === 4 ? \"eraNames\" : \"eraNarrow\"]);\n          break;\n        // Year\n\n        case \"u\": // Extended year. Need to be implemented.\n\n        case \"U\":\n          // Cyclic year name. Need to be implemented.\n          throw createErrorUnsupportedFeature({\n            feature: \"year pattern `\" + chr + \"`\"\n          });\n        // Quarter\n\n        case \"Q\":\n        case \"q\":\n          if (length > 2) {\n            cldr.main([\"dates/calendars/gregorian/quarters\", chr === \"Q\" ? \"format\" : \"stand-alone\", widths[length - 3]]);\n          }\n\n          break;\n        // Month\n\n        case \"M\":\n        case \"L\":\n          // number l=1:{1,2}, l=2:{2}.\n          // lookup l=3...\n          if (length > 2) {\n            cldr.main([\"dates/calendars/gregorian/months\", chr === \"M\" ? \"format\" : \"stand-alone\", widths[length - 3]]);\n          }\n\n          break;\n        // Day\n\n        case \"g\":\n          // Modified Julian day. Need to be implemented.\n          throw createErrorUnsupportedFeature({\n            feature: \"Julian day pattern `g`\"\n          });\n        // Week day\n\n        case \"e\":\n        case \"c\":\n          // lookup for length >=3.\n          if (length <= 2) {\n            break;\n          }\n\n        /* falls through */\n\n        case \"E\":\n          if (length === 6) {\n            // Note: if short day names are not explicitly specified, abbreviated day\n            // names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras\n            // eslint-disable-next-line no-unused-expressions\n            cldr.main([\"dates/calendars/gregorian/days\", [chr === \"c\" ? \"stand-alone\" : \"format\"], \"short\"]) || cldr.main([\"dates/calendars/gregorian/days\", [chr === \"c\" ? \"stand-alone\" : \"format\"], \"abbreviated\"]);\n          } else {\n            cldr.main([\"dates/calendars/gregorian/days\", [chr === \"c\" ? \"stand-alone\" : \"format\"], widths[length < 3 ? 0 : length - 3]]);\n          }\n\n          break;\n        // Period (AM or PM)\n\n        case \"a\":\n          cldr.main(\"dates/calendars/gregorian/dayPeriods/format/wide\");\n          break;\n        // Zone\n\n        case \"V\":\n          if (length === 1) {\n            throw createErrorUnsupportedFeature({\n              feature: \"timezone pattern `\" + pattern + \"`\"\n            });\n          }\n\n          if (timeZone) {\n            if (length === 2) {\n              // Skip looseMatching processing since timeZone is a canonical posix value.\n              properties.timeZoneName = timeZone;\n              properties.timeZoneNameRe = new RegExp(\"^\" + regexpEscape(timeZone));\n              break;\n            }\n\n            var timeZoneName,\n                exemplarCity = cldr.main([\"dates/timeZoneNames/zone\", timeZone, \"exemplarCity\"]);\n\n            if (length === 3) {\n              if (!exemplarCity) {\n                exemplarCity = cldr.main([\"dates/timeZoneNames/zone/Etc/Unknown/exemplarCity\"]);\n              }\n\n              timeZoneName = exemplarCity;\n            }\n\n            if (exemplarCity && length === 4) {\n              timeZoneName = formatMessage(cldr.main(\"dates/timeZoneNames/regionFormat\"), [exemplarCity]);\n            }\n\n            if (timeZoneName) {\n              timeZoneName = looseMatching(timeZoneName);\n              properties.timeZoneName = timeZoneName;\n              properties.timeZoneNameRe = new RegExp(\"^\" + regexpEscape(timeZoneName));\n            }\n          }\n\n          if (current === \"v\") {\n            length = 1;\n          }\n\n        /* falls through */\n\n        case \"z\":\n        case \"O\":\n          gmtFormat = cldr.main(\"dates/timeZoneNames/gmtFormat\");\n          cldr.main(\"dates/timeZoneNames/gmtZeroFormat\");\n          cldr.main(\"dates/timeZoneNames/hourFormat\");\n          properties[\"timeZoneNames/gmtZeroFormatRe\"] = new RegExp(\"^\" + regexpEscape(properties[\"timeZoneNames/gmtZeroFormat\"]));\n          aux = properties[\"timeZoneNames/hourFormat\"];\n          properties[\"timeZoneNames/hourFormat\"] = (length < 4 ? [dateTimezoneHourFormatHm(aux, \"H\"), dateTimezoneHourFormatH(aux)] : [dateTimezoneHourFormatHm(aux, \"HH\")]).map(function (hourFormat) {\n            return hourFormatRe(hourFormat, gmtFormat, digitsReSource, timeSeparator);\n          });\n\n        /* falls through */\n\n        case \"X\":\n        case \"x\":\n          // x: hourFormat(\"+HH[mm];-HH[mm]\")\n          // xx: hourFormat(\"+HHmm;-HHmm\")\n          // xxx: hourFormat(\"+HH:mm;-HH:mm\")\n          // xxxx: hourFormat(\"+HHmm[ss];-HHmm[ss]\")\n          // xxxxx: hourFormat(\"+HH:mm[:ss];-HH:mm[:ss]\")\n          properties.x = [[\"+HHmm;-HHmm\", \"+HH;-HH\"], [\"+HHmm;-HHmm\"], [\"+HH:mm;-HH:mm\"], [\"+HHmmss;-HHmmss\", \"+HHmm;-HHmm\"], [\"+HH:mm:ss;-HH:mm:ss\", \"+HH:mm;-HH:mm\"]][length - 1].map(function (hourFormat) {\n            return hourFormatRe(hourFormat);\n          });\n      }\n    });\n    cldr.off(\"get\", populateProperties);\n    return properties;\n  };\n  /**\n   * dayOfWeek( date, firstDay )\n   *\n   * @date\n   *\n   * @firstDay the result of `dateFirstDayOfWeek( cldr )`\n   *\n   * Return the day of the week normalized by the territory's firstDay [0-6].\n   * Eg for \"mon\":\n   * - return 0 if territory is GB, or BR, or DE, or FR (week starts on \"mon\");\n   * - return 1 if territory is US (week starts on \"sun\");\n   * - return 2 if territory is EG (week starts on \"sat\");\n   */\n\n\n  var dateDayOfWeek = function (date, firstDay) {\n    return (date.getDay() - firstDay + 7) % 7;\n  };\n  /**\n   * distanceInDays( from, to )\n   *\n   * Return the distance in days between from and to Dates.\n   */\n\n\n  var dateDistanceInDays = function (from, to) {\n    var inDays = 864e5;\n    return (to.getTime() - from.getTime()) / inDays;\n  };\n  /**\n   * dayOfYear\n   *\n   * Return the distance in days of the date to the begin of the year [0-d].\n   */\n\n\n  var dateDayOfYear = function (date) {\n    return Math.floor(dateDistanceInDays(dateStartOf(date, \"year\"), date));\n  }; // Invert key and values, e.g., {\"year\": \"yY\"} ==> {\"y\": \"year\", \"Y\": \"year\"}\n\n\n  var dateFieldsMap = objectInvert({\n    \"era\": \"G\",\n    \"year\": \"yY\",\n    \"quarter\": \"qQ\",\n    \"month\": \"ML\",\n    \"week\": \"wW\",\n    \"day\": \"dDF\",\n    \"weekday\": \"ecE\",\n    \"dayperiod\": \"a\",\n    \"hour\": \"hHkK\",\n    \"minute\": \"m\",\n    \"second\": \"sSA\",\n    \"zone\": \"zvVOxX\"\n  }, function (object, key, value) {\n    value.split(\"\").forEach(function (symbol) {\n      object[symbol] = key;\n    });\n    return object;\n  });\n  /**\n   * millisecondsInDay\n   */\n\n  var dateMillisecondsInDay = function (date) {\n    // TODO Handle daylight savings discontinuities\n    return date - dateStartOf(date, \"day\");\n  };\n  /**\n   * hourFormat( date, format, timeSeparator, formatNumber )\n   *\n   * Return date's timezone offset according to the format passed.\n   * Eg for format when timezone offset is 180:\n   * - \"+H;-H\": -3\n   * - \"+HHmm;-HHmm\": -0300\n   * - \"+HH:mm;-HH:mm\": -03:00\n   * - \"+HH:mm:ss;-HH:mm:ss\": -03:00:00\n   */\n\n\n  var dateTimezoneHourFormat = function (date, format, timeSeparator, formatNumber) {\n    var absOffset,\n        offset = date.getTimezoneOffset();\n    absOffset = Math.abs(offset);\n    formatNumber = formatNumber || {\n      1: function (value) {\n        return stringPad(value, 1);\n      },\n      2: function (value) {\n        return stringPad(value, 2);\n      }\n    };\n    return format // Pick the correct sign side (+ or -).\n    .split(\";\")[offset > 0 ? 1 : 0] // Localize time separator\n    .replace(\":\", timeSeparator) // Update hours offset.\n    .replace(/HH?/, function (match) {\n      return formatNumber[match.length](Math.floor(absOffset / 60));\n    }) // Update minutes offset and return.\n    .replace(/mm/, function () {\n      return formatNumber[2](Math.floor(absOffset % 60));\n    }) // Update minutes offset and return.\n    .replace(/ss/, function () {\n      return formatNumber[2](Math.floor(absOffset % 1 * 60));\n    });\n  };\n  /**\n   * format( date, properties )\n   *\n   * @date [Date instance].\n   *\n   * @properties\n   *\n   * TODO Support other calendar types.\n   *\n   * Disclosure: this function borrows excerpts of dojo/date/locale.\n   */\n\n\n  var dateFormat = function (date, numberFormatters, properties) {\n    var parts = [];\n    var timeSeparator = properties.timeSeparator; // create globalize date with given timezone data\n\n    if (properties.timeZoneData) {\n      date = new ZonedDateTime(date, properties.timeZoneData());\n    }\n\n    properties.pattern.replace(datePatternRe, function (current) {\n      var aux,\n          dateField,\n          type,\n          value,\n          chr = current.charAt(0),\n          length = current.length;\n\n      if (chr === \"j\") {\n        // Locale preferred hHKk.\n        // http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\n        chr = properties.preferredTime;\n      }\n\n      if (chr === \"Z\") {\n        // Z..ZZZ: same as \"xxxx\".\n        if (length < 4) {\n          chr = \"x\";\n          length = 4; // ZZZZ: same as \"OOOO\".\n        } else if (length < 5) {\n          chr = \"O\";\n          length = 4; // ZZZZZ: same as \"XXXXX\"\n        } else {\n          chr = \"X\";\n          length = 5;\n        }\n      } // z...zzz: \"{shortRegion}\", e.g., \"PST\" or \"PDT\".\n      // zzzz: \"{regionName} {Standard Time}\" or \"{regionName} {Daylight Time}\",\n      //       e.g., \"Pacific Standard Time\" or \"Pacific Daylight Time\".\n\n\n      if (chr === \"z\") {\n        if (date.isDST) {\n          value = date.isDST() ? properties.daylightTzName : properties.standardTzName;\n        } // Fall back to \"O\" format.\n\n\n        if (!value) {\n          chr = \"O\";\n\n          if (length < 4) {\n            length = 1;\n          }\n        }\n      }\n\n      switch (chr) {\n        // Era\n        case \"G\":\n          value = properties.eras[date.getFullYear() < 0 ? 0 : 1];\n          break;\n        // Year\n\n        case \"y\":\n          // Plain year.\n          // The length specifies the padding, but for two letters it also specifies the\n          // maximum length.\n          value = date.getFullYear();\n\n          if (length === 2) {\n            value = String(value);\n            value = +value.substr(value.length - 2);\n          }\n\n          break;\n\n        case \"Y\":\n          // Year in \"Week of Year\"\n          // The length specifies the padding, but for two letters it also specifies the\n          // maximum length.\n          // yearInWeekofYear = date + DaysInAWeek - (dayOfWeek - firstDay) - minDays\n          value = new Date(date.getTime());\n          value.setDate(value.getDate() + 7 - dateDayOfWeek(date, properties.firstDay) - properties.firstDay - properties.minDays);\n          value = value.getFullYear();\n\n          if (length === 2) {\n            value = String(value);\n            value = +value.substr(value.length - 2);\n          }\n\n          break;\n        // Quarter\n\n        case \"Q\":\n        case \"q\":\n          value = Math.ceil((date.getMonth() + 1) / 3);\n\n          if (length > 2) {\n            value = properties.quarters[chr][length][value];\n          }\n\n          break;\n        // Month\n\n        case \"M\":\n        case \"L\":\n          value = date.getMonth() + 1;\n\n          if (length > 2) {\n            value = properties.months[chr][length][value];\n          }\n\n          break;\n        // Week\n\n        case \"w\":\n          // Week of Year.\n          // woy = ceil( ( doy + dow of 1/1 ) / 7 ) - minDaysStuff ? 1 : 0.\n          // TODO should pad on ww? Not documented, but I guess so.\n          value = dateDayOfWeek(dateStartOf(date, \"year\"), properties.firstDay);\n          value = Math.ceil((dateDayOfYear(date) + value) / 7) - (7 - value >= properties.minDays ? 0 : 1);\n          break;\n\n        case \"W\":\n          // Week of Month.\n          // wom = ceil( ( dom + dow of `1/month` ) / 7 ) - minDaysStuff ? 1 : 0.\n          value = dateDayOfWeek(dateStartOf(date, \"month\"), properties.firstDay);\n          value = Math.ceil((date.getDate() + value) / 7) - (7 - value >= properties.minDays ? 0 : 1);\n          break;\n        // Day\n\n        case \"d\":\n          value = date.getDate();\n          break;\n\n        case \"D\":\n          value = dateDayOfYear(date) + 1;\n          break;\n\n        case \"F\":\n          // Day of Week in month. eg. 2nd Wed in July.\n          value = Math.floor(date.getDate() / 7) + 1;\n          break;\n        // Week day\n\n        case \"e\":\n        case \"c\":\n          if (length <= 2) {\n            // Range is [1-7] (deduced by example provided on documentation)\n            // TODO Should pad with zeros (not specified in the docs)?\n            value = dateDayOfWeek(date, properties.firstDay) + 1;\n            break;\n          }\n\n        /* falls through */\n\n        case \"E\":\n          value = dateWeekDays[date.getDay()];\n          value = properties.days[chr][length][value];\n          break;\n        // Period (AM or PM)\n\n        case \"a\":\n          value = properties.dayPeriods[date.getHours() < 12 ? \"am\" : \"pm\"];\n          break;\n        // Hour\n\n        case \"h\":\n          // 1-12\n          value = date.getHours() % 12 || 12;\n          break;\n\n        case \"H\":\n          // 0-23\n          value = date.getHours();\n          break;\n\n        case \"K\":\n          // 0-11\n          value = date.getHours() % 12;\n          break;\n\n        case \"k\":\n          // 1-24\n          value = date.getHours() || 24;\n          break;\n        // Minute\n\n        case \"m\":\n          value = date.getMinutes();\n          break;\n        // Second\n\n        case \"s\":\n          value = date.getSeconds();\n          break;\n\n        case \"S\":\n          value = Math.round(date.getMilliseconds() * Math.pow(10, length - 3));\n          break;\n\n        case \"A\":\n          value = Math.round(dateMillisecondsInDay(date) * Math.pow(10, length - 3));\n          break;\n        // Zone\n\n        case \"z\":\n          break;\n\n        case \"v\":\n          // v...vvv: \"{shortRegion}\", eg. \"PT\".\n          // vvvv: \"{regionName} {Time}\",\n          //       e.g., \"Pacific Time\".\n          if (properties.genericTzName) {\n            value = properties.genericTzName;\n            break;\n          }\n\n        /* falls through */\n\n        case \"V\":\n          //VVVV: \"{explarCity} {Time}\", e.g., \"Los Angeles Time\"\n          if (properties.timeZoneName) {\n            value = properties.timeZoneName;\n            break;\n          }\n\n          if (current === \"v\") {\n            length = 1;\n          }\n\n        /* falls through */\n\n        case \"O\":\n          // O: \"{gmtFormat}+H;{gmtFormat}-H\" or \"{gmtZeroFormat}\", eg. \"GMT-8\" or \"GMT\".\n          // OOOO: \"{gmtFormat}{hourFormat}\" or \"{gmtZeroFormat}\", eg. \"GMT-08:00\" or \"GMT\".\n          if (date.getTimezoneOffset() === 0) {\n            value = properties.gmtZeroFormat;\n          } else {\n            // If O..OOO and timezone offset has non-zero minutes, show minutes.\n            if (length < 4) {\n              aux = date.getTimezoneOffset();\n              aux = properties.hourFormat[aux % 60 - aux % 1 === 0 ? 0 : 1];\n            } else {\n              aux = properties.hourFormat;\n            }\n\n            value = dateTimezoneHourFormat(date, aux, timeSeparator, numberFormatters);\n            value = properties.gmtFormat.replace(/\\{0\\}/, value);\n          }\n\n          break;\n\n        case \"X\":\n          // Same as x*, except it uses \"Z\" for zero offset.\n          if (date.getTimezoneOffset() === 0) {\n            value = \"Z\";\n            break;\n          }\n\n        /* falls through */\n\n        case \"x\":\n          // x: hourFormat(\"+HH[mm];-HH[mm]\")\n          // xx: hourFormat(\"+HHmm;-HHmm\")\n          // xxx: hourFormat(\"+HH:mm;-HH:mm\")\n          // xxxx: hourFormat(\"+HHmm[ss];-HHmm[ss]\")\n          // xxxxx: hourFormat(\"+HH:mm[:ss];-HH:mm[:ss]\")\n          aux = date.getTimezoneOffset(); // If x and timezone offset has non-zero minutes, use xx (i.e., show minutes).\n\n          if (length === 1 && aux % 60 - aux % 1 !== 0) {\n            length += 1;\n          } // If (xxxx or xxxxx) and timezone offset has zero seconds, use xx or xxx\n          // respectively (i.e., don't show optional seconds).\n\n\n          if ((length === 4 || length === 5) && aux % 1 === 0) {\n            length -= 2;\n          }\n\n          value = [\"+HH;-HH\", \"+HHmm;-HHmm\", \"+HH:mm;-HH:mm\", \"+HHmmss;-HHmmss\", \"+HH:mm:ss;-HH:mm:ss\"][length - 1];\n          value = dateTimezoneHourFormat(date, value, \":\");\n          break;\n        // timeSeparator\n\n        case \":\":\n          value = timeSeparator;\n          break;\n        // ' literals.\n\n        case \"'\":\n          value = removeLiteralQuotes(current);\n          break;\n        // Anything else is considered a literal, including [ ,:/.@#], chinese, japonese, and\n        // arabic characters.\n\n        default:\n          value = current;\n      }\n\n      if (typeof value === \"number\") {\n        value = numberFormatters[length](value);\n      }\n\n      dateField = dateFieldsMap[chr];\n      type = dateField ? dateField : \"literal\";\n      partsPush(parts, type, value);\n    });\n    return parts;\n  };\n\n  var dateToPartsFormatterFn = function (numberFormatters, properties) {\n    return function dateToPartsFormatter(value) {\n      validateParameterPresence(value, \"value\");\n      validateParameterTypeDate(value, \"value\");\n      return dateFormat(value, numberFormatters, properties);\n    };\n  };\n\n  function optionsHasStyle(options) {\n    return options.skeleton !== undefined || options.date !== undefined || options.time !== undefined || options.datetime !== undefined || options.raw !== undefined;\n  }\n\n  function validateRequiredCldr(path, value) {\n    validateCldr(path, value, {\n      skip: [/dates\\/calendars\\/gregorian\\/dateTimeFormats\\/availableFormats/, /dates\\/calendars\\/gregorian\\/days\\/.*\\/short/, /dates\\/timeZoneNames\\/zone/, /dates\\/timeZoneNames\\/metazone/, /globalize-iana/, /supplemental\\/metaZones/, /supplemental\\/timeData\\/(?!001)/, /supplemental\\/weekData\\/(?!001)/]\n    });\n  }\n\n  function validateOptionsPreset(options) {\n    validateOptionsPresetEach(\"date\", options);\n    validateOptionsPresetEach(\"time\", options);\n    validateOptionsPresetEach(\"datetime\", options);\n  }\n\n  function validateOptionsPresetEach(type, options) {\n    var value = options[type];\n    validate(\"E_INVALID_OPTIONS\", \"Invalid `{{type}: \\\"{value}\\\"}`.\", value === undefined || [\"short\", \"medium\", \"long\", \"full\"].indexOf(value) !== -1, {\n      type: type,\n      value: value\n    });\n  }\n\n  function validateOptionsSkeleton(pattern, skeleton) {\n    validate(\"E_INVALID_OPTIONS\", \"Invalid `{skeleton: \\\"{value}\\\"}` based on provided CLDR.\", skeleton === undefined || typeof pattern === \"string\" && pattern, {\n      type: \"skeleton\",\n      value: skeleton\n    });\n  }\n\n  function validateRequiredIana(timeZone) {\n    return function (path, value) {\n      if (!/globalize-iana/.test(path)) {\n        return;\n      }\n\n      validate(\"E_MISSING_IANA_TZ\", \"Missing required IANA timezone content for `{timeZone}`: `{path}`.\", value, {\n        path: path.replace(/globalize-iana\\//, \"\"),\n        timeZone: timeZone\n      });\n    };\n  }\n  /**\n   * .loadTimeZone( json )\n   *\n   * @json [JSON]\n   *\n   * Load IANA timezone data.\n   */\n\n\n  Globalize.loadTimeZone = function (json) {\n    var customData = {\n      \"globalize-iana\": json\n    };\n    validateParameterPresence(json, \"json\");\n    validateParameterTypePlainObject(json, \"json\");\n    Cldr.load(customData);\n  };\n  /**\n   * .dateFormatter( options )\n   *\n   * @options [Object] see date/expand_pattern for more info.\n   *\n   * Return a date formatter function (of the form below) according to the given options and the\n   * default/instance locale.\n   *\n   * fn( value )\n   *\n   * @value [Date]\n   *\n   * Return a function that formats a date according to the given `format` and the default/instance\n   * locale.\n   */\n\n\n  Globalize.dateFormatter = Globalize.prototype.dateFormatter = function (options) {\n    var args, dateToPartsFormatter, returnFn;\n    validateParameterTypePlainObject(options, \"options\");\n    options = options || {};\n\n    if (!optionsHasStyle(options)) {\n      options.skeleton = \"yMd\";\n    }\n\n    args = [options];\n    dateToPartsFormatter = this.dateToPartsFormatter(options);\n    returnFn = dateFormatterFn(dateToPartsFormatter);\n    runtimeBind(args, this.cldr, returnFn, [dateToPartsFormatter]);\n    return returnFn;\n  };\n  /**\n   * .dateToPartsFormatter( options )\n   *\n   * @options [Object] see date/expand_pattern for more info.\n   *\n   * Return a date formatter function (of the form below) according to the given options and the\n   * default/instance locale.\n   *\n   * fn( value )\n   *\n   * @value [Date]\n   *\n   * Return a function that formats a date to parts according to the given `format`\n   * and the default/instance\n   * locale.\n   */\n\n\n  Globalize.dateToPartsFormatter = Globalize.prototype.dateToPartsFormatter = function (options) {\n    var args, cldr, numberFormatters, pad, pattern, properties, returnFn, timeZone, ianaListener;\n    validateParameterTypePlainObject(options, \"options\");\n    cldr = this.cldr;\n    options = options || {};\n\n    if (!optionsHasStyle(options)) {\n      options.skeleton = \"yMd\";\n    }\n\n    validateOptionsPreset(options);\n    validateDefaultLocale(cldr);\n    timeZone = options.timeZone;\n    validateParameterTypeString(timeZone, \"options.timeZone\");\n    args = [options];\n    cldr.on(\"get\", validateRequiredCldr);\n\n    if (timeZone) {\n      ianaListener = validateRequiredIana(timeZone);\n      cldr.on(\"get\", ianaListener);\n    }\n\n    try {\n      pattern = dateExpandPattern(options, cldr);\n      validateOptionsSkeleton(pattern, options.skeleton);\n      properties = dateFormatProperties(pattern, cldr, timeZone);\n    } finally {\n      cldr.off(\"get\", validateRequiredCldr);\n\n      if (ianaListener) {\n        cldr.off(\"get\", ianaListener);\n      }\n    } // Create needed number formatters.\n\n\n    numberFormatters = properties.numberFormatters;\n    delete properties.numberFormatters;\n\n    for (pad in numberFormatters) {\n      numberFormatters[pad] = this.numberFormatter({\n        raw: numberFormatters[pad]\n      });\n    }\n\n    returnFn = dateToPartsFormatterFn(numberFormatters, properties);\n    runtimeBind(args, cldr, returnFn, [numberFormatters, properties]);\n    return returnFn;\n  };\n  /**\n   * .dateParser( options )\n   *\n   * @options [Object] see date/expand_pattern for more info.\n   *\n   * Return a function that parses a string date according to the given `formats` and the\n   * default/instance locale.\n   */\n\n\n  Globalize.dateParser = Globalize.prototype.dateParser = function (options) {\n    var args, cldr, numberParser, parseProperties, pattern, returnFn, timeZone, tokenizerProperties;\n    validateParameterTypePlainObject(options, \"options\");\n    cldr = this.cldr;\n    options = options || {};\n\n    if (!optionsHasStyle(options)) {\n      options.skeleton = \"yMd\";\n    }\n\n    validateOptionsPreset(options);\n    validateDefaultLocale(cldr);\n    timeZone = options.timeZone;\n    validateParameterTypeString(timeZone, \"options.timeZone\");\n    args = [options];\n\n    try {\n      cldr.on(\"get\", validateRequiredCldr);\n\n      if (timeZone) {\n        cldr.on(\"get\", validateRequiredIana(timeZone));\n      }\n\n      pattern = dateExpandPattern(options, cldr);\n      validateOptionsSkeleton(pattern, options.skeleton);\n      tokenizerProperties = dateTokenizerProperties(pattern, cldr, timeZone);\n      parseProperties = dateParseProperties(cldr, timeZone);\n    } finally {\n      cldr.off(\"get\", validateRequiredCldr);\n\n      if (timeZone) {\n        cldr.off(\"get\", validateRequiredIana(timeZone));\n      }\n    }\n\n    numberParser = this.numberParser({\n      raw: \"0\"\n    });\n    returnFn = dateParserFn(numberParser, parseProperties, tokenizerProperties);\n    runtimeBind(args, cldr, returnFn, [numberParser, parseProperties, tokenizerProperties]);\n    return returnFn;\n  };\n  /**\n   * .formatDate( value, options )\n   *\n   * @value [Date]\n   *\n   * @options [Object] see date/expand_pattern for more info.\n   *\n   * Formats a date or number according to the given options string and the default/instance locale.\n   */\n\n\n  Globalize.formatDate = Globalize.prototype.formatDate = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeDate(value, \"value\");\n    return this.dateFormatter(options)(value);\n  };\n  /**\n   * .formatDateToParts( value, options )\n   *\n   * @value [Date]\n   *\n   * @options [Object] see date/expand_pattern for more info.\n   *\n   * Formats a date or number to parts according to the given options and the default/instance locale.\n   */\n\n\n  Globalize.formatDateToParts = Globalize.prototype.formatDateToParts = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeDate(value, \"value\");\n    return this.dateToPartsFormatter(options)(value);\n  };\n  /**\n   * .parseDate( value, options )\n   *\n   * @value [String]\n   *\n   * @options [Object] see date/expand_pattern for more info.\n   *\n   * Return a Date instance or null.\n   */\n\n\n  Globalize.parseDate = Globalize.prototype.parseDate = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeString(value, \"value\");\n    return this.dateParser(options)(value);\n  };\n\n  return Globalize;\n});","map":{"version":3,"sources":["D:/react-myprojects/hrms-airtable/node_modules/globalize/dist/globalize/date.js"],"names":["root","factory","define","amd","exports","module","require","Cldr","Globalize","createError","_createError","createErrorUnsupportedFeature","_createErrorUnsupportedFeature","formatMessage","_formatMessage","isPlainObject","_isPlainObject","looseMatching","_looseMatching","numberNumberingSystemDigitsMap","_numberNumberingSystemDigitsMap","numberSymbol","_numberSymbol","partsJoin","_partsJoin","partsPush","_partsPush","regexpEscape","_regexpEscape","removeLiteralQuotes","_removeLiteralQuotes","runtimeBind","_runtimeBind","stringPad","_stringPad","validate","_validate","validateCldr","_validateCldr","validateDefaultLocale","_validateDefaultLocale","validateParameterPresence","_validateParameterPresence","validateParameterType","_validateParameterType","validateParameterTypePlainObject","_validateParameterTypePlainObject","validateParameterTypeString","_validateParameterTypeString","validateParameterTypeDate","value","name","undefined","Date","createErrorInvalidParameterValue","validateSkeletonFieldsPosMap","split","reduce","memo","item","i","validateSkeleton","skeleton","last","fieldsPosMap","replace","field","invalidField","type","every","objectInvert","object","fn","key","Object","keys","newObject","dateExpandPatternSimilarFieldsMap","forEach","dateExpandPatternNormalizePatternType","character","datePatternRe","stringRepeat","str","count","result","expandBestMatchFormat","skeletonWithoutFractionalSeconds","bestMatchFormat","j","bestMatchFormatParts","matchedType","matchedLength","requestedType","requestedLength","requestedSkeletonParts","normalizePatternType","match","length","charAt","join","dateExpandPatternAugmentFormat","requestedSkeleton","decimalSeparator","countOfFractionalSeconds","fractionalSecondMatch","lastSecondIdx","lastIndexOf","slice","dateExpandPatternCompareFormats","formatA","formatB","a","b","distance","lenA","lenB","typeA","typeB","Math","abs","dateExpandPatternGetBestMatchPattern","cldr","askedSkeleton","availableFormats","pattern","ratedFormats","path","augmentFormat","compareFormats","main","push","rate","filter","format","sort","dateExpandPattern","options","dateSkeleton","timeSkeleton","getBestMatchPattern","combineDateTime","datePattern","timePattern","supplemental","timeData","preferred","test","date","time","datetime","raw","dateWeekDays","dateFirstDayOfWeek","indexOf","weekData","firstDay","dateGetTimeZoneName","timeZone","metaZone","dateTimezoneHourFormatH","hourFormat","map","dateTimezoneHourFormatHm","hFormat","parts","splice","runtimeCacheDataBind","data","dataCacheKey","dateFormatProperties","properties","numberFormatters","timeSeparator","widths","setNumberFormatterPattern","pad","timeZoneData","offsets","get","untils","isdsts","current","aux","chr","daylightTzName","formatNumber","genericTzName","standardTzName","preferredTime","eras","minDays","feature","quarters","months","days","dayPeriods","am","pm","timeZoneName","exemplarCity","gmtFormat","gmtZeroFormat","dateFormatterFn","dateToPartsFormatter","dateFormatter","dateParseProperties","preferredTimeData","ZonedDateTime","definePrivateProperty","property","defineProperty","getUntilsIndex","original","index","originalTime","getTime","setWrap","offset1","getTimezoneOffset","ret","setTime","offset2","setMinutes","getMinutes","Error","local","prototype","clone","method","utcMethod","substr","valueOf","isDST","Boolean","inspect","abbrs","toISOString","toDate","dateIsLeapYear","year","getMonth","dateLastDayOfMonth","getFullYear","getDate","dateStartOf","unit","setMonth","setDate","setHours","setSeconds","setMilliseconds","dateSetDate","day","lastDay","dateSetMonth","month","originalDate","outOfRange","low","high","dateParse","_value","tokens","amPm","daysOfYear","era","hour","hour12","timezoneOffset","valid","YEAR","MONTH","DAY","HOUR","MINUTE","SECOND","MILLISECONDS","truncateAt","units","token","century","floor","setFullYear","round","pow","getHours","max","apply","dateTokenizer","numberParser","digitsRe","numeric","tokenRe","hourFormatParse","isPositive","oneDigitIfLengthOne","oneOrTwoDigitsIfLengthOne","RegExp","source","oneOrTwoDigitsIfLengthOneOrTwo","twoDigitsIfLengthTwo","lookup","array","some","valueRe","standardOrDaylightTzName","timeZoneNameRe","hourFormatRe","x","lexeme","isNaN","dateParserFn","parseProperties","tokenizerProperties","dateParser","objectFilter","testRe","copy","dateTokenizerProperties","digitsReSource","re","part","populateProperties","skipRe","regexpSourceSomeTerm","terms","on","off","dateDayOfWeek","getDay","dateDistanceInDays","from","to","inDays","dateDayOfYear","dateFieldsMap","symbol","dateMillisecondsInDay","dateTimezoneHourFormat","absOffset","offset","dateFormat","dateField","String","ceil","getSeconds","getMilliseconds","dateToPartsFormatterFn","optionsHasStyle","validateRequiredCldr","skip","validateOptionsPreset","validateOptionsPresetEach","validateOptionsSkeleton","validateRequiredIana","loadTimeZone","json","customData","load","args","returnFn","ianaListener","numberFormatter","formatDate","formatDateToParts","parseDate"],"mappings":"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","sourcesContent":["/**\n * Globalize v1.7.0\n *\n * https://github.com/globalizejs/globalize\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2021-08-02T11:53Z\n */\n/*!\n * Globalize v1.7.0 2021-08-02T11:53Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function( root, factory ) {\n\n\t// UMD returnExports\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD\n\t\tdefine([\n\t\t\t\"cldr\",\n\t\t\t\"../globalize\",\n\t\t\t\"./number\",\n\t\t\t\"cldr/event\",\n\t\t\t\"cldr/supplemental\"\n\t\t], factory );\n\t} else if ( typeof exports === \"object\" ) {\n\n\t\t// Node, CommonJS\n\t\tmodule.exports = factory( require( \"cldrjs\" ), require( \"../globalize\" ) );\n\t} else {\n\n\t\t// Extend global\n\t\tfactory( root.Cldr, root.Globalize );\n\t}\n}(this, function( Cldr, Globalize ) {\n\nvar createError = Globalize._createError,\n\tcreateErrorUnsupportedFeature = Globalize._createErrorUnsupportedFeature,\n\tformatMessage = Globalize._formatMessage,\n\tisPlainObject = Globalize._isPlainObject,\n\tlooseMatching = Globalize._looseMatching,\n\tnumberNumberingSystemDigitsMap = Globalize._numberNumberingSystemDigitsMap,\n\tnumberSymbol = Globalize._numberSymbol,\n\tpartsJoin = Globalize._partsJoin,\n\tpartsPush = Globalize._partsPush,\n\tregexpEscape = Globalize._regexpEscape,\n\tremoveLiteralQuotes = Globalize._removeLiteralQuotes,\n\truntimeBind = Globalize._runtimeBind,\n\tstringPad = Globalize._stringPad,\n\tvalidate = Globalize._validate,\n\tvalidateCldr = Globalize._validateCldr,\n\tvalidateDefaultLocale = Globalize._validateDefaultLocale,\n\tvalidateParameterPresence = Globalize._validateParameterPresence,\n\tvalidateParameterType = Globalize._validateParameterType,\n\tvalidateParameterTypePlainObject = Globalize._validateParameterTypePlainObject,\n\tvalidateParameterTypeString = Globalize._validateParameterTypeString;\n\n\nvar validateParameterTypeDate = function( value, name ) {\n\tvalidateParameterType( value, name, value === undefined || value instanceof Date, \"Date\" );\n};\n\n\n\n\nvar createErrorInvalidParameterValue = function( name, value ) {\n\treturn createError( \"E_INVALID_PAR_VALUE\", \"Invalid `{name}` value ({value}).\", {\n\t\tname: name,\n\t\tvalue: value\n\t});\n};\n\n\n\n\n/**\n * Create a map between the skeleton fields and their positions, e.g.,\n * {\n *   G: 0\n *   y: 1\n *   ...\n * }\n */\nvar validateSkeletonFieldsPosMap = \"GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx\".split( \"\" ).reduce(function( memo, item, i ) {\n\tmemo[ item ] = i;\n\treturn memo;\n}, {});\n\n\n\n\n/**\n * validateSkeleton( skeleton )\n *\n * skeleton: Assume `j` has already been converted into a localized hour field.\n */\nvar validateSkeleton = function validateSkeleton( skeleton ) {\n\tvar last,\n\n\t\t// Using easier to read variable.\n\t\tfieldsPosMap = validateSkeletonFieldsPosMap;\n\n\t// \"The fields are from the Date Field Symbol Table in Date Format Patterns\"\n\t// Ref: http://www.unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n\t// I.e., check for invalid characters.\n\tskeleton.replace( /[^GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx]/, function( field ) {\n\t\tthrow createError(\n\t\t\t\"E_INVALID_OPTIONS\", \"Invalid field `{invalidField}` of skeleton `{value}`\",\n\t\t\t{\n\t\t\t\tinvalidField: field,\n\t\t\t\ttype: \"skeleton\",\n\t\t\t\tvalue: skeleton\n\t\t\t}\n\t\t);\n\t});\n\n\t// \"The canonical order is from top to bottom in that table; that is, yM not My\".\n\t// http://www.unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n\t// I.e., check for invalid order.\n\tskeleton.split( \"\" ).every(function( field ) {\n\t\tif ( fieldsPosMap[ field ] < last ) {\n\t\t\tthrow createError(\n\t\t\t\t\"E_INVALID_OPTIONS\", \"Invalid order `{invalidField}` of skeleton `{value}`\",\n\t\t\t\t{\n\t\t\t\t\tinvalidField: field,\n\t\t\t\t\ttype: \"skeleton\",\n\t\t\t\t\tvalue: skeleton\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tlast = fieldsPosMap[ field ];\n\t\treturn true;\n\t});\n};\n\n\n\n\n/**\n * Returns a new object created by using `object`'s values as keys, and the keys as values.\n */\nvar objectInvert = function( object, fn ) {\n\tfn = fn || function( object, key, value ) {\n\t\tobject[ value ] = key;\n\t\treturn object;\n\t};\n\treturn Object.keys( object ).reduce(function( newObject, key ) {\n\t\treturn fn( newObject, key, object[ key ] );\n\t}, {});\n};\n\n\n\n\n// Invert key and values, e.g., {\"e\": \"eEc\"} ==> {\"e\": \"e\", \"E\": \"e\", \"c\": \"e\"}.\nvar dateExpandPatternSimilarFieldsMap = objectInvert({\n\t\"e\": \"eEc\",\n\t\"L\": \"ML\"\n}, function( object, key, value ) {\n\tvalue.split( \"\" ).forEach(function( field ) {\n\t\tobject[ field ] = key;\n\t});\n\treturn object;\n});\n\n\n\n\nvar dateExpandPatternNormalizePatternType = function( character ) {\n\treturn dateExpandPatternSimilarFieldsMap[ character ] || character;\n};\n\n\n\n\nvar datePatternRe = ( /([a-z])\\1*|'([^']|'')+'|''|./ig );\n\n\n\n\nvar stringRepeat = function( str, count ) {\n\tvar i, result = \"\";\n\tfor ( i = 0; i < count; i++ ) {\n\t\tresult = result + str;\n\t}\n\treturn result;\n};\n\n\n\n\nfunction expandBestMatchFormat( skeletonWithoutFractionalSeconds, bestMatchFormat ) {\n\tvar i, j, bestMatchFormatParts, matchedType, matchedLength, requestedType,\n\t\trequestedLength, requestedSkeletonParts,\n\n\t\t// Using an easier to read variable.\n\t\tnormalizePatternType = dateExpandPatternNormalizePatternType;\n\n\trequestedSkeletonParts = skeletonWithoutFractionalSeconds.match( datePatternRe );\n\tbestMatchFormatParts = bestMatchFormat.match( datePatternRe );\n\n\tfor ( i = 0; i < bestMatchFormatParts.length; i++ ) {\n\t\tmatchedType = bestMatchFormatParts[ i ].charAt( 0 );\n\t\tmatchedLength = bestMatchFormatParts[ i ].length;\n\t\tfor ( j = 0; j < requestedSkeletonParts.length; j++ ) {\n\t\t\trequestedType = requestedSkeletonParts[ j ].charAt( 0 );\n\t\t\trequestedLength = requestedSkeletonParts[ j ].length;\n\t\t\tif ( normalizePatternType( matchedType ) === normalizePatternType( requestedType ) &&\n\t\t\t\tmatchedLength < requestedLength\n\t\t\t) {\n\t\t\t\tbestMatchFormatParts[ i ] = stringRepeat( matchedType, requestedLength );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn bestMatchFormatParts.join( \"\" );\n}\n\n// See: http://www.unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\nvar dateExpandPatternAugmentFormat = function( requestedSkeleton, bestMatchFormat, decimalSeparator ) {\n\tvar countOfFractionalSeconds, fractionalSecondMatch, lastSecondIdx,\n\t\tskeletonWithoutFractionalSeconds;\n\n\tfractionalSecondMatch = requestedSkeleton.match( /S/g );\n\tcountOfFractionalSeconds = fractionalSecondMatch ? fractionalSecondMatch.length : 0;\n\tskeletonWithoutFractionalSeconds = requestedSkeleton.replace( /S/g, \"\" );\n\n\tbestMatchFormat = expandBestMatchFormat( skeletonWithoutFractionalSeconds, bestMatchFormat );\n\n\tlastSecondIdx = bestMatchFormat.lastIndexOf( \"s\" );\n\tif ( lastSecondIdx !== -1 && countOfFractionalSeconds !== 0 ) {\n\t\tbestMatchFormat =\n\t\t\tbestMatchFormat.slice( 0, lastSecondIdx + 1 ) +\n\t\t\tdecimalSeparator +\n\t\t\tstringRepeat( \"S\", countOfFractionalSeconds ) +\n\t\t\tbestMatchFormat.slice( lastSecondIdx + 1 );\n\t}\n\treturn bestMatchFormat;\n};\n\n\n\n\nvar dateExpandPatternCompareFormats = function( formatA, formatB ) {\n\tvar a, b, distance, lenA, lenB, typeA, typeB, i, j,\n\n\t\t// Using easier to read variables.\n\t\tnormalizePatternType = dateExpandPatternNormalizePatternType;\n\n\tif ( formatA === formatB ) {\n\t\treturn 0;\n\t}\n\n\tformatA = formatA.match( datePatternRe );\n\tformatB = formatB.match( datePatternRe );\n\n\tif ( formatA.length !== formatB.length ) {\n\t\treturn -1;\n\t}\n\n\tdistance = 1;\n\tfor ( i = 0; i < formatA.length; i++ ) {\n\t\ta = formatA[ i ].charAt( 0 );\n\t\ttypeA = normalizePatternType( a );\n\t\ttypeB = null;\n\t\tfor ( j = 0; j < formatB.length; j++ ) {\n\t\t\tb = formatB[ j ].charAt( 0 );\n\t\t\ttypeB = normalizePatternType( b );\n\t\t\tif ( typeA === typeB ) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ttypeB = null;\n\t\t\t}\n\t\t}\n\t\tif ( typeB === null ) {\n\t\t\treturn -1;\n\t\t}\n\t\tlenA = formatA[ i ].length;\n\t\tlenB = formatB[ j ].length;\n\t\tdistance = distance + Math.abs( lenA - lenB );\n\n\t\t// Most symbols have a small distance from each other, e.g., M ≅ L; E ≅ c; a ≅ b ≅ B;\n\t\t// H ≅ k ≅ h ≅ K; ...\n\t\tif ( a !== b ) {\n\t\t\tdistance += 1;\n\t\t}\n\n\t\t// Numeric (l<3) and text fields (l>=3) are given a larger distance from each other.\n\t\tif ( ( lenA < 3 && lenB >= 3 ) || ( lenA >= 3 && lenB < 3 ) ) {\n\t\t\tdistance += 20;\n\t\t}\n\t}\n\treturn distance;\n};\n\n\n\n\nvar dateExpandPatternGetBestMatchPattern = function( cldr, askedSkeleton ) {\n\tvar availableFormats, decimalSeparator, pattern, ratedFormats, skeleton,\n\t\tpath = \"dates/calendars/gregorian/dateTimeFormats/availableFormats\",\n\n\t\t// Using easier to read variables.\n\t\taugmentFormat = dateExpandPatternAugmentFormat,\n\t\tcompareFormats = dateExpandPatternCompareFormats;\n\n\tpattern = cldr.main([ path, askedSkeleton ]);\n\n\tif ( askedSkeleton && !pattern ) {\n\t\tavailableFormats = cldr.main([ path ]);\n\t\tratedFormats = [];\n\n\t\tfor ( skeleton in availableFormats ) {\n\t\t\tratedFormats.push({\n\t\t\t\tskeleton: skeleton,\n\t\t\t\tpattern: availableFormats[ skeleton ],\n\t\t\t\trate: compareFormats( askedSkeleton, skeleton )\n\t\t\t});\n\t\t}\n\n\t\tratedFormats = ratedFormats\n\t\t\t.filter( function( format ) {\n\t\t\t\treturn format.rate > -1;\n\t\t\t} )\n\t\t\t.sort( function( formatA, formatB ) {\n\t\t\t\treturn formatA.rate - formatB.rate;\n\t\t\t});\n\n\t\tif ( ratedFormats.length ) {\n\t\t\tdecimalSeparator = numberSymbol( \"decimal\", cldr );\n\t\t\tpattern = augmentFormat( askedSkeleton, ratedFormats[ 0 ].pattern, decimalSeparator );\n\t\t}\n\t}\n\n\treturn pattern;\n};\n\n\n\n\n/**\n * expandPattern( options, cldr )\n *\n * @options [Object] if String, it's considered a skeleton. Object accepts:\n * - skeleton: [String] lookup availableFormat;\n * - date: [String] ( \"full\" | \"long\" | \"medium\" | \"short\" );\n * - time: [String] ( \"full\" | \"long\" | \"medium\" | \"short\" );\n * - datetime: [String] ( \"full\" | \"long\" | \"medium\" | \"short\" );\n * - raw: [String] For more info see datetime/format.js.\n *\n * @cldr [Cldr instance].\n *\n * Return the corresponding pattern.\n * Eg for \"en\":\n * - \"GyMMMd\" returns \"MMM d, y G\";\n * - { skeleton: \"GyMMMd\" } returns \"MMM d, y G\";\n * - { date: \"full\" } returns \"EEEE, MMMM d, y\";\n * - { time: \"full\" } returns \"h:mm:ss a zzzz\";\n * - { datetime: \"full\" } returns \"EEEE, MMMM d, y 'at' h:mm:ss a zzzz\";\n * - { raw: \"dd/mm\" } returns \"dd/mm\";\n */\nvar dateExpandPattern = function( options, cldr ) {\n\tvar dateSkeleton, result, skeleton, timeSkeleton, type,\n\n\t\t// Using easier to read variables.\n\t\tgetBestMatchPattern = dateExpandPatternGetBestMatchPattern;\n\n\tfunction combineDateTime( type, datePattern, timePattern ) {\n\t\treturn formatMessage(\n\t\t\tcldr.main([\n\t\t\t\t\"dates/calendars/gregorian/dateTimeFormats\",\n\t\t\t\ttype\n\t\t\t]),\n\t\t\t[ timePattern, datePattern ]\n\t\t);\n\t}\n\n\tswitch ( true ) {\n\t\tcase \"skeleton\" in options:\n\t\t\tskeleton = options.skeleton;\n\n\t\t\t// Preferred hour (j).\n\t\t\tskeleton = skeleton.replace( /j/g, function() {\n\t\t\t\treturn cldr.supplemental.timeData.preferred();\n\t\t\t});\n\n\t\t\tvalidateSkeleton( skeleton );\n\n\t\t\t// Try direct map (note that getBestMatchPattern handles it).\n\t\t\t// ... or, try to \"best match\" the whole skeleton.\n\t\t\tresult = getBestMatchPattern(\n\t\t\t\tcldr,\n\t\t\t\tskeleton\n\t\t\t);\n\t\t\tif ( result ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// ... or, try to \"best match\" the date and time parts individually.\n\t\t\ttimeSkeleton = skeleton.split( /[^hHKkmsSAzZOvVXx]/ ).slice( -1 )[ 0 ];\n\t\t\tdateSkeleton = skeleton.split( /[^GyYuUrQqMLlwWdDFgEec]/ )[ 0 ];\n\t\t\tdateSkeleton = getBestMatchPattern(\n\t\t\t\tcldr,\n\t\t\t\tdateSkeleton\n\t\t\t);\n\t\t\ttimeSkeleton = getBestMatchPattern(\n\t\t\t\tcldr,\n\t\t\t\ttimeSkeleton\n\t\t\t);\n\n\t\t\tif ( /(MMMM|LLLL).*[Ec]/.test( dateSkeleton ) ) {\n\t\t\t\ttype = \"full\";\n\t\t\t} else if ( /MMMM|LLLL/.test( dateSkeleton ) ) {\n\t\t\t\ttype = \"long\";\n\t\t\t} else if ( /MMM|LLL/.test( dateSkeleton ) ) {\n\t\t\t\ttype = \"medium\";\n\t\t\t} else {\n\t\t\t\ttype = \"short\";\n\t\t\t}\n\n\t\t\tif ( dateSkeleton && timeSkeleton ) {\n\t\t\t\tresult = combineDateTime( type, dateSkeleton, timeSkeleton );\n\t\t\t} else {\n\t\t\t\tresult = dateSkeleton || timeSkeleton;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase \"date\" in options:\n\t\tcase \"time\" in options:\n\t\t\tresult = cldr.main([\n\t\t\t\t\"dates/calendars/gregorian\",\n\t\t\t\t\"date\" in options ? \"dateFormats\" : \"timeFormats\",\n\t\t\t\t( options.date || options.time )\n\t\t\t]);\n\t\t\tbreak;\n\n\t\tcase \"datetime\" in options:\n\t\t\tresult = combineDateTime( options.datetime,\n\t\t\t\tcldr.main([ \"dates/calendars/gregorian/dateFormats\", options.datetime ]),\n\t\t\t\tcldr.main([ \"dates/calendars/gregorian/timeFormats\", options.datetime ])\n\t\t\t);\n\t\t\tbreak;\n\n\t\tcase \"raw\" in options:\n\t\t\tresult = options.raw;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow createErrorInvalidParameterValue({\n\t\t\t\tname: \"options\",\n\t\t\t\tvalue: options\n\t\t\t});\n\t}\n\n\treturn result;\n};\n\n\n\n\nvar dateWeekDays = [ \"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\" ];\n\n\n\n\n/**\n * firstDayOfWeek\n */\nvar dateFirstDayOfWeek = function( cldr ) {\n\treturn dateWeekDays.indexOf( cldr.supplemental.weekData.firstDay() );\n};\n\n\n\n\n/**\n * getTimeZoneName( length, type )\n */\nvar dateGetTimeZoneName = function( length, type, timeZone, cldr ) {\n\tvar metaZone, result;\n\n\tif ( !timeZone ) {\n\t\treturn;\n\t}\n\n\tresult = cldr.main([\n\t\t\"dates/timeZoneNames/zone\",\n\t\ttimeZone,\n\t\tlength < 4 ? \"short\" : \"long\",\n\t\ttype\n\t]);\n\n\tif ( result ) {\n\t\treturn result;\n\t}\n\n\t// The latest metazone data of the metazone array.\n\t// TODO expand to support the historic metazones based on the given date.\n\tmetaZone = cldr.supplemental([\n\t\t\"metaZones/metazoneInfo/timezone\", timeZone, 0,\n\t\t\"usesMetazone/_mzone\"\n\t]);\n\n\treturn cldr.main([\n\t\t\"dates/timeZoneNames/metazone\",\n\t\tmetaZone,\n\t\tlength < 4 ? \"short\" : \"long\",\n\t\ttype\n\t]);\n};\n\n\n\n\n/**\n * timezoneHourFormatShortH( hourFormat )\n *\n * @hourFormat [String]\n *\n * Unofficial deduction of the short hourFormat given time zone `hourFormat` element.\n * Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293\n *\n * Example:\n * - \"+HH.mm;-HH.mm\" => \"+H;-H\"\n * - \"+HH:mm;-HH:mm\" => \"+H;-H\"\n * - \"+HH:mm;−HH:mm\" => \"+H;−H\" (Note MINUS SIGN \\u2212)\n * - \"+HHmm;-HHmm\" => \"+H:-H\"\n */\nvar dateTimezoneHourFormatH = function( hourFormat ) {\n\treturn hourFormat\n\t\t.split( \";\" )\n\t\t.map(function( format ) {\n\t\t\treturn format.slice( 0, format.indexOf( \"H\" ) + 1 );\n\t\t})\n\t\t.join( \";\" );\n};\n\n\n\n\n/**\n * timezoneHourFormatLongHm( hourFormat )\n *\n * @hourFormat [String]\n *\n * Unofficial deduction of the short hourFormat given time zone `hourFormat` element.\n * Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293\n *\n * Example (hFormat === \"H\"): (used for short Hm)\n * - \"+HH.mm;-HH.mm\" => \"+H.mm;-H.mm\"\n * - \"+HH:mm;-HH:mm\" => \"+H:mm;-H:mm\"\n * - \"+HH:mm;−HH:mm\" => \"+H:mm;−H:mm\" (Note MINUS SIGN \\u2212)\n * - \"+HHmm;-HHmm\" => \"+Hmm:-Hmm\"\n *\n * Example (hFormat === \"HH\": (used for long Hm)\n * - \"+HH.mm;-HH.mm\" => \"+HH.mm;-HH.mm\"\n * - \"+HH:mm;-HH:mm\" => \"+HH:mm;-HH:mm\"\n * - \"+H:mm;-H:mm\"   => \"+HH:mm;-HH:mm\"\n * - \"+HH:mm;−HH:mm\" => \"+HH:mm;−HH:mm\" (Note MINUS SIGN \\u2212)\n * - \"+HHmm;-HHmm\" => \"+HHmm:-HHmm\"\n */\nvar dateTimezoneHourFormatHm = function( hourFormat, hFormat ) {\n\treturn hourFormat\n\t\t.split( \";\" )\n\t\t.map(function( format ) {\n\t\t\tvar parts = format.split( /H+/ );\n\t\t\tparts.splice( 1, 0, hFormat );\n\t\t\treturn parts.join( \"\" );\n\t\t})\n\t\t.join( \";\" );\n};\n\n\n\n\nvar runtimeCacheDataBind = function( key, data ) {\n\tvar fn = function() {\n\t\treturn data;\n\t};\n\tfn.dataCacheKey = key;\n\treturn fn;\n};\n\n\n\n\n/**\n * properties( pattern, cldr )\n *\n * @pattern [String] raw pattern.\n * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n *\n * @cldr [Cldr instance].\n *\n * Return the properties given the pattern and cldr.\n *\n * TODO Support other calendar types.\n */\nvar dateFormatProperties = function( pattern, cldr, timeZone ) {\n\tvar properties = {\n\t\t\tnumberFormatters: {},\n\t\t\tpattern: pattern,\n\t\t\ttimeSeparator: numberSymbol( \"timeSeparator\", cldr )\n\t\t},\n\t\twidths = [ \"abbreviated\", \"wide\", \"narrow\" ];\n\n\tfunction setNumberFormatterPattern( pad ) {\n\t\tproperties.numberFormatters[ pad ] = stringPad( \"\", pad );\n\t}\n\n\tif ( timeZone ) {\n\t\tproperties.timeZoneData = runtimeCacheDataBind( \"iana/\" + timeZone, {\n\t\t\toffsets: cldr.get([ \"globalize-iana/zoneData\", timeZone, \"offsets\" ]),\n\t\t\tuntils: cldr.get([ \"globalize-iana/zoneData\", timeZone, \"untils\" ]),\n\t\t\tisdsts: cldr.get([ \"globalize-iana/zoneData\", timeZone, \"isdsts\" ])\n\t\t});\n\t}\n\n\tpattern.replace( datePatternRe, function( current ) {\n\t\tvar aux, chr, daylightTzName, formatNumber, genericTzName, length, standardTzName;\n\n\t\tchr = current.charAt( 0 );\n\t\tlength = current.length;\n\n\t\tif ( chr === \"j\" ) {\n\n\t\t\t// Locale preferred hHKk.\n\t\t\t// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\n\t\t\tproperties.preferredTime = chr = cldr.supplemental.timeData.preferred();\n\t\t}\n\n\t\t// ZZZZ: same as \"OOOO\".\n\t\tif ( chr === \"Z\" && length === 4 ) {\n\t\t\tchr = \"O\";\n\t\t\tlength = 4;\n\t\t}\n\n\t\t// z...zzz: \"{shortRegion}\", eg. \"PST\" or \"PDT\".\n\t\t// zzzz: \"{regionName} {Standard Time}\" or \"{regionName} {Daylight Time}\",\n\t\t//       e.g., \"Pacific Standard Time\" or \"Pacific Daylight Time\".\n\t\t// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\t\tif ( chr === \"z\" ) {\n\t\t\tstandardTzName = dateGetTimeZoneName( length, \"standard\", timeZone, cldr );\n\t\t\tdaylightTzName = dateGetTimeZoneName( length, \"daylight\", timeZone, cldr );\n\t\t\tif ( standardTzName ) {\n\t\t\t\tproperties.standardTzName = standardTzName;\n\t\t\t}\n\t\t\tif ( daylightTzName ) {\n\t\t\t\tproperties.daylightTzName = daylightTzName;\n\t\t\t}\n\n\t\t\t// Fall through the \"O\" format in case one name is missing.\n\t\t\tif ( !standardTzName || !daylightTzName ) {\n\t\t\t\tchr = \"O\";\n\t\t\t\tif ( length < 4 ) {\n\t\t\t\t\tlength = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// v...vvv: \"{shortRegion}\", eg. \"PT\".\n\t\t// vvvv: \"{regionName} {Time}\" or \"{regionName} {Time}\",\n\t\t// e.g., \"Pacific Time\"\n\t\t// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\t\tif ( chr === \"v\" ) {\n\t\t\tgenericTzName = dateGetTimeZoneName( length, \"generic\", timeZone, cldr );\n\n\t\t\t// Fall back to \"V\" format.\n\t\t\tif ( !genericTzName ) {\n\t\t\t\tchr = \"V\";\n\t\t\t\tlength = 4;\n\t\t\t}\n\t\t}\n\n\t\tswitch ( chr ) {\n\n\t\t\t// Era\n\t\t\tcase \"G\":\n\t\t\t\tproperties.eras = cldr.main([\n\t\t\t\t\t\"dates/calendars/gregorian/eras\",\n\t\t\t\t\tlength <= 3 ? \"eraAbbr\" : ( length === 4 ? \"eraNames\" : \"eraNarrow\" )\n\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Year\n\t\t\tcase \"y\":\n\n\t\t\t\t// Plain year.\n\t\t\t\tformatNumber = true;\n\t\t\t\tbreak;\n\n\t\t\tcase \"Y\":\n\n\t\t\t\t// Year in \"Week of Year\"\n\t\t\t\tproperties.firstDay = dateFirstDayOfWeek( cldr );\n\t\t\t\tproperties.minDays = cldr.supplemental.weekData.minDays();\n\t\t\t\tformatNumber = true;\n\t\t\t\tbreak;\n\n\t\t\tcase \"u\": // Extended year. Need to be implemented.\n\t\t\tcase \"U\": // Cyclic year name. Need to be implemented.\n\t\t\t\tthrow createErrorUnsupportedFeature({\n\t\t\t\t\tfeature: \"year pattern `\" + chr + \"`\"\n\t\t\t\t});\n\n\t\t\t// Quarter\n\t\t\tcase \"Q\":\n\t\t\tcase \"q\":\n\t\t\t\tif ( length > 2 ) {\n\t\t\t\t\tif ( !properties.quarters ) {\n\t\t\t\t\t\tproperties.quarters = {};\n\t\t\t\t\t}\n\t\t\t\t\tif ( !properties.quarters[ chr ] ) {\n\t\t\t\t\t\tproperties.quarters[ chr ] = {};\n\t\t\t\t\t}\n\t\t\t\t\tproperties.quarters[ chr ][ length ] = cldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/quarters\",\n\t\t\t\t\t\tchr === \"Q\" ? \"format\" : \"stand-alone\",\n\t\t\t\t\t\twidths[ length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\t} else {\n\t\t\t\t\tformatNumber = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Month\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\t\t\t\tif ( length > 2 ) {\n\t\t\t\t\tif ( !properties.months ) {\n\t\t\t\t\t\tproperties.months = {};\n\t\t\t\t\t}\n\t\t\t\t\tif ( !properties.months[ chr ] ) {\n\t\t\t\t\t\tproperties.months[ chr ] = {};\n\t\t\t\t\t}\n\t\t\t\t\tproperties.months[ chr ][ length ] = cldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/months\",\n\t\t\t\t\t\tchr === \"M\" ? \"format\" : \"stand-alone\",\n\t\t\t\t\t\twidths[ length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\t} else {\n\t\t\t\t\tformatNumber = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Week - Week of Year (w) or Week of Month (W).\n\t\t\tcase \"w\":\n\t\t\tcase \"W\":\n\t\t\t\tproperties.firstDay = dateFirstDayOfWeek( cldr );\n\t\t\t\tproperties.minDays = cldr.supplemental.weekData.minDays();\n\t\t\t\tformatNumber = true;\n\t\t\t\tbreak;\n\n\t\t\t// Day\n\t\t\tcase \"d\":\n\t\t\tcase \"D\":\n\t\t\tcase \"F\":\n\t\t\t\tformatNumber = true;\n\t\t\t\tbreak;\n\n\t\t\tcase \"g\":\n\n\t\t\t\t// Modified Julian day. Need to be implemented.\n\t\t\t\tthrow createErrorUnsupportedFeature({\n\t\t\t\t\tfeature: \"Julian day pattern `g`\"\n\t\t\t\t});\n\n\t\t\t// Week day\n\t\t\tcase \"e\":\n\t\t\tcase \"c\":\n\t\t\t\tif ( length <= 2 ) {\n\t\t\t\t\tproperties.firstDay = dateFirstDayOfWeek( cldr );\n\t\t\t\t\tformatNumber = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"E\":\n\t\t\t\tif ( !properties.days ) {\n\t\t\t\t\tproperties.days = {};\n\t\t\t\t}\n\t\t\t\tif ( !properties.days[ chr ] ) {\n\t\t\t\t\tproperties.days[ chr ] = {};\n\t\t\t\t}\n\t\t\t\tif ( length === 6 ) {\n\n\t\t\t\t\t// If short day names are not explicitly specified, abbreviated day names are\n\t\t\t\t\t// used instead.\n\t\t\t\t\t// http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras\n\t\t\t\t\t// http://unicode.org/cldr/trac/ticket/6790\n\t\t\t\t\tproperties.days[ chr ][ length ] = cldr.main([\n\t\t\t\t\t\t\t\"dates/calendars/gregorian/days\",\n\t\t\t\t\t\t\tchr === \"c\" ? \"stand-alone\" : \"format\",\n\t\t\t\t\t\t\t\"short\"\n\t\t\t\t\t\t]) || cldr.main([\n\t\t\t\t\t\t\t\"dates/calendars/gregorian/days\",\n\t\t\t\t\t\t\tchr === \"c\" ? \"stand-alone\" : \"format\",\n\t\t\t\t\t\t\t\"abbreviated\"\n\t\t\t\t\t\t]);\n\t\t\t\t} else {\n\t\t\t\t\tproperties.days[ chr ][ length ] = cldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/days\",\n\t\t\t\t\t\tchr === \"c\" ? \"stand-alone\" : \"format\",\n\t\t\t\t\t\twidths[ length < 3 ? 0 : length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Period (AM or PM)\n\t\t\tcase \"a\":\n\t\t\t\tproperties.dayPeriods = {\n\t\t\t\t\tam: cldr.main(\n\t\t\t\t\t\t\"dates/calendars/gregorian/dayPeriods/format/wide/am\"\n\t\t\t\t\t),\n\t\t\t\t\tpm: cldr.main(\n\t\t\t\t\t\t\"dates/calendars/gregorian/dayPeriods/format/wide/pm\"\n\t\t\t\t\t)\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\t// Hour\n\t\t\tcase \"h\": // 1-12\n\t\t\tcase \"H\": // 0-23\n\t\t\tcase \"K\": // 0-11\n\t\t\tcase \"k\": // 1-24\n\n\t\t\t// Minute\n\t\t\tcase \"m\":\n\n\t\t\t// Second\n\t\t\tcase \"s\":\n\t\t\tcase \"S\":\n\t\t\tcase \"A\":\n\t\t\t\tformatNumber = true;\n\t\t\t\tbreak;\n\n\t\t\t// Zone\n\t\t\tcase \"v\":\n\t\t\t\tif ( length !== 1 && length !== 4 ) {\n\t\t\t\t\tthrow createErrorUnsupportedFeature({\n\t\t\t\t\t\tfeature: \"timezone pattern `\" + pattern + \"`\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tproperties.genericTzName = genericTzName;\n\t\t\t\tbreak;\n\n\t\t\tcase \"V\":\n\n\t\t\t\tif ( length === 1 ) {\n\t\t\t\t\tthrow createErrorUnsupportedFeature({\n\t\t\t\t\t\tfeature: \"timezone pattern `\" + pattern + \"`\"\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif ( timeZone ) {\n\t\t\t\t\tif ( length === 2 ) {\n\t\t\t\t\t\tproperties.timeZoneName = timeZone;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar timeZoneName,\n\t\t\t\t\t\texemplarCity = cldr.main([\n\t\t\t\t\t\t\t\"dates/timeZoneNames/zone\", timeZone, \"exemplarCity\"\n\t\t\t\t\t\t]);\n\n\t\t\t\t\tif ( length === 3 ) {\n\t\t\t\t\t\tif ( !exemplarCity ) {\n\t\t\t\t\t\t\texemplarCity = cldr.main([\n\t\t\t\t\t\t\t\t\"dates/timeZoneNames/zone/Etc/Unknown/exemplarCity\"\n\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttimeZoneName = exemplarCity;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( exemplarCity && length === 4 ) {\n\t\t\t\t\t\ttimeZoneName = formatMessage(\n\t\t\t\t\t\t\tcldr.main(\n\t\t\t\t\t\t\t\t\"dates/timeZoneNames/regionFormat\"\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t[ exemplarCity ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( timeZoneName ) {\n\t\t\t\t\t\tproperties.timeZoneName = timeZoneName;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( current === \"v\" ) {\n\t\t\t\t\tlength = 1;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"O\":\n\n\t\t\t\t// O: \"{gmtFormat}+H;{gmtFormat}-H\" or \"{gmtZeroFormat}\", eg. \"GMT-8\" or \"GMT\".\n\t\t\t\t// OOOO: \"{gmtFormat}{hourFormat}\" or \"{gmtZeroFormat}\", eg. \"GMT-08:00\" or \"GMT\".\n\t\t\t\tproperties.gmtFormat = cldr.main( \"dates/timeZoneNames/gmtFormat\" );\n\t\t\t\tproperties.gmtZeroFormat = cldr.main( \"dates/timeZoneNames/gmtZeroFormat\" );\n\n\t\t\t\t// Unofficial deduction of the hourFormat variations.\n\t\t\t\t// Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293\n\t\t\t\taux = cldr.main( \"dates/timeZoneNames/hourFormat\" );\n\t\t\t\tproperties.hourFormat = length < 4 ?\n\t\t\t\t\t[ dateTimezoneHourFormatH( aux ), dateTimezoneHourFormatHm( aux, \"H\" ) ] :\n\t\t\t\t\tdateTimezoneHourFormatHm( aux, \"HH\" );\n\n\t\t\t/* falls through */\n\t\t\tcase \"Z\":\n\t\t\tcase \"X\":\n\t\t\tcase \"x\":\n\t\t\t\tsetNumberFormatterPattern( 1 );\n\t\t\t\tsetNumberFormatterPattern( 2 );\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ( formatNumber ) {\n\t\t\tsetNumberFormatterPattern( length );\n\t\t}\n\t});\n\n\treturn properties;\n};\n\n\n\n\nvar dateFormatterFn = function( dateToPartsFormatter ) {\n\treturn function dateFormatter( value ) {\n\t\treturn partsJoin( dateToPartsFormatter( value ));\n\t};\n};\n\n\n\n\n/**\n * parseProperties( cldr )\n *\n * @cldr [Cldr instance].\n *\n * @timeZone [String] FIXME.\n *\n * Return parser properties.\n */\nvar dateParseProperties = function( cldr, timeZone ) {\n\tvar properties = {\n\t\tpreferredTimeData: cldr.supplemental.timeData.preferred()\n\t};\n\n\tif ( timeZone ) {\n\t\tproperties.timeZoneData = runtimeCacheDataBind( \"iana/\" + timeZone, {\n\t\t\toffsets: cldr.get([ \"globalize-iana/zoneData\", timeZone, \"offsets\" ]),\n\t\t\tuntils: cldr.get([ \"globalize-iana/zoneData\", timeZone, \"untils\" ]),\n\t\t\tisdsts: cldr.get([ \"globalize-iana/zoneData\", timeZone, \"isdsts\" ])\n\t\t});\n\t}\n\n\treturn properties;\n};\n\n\nvar ZonedDateTime = (function() {\nfunction definePrivateProperty(object, property, value) {\n  Object.defineProperty(object, property, {\n    value: value\n  });\n}\n\nfunction getUntilsIndex(original, untils) {\n  var index = 0;\n  var originalTime = original.getTime();\n\n  // TODO Should we do binary search for improved performance?\n  while (index < untils.length - 1 && originalTime >= untils[index]) {\n    index++;\n  }\n  return index;\n}\n\nfunction setWrap(fn) {\n  var offset1 = this.getTimezoneOffset();\n  var ret = fn();\n  this.original.setTime(new Date(this.getTime()));\n  var offset2 = this.getTimezoneOffset();\n  if (offset2 - offset1) {\n    this.original.setMinutes(this.original.getMinutes() + offset2 - offset1);\n  }\n  return ret;\n}\n\nvar ZonedDateTime = function(date, timeZoneData) {\n  definePrivateProperty(this, \"original\", new Date(date.getTime()));\n  definePrivateProperty(this, \"local\", new Date(date.getTime()));\n  definePrivateProperty(this, \"timeZoneData\", timeZoneData);\n  definePrivateProperty(this, \"setWrap\", setWrap);\n  if (!(timeZoneData.untils && timeZoneData.offsets && timeZoneData.isdsts)) {\n    throw new Error(\"Invalid IANA data\");\n  }\n  this.setTime(this.local.getTime() - this.getTimezoneOffset() * 60 * 1000);\n};\n\nZonedDateTime.prototype.clone = function() {\n  return new ZonedDateTime(this.original, this.timeZoneData);\n};\n\n// Date field getters.\n[\"getFullYear\", \"getMonth\", \"getDate\", \"getDay\", \"getHours\", \"getMinutes\",\n\"getSeconds\", \"getMilliseconds\"].forEach(function(method) {\n  // Corresponding UTC method, e.g., \"getUTCFullYear\" if method === \"getFullYear\".\n  var utcMethod = \"getUTC\" + method.substr(3);\n  ZonedDateTime.prototype[method] = function() {\n    return this.local[utcMethod]();\n  };\n});\n\n// Note: Define .valueOf = .getTime for arithmetic operations like date1 - date2.\nZonedDateTime.prototype.valueOf =\nZonedDateTime.prototype.getTime = function() {\n  return this.local.getTime() + this.getTimezoneOffset() * 60 * 1000;\n};\n\nZonedDateTime.prototype.getTimezoneOffset = function() {\n  var index = getUntilsIndex(this.original, this.timeZoneData.untils);\n  return this.timeZoneData.offsets[index];\n};\n\n// Date field setters.\n[\"setFullYear\", \"setMonth\", \"setDate\", \"setHours\", \"setMinutes\", \"setSeconds\", \"setMilliseconds\"].forEach(function(method) {\n  // Corresponding UTC method, e.g., \"setUTCFullYear\" if method === \"setFullYear\".\n  var utcMethod = \"setUTC\" + method.substr(3);\n  ZonedDateTime.prototype[method] = function(value) {\n    var local = this.local;\n    // Note setWrap is needed for seconds and milliseconds just because\n    // abs(value) could be >= a minute.\n    return this.setWrap(function() {\n      return local[utcMethod](value);\n    });\n  };\n});\n\nZonedDateTime.prototype.setTime = function(time) {\n  return this.local.setTime(time);\n};\n\nZonedDateTime.prototype.isDST = function() {\n  var index = getUntilsIndex(this.original, this.timeZoneData.untils);\n  return Boolean(this.timeZoneData.isdsts[index]);\n};\n\nZonedDateTime.prototype.inspect = function() {\n  var index = getUntilsIndex(this.original, this.timeZoneData.untils);\n  var abbrs = this.timeZoneData.abbrs;\n  return this.local.toISOString().replace(/Z$/, \"\") + \" \" +\n    (abbrs && abbrs[index] + \" \" || (this.getTimezoneOffset() * -1) + \" \") +\n    (this.isDST() ? \"(daylight savings)\" : \"\");\n};\n\nZonedDateTime.prototype.toDate = function() {\n  return new Date(this.getTime());\n};\n\n// Type cast getters.\n[\"toISOString\", \"toJSON\", \"toUTCString\"].forEach(function(method) {\n  ZonedDateTime.prototype[method] = function() {\n    return this.toDate()[method]();\n  };\n});\n\nreturn ZonedDateTime;\n}());\n\n\n/**\n * isLeapYear( year )\n *\n * @year [Number]\n *\n * Returns an indication whether the specified year is a leap year.\n */\nvar dateIsLeapYear = function( year ) {\n\treturn new Date( year, 1, 29 ).getMonth() === 1;\n};\n\n\n\n\n/**\n * lastDayOfMonth( date )\n *\n * @date [Date]\n *\n * Return the last day of the given date's month\n */\nvar dateLastDayOfMonth = function( date ) {\n\treturn new Date( date.getFullYear(), date.getMonth() + 1, 0 ).getDate();\n};\n\n\n\n\n/**\n * startOf changes the input to the beginning of the given unit.\n *\n * For example, starting at the start of a day, resets hours, minutes\n * seconds and milliseconds to 0. Starting at the month does the same, but\n * also sets the date to 1.\n *\n * Returns the modified date\n */\nvar dateStartOf = function( date, unit ) {\n\tdate = date instanceof ZonedDateTime ? date.clone() : new Date( date.getTime() );\n\tswitch ( unit ) {\n\t\tcase \"year\":\n\t\t\tdate.setMonth( 0 );\n\t\t/* falls through */\n\t\tcase \"month\":\n\t\t\tdate.setDate( 1 );\n\t\t/* falls through */\n\t\tcase \"day\":\n\t\t\tdate.setHours( 0 );\n\t\t/* falls through */\n\t\tcase \"hour\":\n\t\t\tdate.setMinutes( 0 );\n\t\t/* falls through */\n\t\tcase \"minute\":\n\t\t\tdate.setSeconds( 0 );\n\t\t/* falls through */\n\t\tcase \"second\":\n\t\t\tdate.setMilliseconds( 0 );\n\t}\n\treturn date;\n};\n\n\n\n\n/**\n * Differently from native date.setDate(), this function returns a date whose\n * day remains inside the month boundaries. For example:\n *\n * setDate( FebDate, 31 ): a \"Feb 28\" date.\n * setDate( SepDate, 31 ): a \"Sep 30\" date.\n */\nvar dateSetDate = function( date, day ) {\n\tvar lastDay = new Date( date.getFullYear(), date.getMonth() + 1, 0 ).getDate();\n\n\tdate.setDate( day < 1 ? 1 : day < lastDay ? day : lastDay );\n};\n\n\n\n\n/**\n * Differently from native date.setMonth(), this function adjusts date if\n * needed, so final month is always the one set.\n *\n * setMonth( Jan31Date, 1 ): a \"Feb 28\" date.\n * setDate( Jan31Date, 8 ): a \"Sep 30\" date.\n */\nvar dateSetMonth = function( date, month ) {\n\tvar originalDate = date.getDate();\n\n\tdate.setDate( 1 );\n\tdate.setMonth( month );\n\tdateSetDate( date, originalDate );\n};\n\n\n\n\nvar outOfRange = function( value, low, high ) {\n\treturn value < low || value > high;\n};\n\n\n\n\n/**\n * parse( value, tokens, properties )\n *\n * @value [String] string date.\n *\n * @tokens [Object] tokens returned by date/tokenizer.\n *\n * @properties [Object] output returned by date/tokenizer-properties.\n *\n * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n */\nvar dateParse = function( _value, tokens, properties ) {\n\tvar amPm, day, daysOfYear, month, era, hour, hour12, timezoneOffset, valid,\n\t\tYEAR = 0,\n\t\tMONTH = 1,\n\t\tDAY = 2,\n\t\tHOUR = 3,\n\t\tMINUTE = 4,\n\t\tSECOND = 5,\n\t\tMILLISECONDS = 6,\n\t\tdate = new Date(),\n\t\ttruncateAt = [],\n\t\tunits = [ \"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"milliseconds\" ];\n\n\t// Create globalize date with given timezone data.\n\tif ( properties.timeZoneData ) {\n\t\tdate = new ZonedDateTime( date, properties.timeZoneData() );\n\t}\n\n\tif ( !tokens.length ) {\n\t\treturn null;\n\t}\n\n\tvalid = tokens.every(function( token ) {\n\t\tvar century, chr, value, length;\n\n\t\tif ( token.type === \"literal\" ) {\n\n\t\t\t// continue\n\t\t\treturn true;\n\t\t}\n\n\t\tchr = token.type.charAt( 0 );\n\t\tlength = token.type.length;\n\n\t\tif ( chr === \"j\" ) {\n\n\t\t\t// Locale preferred hHKk.\n\t\t\t// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\n\t\t\tchr = properties.preferredTimeData;\n\t\t}\n\n\t\tswitch ( chr ) {\n\n\t\t\t// Era\n\t\t\tcase \"G\":\n\t\t\t\ttruncateAt.push( YEAR );\n\t\t\t\tera = +token.value;\n\t\t\t\tbreak;\n\n\t\t\t// Year\n\t\t\tcase \"y\":\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( length === 2 ) {\n\t\t\t\t\tif ( outOfRange( value, 0, 99 ) ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// mimic dojo/date/locale: choose century to apply, according to a sliding\n\t\t\t\t\t// window of 80 years before and 20 years after present year.\n\t\t\t\t\tcentury = Math.floor( date.getFullYear() / 100 ) * 100;\n\t\t\t\t\tvalue += century;\n\t\t\t\t\tif ( value > date.getFullYear() + 20 ) {\n\t\t\t\t\t\tvalue -= 100;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdate.setFullYear( value );\n\t\t\t\ttruncateAt.push( YEAR );\n\t\t\t\tbreak;\n\n\t\t\tcase \"Y\": // Year in \"Week of Year\"\n\t\t\t\tthrow createErrorUnsupportedFeature({\n\t\t\t\t\tfeature: \"year pattern `\" + chr + \"`\"\n\t\t\t\t});\n\n\t\t\t// Quarter (skip)\n\t\t\tcase \"Q\":\n\t\t\tcase \"q\":\n\t\t\t\tbreak;\n\n\t\t\t// Month\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\t\t\t\tif ( length <= 2 ) {\n\t\t\t\t\tvalue = token.value;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = +token.value;\n\t\t\t\t}\n\t\t\t\tif ( outOfRange( value, 1, 12 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Setting the month later so that we have the correct year and can determine\n\t\t\t\t// the correct last day of February in case of leap year.\n\t\t\t\tmonth = value;\n\t\t\t\ttruncateAt.push( MONTH );\n\t\t\t\tbreak;\n\n\t\t\t// Week (skip)\n\t\t\tcase \"w\": // Week of Year.\n\t\t\tcase \"W\": // Week of Month.\n\t\t\t\tbreak;\n\n\t\t\t// Day\n\t\t\tcase \"d\":\n\t\t\t\tday = token.value;\n\t\t\t\ttruncateAt.push( DAY );\n\t\t\t\tbreak;\n\n\t\t\tcase \"D\":\n\t\t\t\tdaysOfYear = token.value;\n\t\t\t\ttruncateAt.push( DAY );\n\t\t\t\tbreak;\n\n\t\t\tcase \"F\":\n\n\t\t\t\t// Day of Week in month. eg. 2nd Wed in July.\n\t\t\t\t// Skip\n\t\t\t\tbreak;\n\n\t\t\t// Week day\n\t\t\tcase \"e\":\n\t\t\tcase \"c\":\n\t\t\tcase \"E\":\n\n\t\t\t\t// Skip.\n\t\t\t\t// value = arrayIndexOf( dateWeekDays, token.value );\n\t\t\t\tbreak;\n\n\t\t\t// Period (AM or PM)\n\t\t\tcase \"a\":\n\t\t\t\tamPm = token.value;\n\t\t\t\tbreak;\n\n\t\t\t// Hour\n\t\t\tcase \"h\": // 1-12\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 1, 12 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\thour = hour12 = true;\n\t\t\t\tdate.setHours( value === 12 ? 0 : value );\n\t\t\t\ttruncateAt.push( HOUR );\n\t\t\t\tbreak;\n\n\t\t\tcase \"K\": // 0-11\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 0, 11 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\thour = hour12 = true;\n\t\t\t\tdate.setHours( value );\n\t\t\t\ttruncateAt.push( HOUR );\n\t\t\t\tbreak;\n\n\t\t\tcase \"k\": // 1-24\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 1, 24 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\thour = true;\n\t\t\t\tdate.setHours( value === 24 ? 0 : value );\n\t\t\t\ttruncateAt.push( HOUR );\n\t\t\t\tbreak;\n\n\t\t\tcase \"H\": // 0-23\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 0, 23 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\thour = true;\n\t\t\t\tdate.setHours( value );\n\t\t\t\ttruncateAt.push( HOUR );\n\t\t\t\tbreak;\n\n\t\t\t// Minute\n\t\t\tcase \"m\":\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 0, 59 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tdate.setMinutes( value );\n\t\t\t\ttruncateAt.push( MINUTE );\n\t\t\t\tbreak;\n\n\t\t\t// Second\n\t\t\tcase \"s\":\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 0, 59 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tdate.setSeconds( value );\n\t\t\t\ttruncateAt.push( SECOND );\n\t\t\t\tbreak;\n\n\t\t\tcase \"A\":\n\t\t\t\tdate.setHours( 0 );\n\t\t\t\tdate.setMinutes( 0 );\n\t\t\t\tdate.setSeconds( 0 );\n\n\t\t\t/* falls through */\n\t\t\tcase \"S\":\n\t\t\t\tvalue = Math.round( token.value * Math.pow( 10, 3 - length ) );\n\t\t\t\tdate.setMilliseconds( value );\n\t\t\t\ttruncateAt.push( MILLISECONDS );\n\t\t\t\tbreak;\n\n\t\t\t// Zone\n\t\t\tcase \"z\":\n\t\t\tcase \"Z\":\n\t\t\tcase \"O\":\n\t\t\tcase \"v\":\n\t\t\tcase \"V\":\n\t\t\tcase \"X\":\n\t\t\tcase \"x\":\n\t\t\t\tif ( typeof token.value === \"number\" ) {\n\t\t\t\t\ttimezoneOffset = token.value;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t});\n\n\tif ( !valid ) {\n\t\treturn null;\n\t}\n\n\t// 12-hour format needs AM or PM, 24-hour format doesn't, ie. return null\n\t// if amPm && !hour12 || !amPm && hour12.\n\tif ( hour && !( !amPm ^ hour12 ) ) {\n\t\treturn null;\n\t}\n\n\tif ( era === 0 ) {\n\n\t\t// 1 BC = year 0\n\t\tdate.setFullYear( date.getFullYear() * -1 + 1 );\n\t}\n\n\tif ( month !== undefined ) {\n\t\tdateSetMonth( date, month - 1 );\n\t}\n\n\tif ( day !== undefined ) {\n\t\tif ( outOfRange( day, 1, dateLastDayOfMonth( date ) ) ) {\n\t\t\treturn null;\n\t\t}\n\t\tdate.setDate( day );\n\t} else if ( daysOfYear !== undefined ) {\n\t\tif ( outOfRange( daysOfYear, 1, dateIsLeapYear( date.getFullYear() ) ? 366 : 365 ) ) {\n\t\t\treturn null;\n\t\t}\n\t\tdate.setMonth( 0 );\n\t\tdate.setDate( daysOfYear );\n\t}\n\n\tif ( hour12 && amPm === \"pm\" ) {\n\t\tdate.setHours( date.getHours() + 12 );\n\t}\n\n\tif ( timezoneOffset !== undefined ) {\n\t\tdate.setMinutes( date.getMinutes() + timezoneOffset - date.getTimezoneOffset() );\n\t}\n\n\t// Truncate date at the most precise unit defined. Eg.\n\t// If value is \"12/31\", and pattern is \"MM/dd\":\n\t// => new Date( <current Year>, 12, 31, 0, 0, 0, 0 );\n\ttruncateAt = Math.max.apply( null, truncateAt );\n\tdate = dateStartOf( date, units[ truncateAt ] );\n\n\t// Get date back from globalize date.\n\tif ( date instanceof ZonedDateTime ) {\n\t\tdate = date.toDate();\n\t}\n\n\treturn date;\n};\n\n\n/* eslint-disable no-unused-expressions */\n\n\n\n/**\n * tokenizer( value, numberParser, properties )\n *\n * @value [String] string date.\n *\n * @numberParser [Function]\n *\n * @properties [Object] output returned by date/tokenizer-properties.\n *\n * Returns an Array of tokens, eg. value \"5 o'clock PM\", pattern \"h 'o''clock' a\":\n * [{\n *   type: \"h\",\n *   lexeme: \"5\"\n * }, {\n *   type: \"literal\",\n *   lexeme: \" \"\n * }, {\n *   type: \"literal\",\n *   lexeme: \"o'clock\"\n * }, {\n *   type: \"literal\",\n *   lexeme: \" \"\n * }, {\n *   type: \"a\",\n *   lexeme: \"PM\",\n *   value: \"pm\"\n * }]\n *\n * OBS: lexeme's are always String and may return invalid ranges depending of the token type.\n * Eg. \"99\" for month number.\n *\n * Return an empty Array when not successfully parsed.\n */\nvar dateTokenizer = function( value, numberParser, properties ) {\n\tvar digitsRe, valid,\n\t\ttokens = [],\n\t\twidths = [ \"abbreviated\", \"wide\", \"narrow\" ];\n\n\tdigitsRe = properties.digitsRe;\n\tvalue = looseMatching( value );\n\n\tvalid = properties.pattern.match( datePatternRe ).every(function( current ) {\n\t\tvar aux, chr, length, numeric, tokenRe,\n\t\t\ttoken = {};\n\n\t\tfunction hourFormatParse( tokenRe, numberParser ) {\n\t\t\tvar aux, isPositive,\n\t\t\t\tmatch = value.match( tokenRe );\n\t\t\tnumberParser = numberParser || function( value ) {\n\t\t\t\treturn +value;\n\t\t\t};\n\n\t\t\tif ( !match ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tisPositive = match[ 1 ];\n\n\t\t\t// hourFormat containing H only, e.g., `+H;-H`\n\t\t\tif ( match.length < 6 ) {\n\t\t\t\taux = isPositive ? 1 : 3;\n\t\t\t\ttoken.value = numberParser( match[ aux ] ) * 60;\n\n\t\t\t// hourFormat containing H and m, e.g., `+HHmm;-HHmm`\n\t\t\t} else if ( match.length < 10 ) {\n\t\t\t\taux = isPositive ? [ 1, 3 ] : [ 5, 7 ];\n\t\t\t\ttoken.value = numberParser( match[ aux[ 0 ] ] ) * 60 +\n\t\t\t\t\tnumberParser( match[ aux[ 1 ] ] );\n\n\t\t\t// hourFormat containing H, m, and s e.g., `+HHmmss;-HHmmss`\n\t\t\t} else {\n\t\t\t\taux = isPositive ? [ 1, 3, 5 ] : [ 7, 9, 11 ];\n\t\t\t\ttoken.value = numberParser( match[ aux[ 0 ] ] ) * 60 +\n\t\t\t\t\tnumberParser( match[ aux[ 1 ] ] ) +\n\t\t\t\t\tnumberParser( match[ aux[ 2 ] ] ) / 60;\n\t\t\t}\n\n\t\t\tif ( isPositive ) {\n\t\t\t\ttoken.value *= -1;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tfunction oneDigitIfLengthOne() {\n\t\t\tif ( length === 1 ) {\n\n\t\t\t\t// Unicode equivalent to /\\d/\n\t\t\t\tnumeric = true;\n\t\t\t\treturn tokenRe = digitsRe;\n\t\t\t}\n\t\t}\n\n\t\tfunction oneOrTwoDigitsIfLengthOne() {\n\t\t\tif ( length === 1 ) {\n\n\t\t\t\t// Unicode equivalent to /\\d\\d?/\n\t\t\t\tnumeric = true;\n\t\t\t\treturn tokenRe = new RegExp( \"^(\" + digitsRe.source + \"){1,2}\" );\n\t\t\t}\n\t\t}\n\n\t\tfunction oneOrTwoDigitsIfLengthOneOrTwo() {\n\t\t\tif ( length === 1 || length === 2 ) {\n\n\t\t\t\t// Unicode equivalent to /\\d\\d?/\n\t\t\t\tnumeric = true;\n\t\t\t\treturn tokenRe = new RegExp( \"^(\" + digitsRe.source + \"){1,2}\" );\n\t\t\t}\n\t\t}\n\n\t\tfunction twoDigitsIfLengthTwo() {\n\t\t\tif ( length === 2 ) {\n\n\t\t\t\t// Unicode equivalent to /\\d\\d/\n\t\t\t\tnumeric = true;\n\t\t\t\treturn tokenRe = new RegExp( \"^(\" + digitsRe.source + \"){2}\" );\n\t\t\t}\n\t\t}\n\n\t\t// Brute-force test every locale entry in an attempt to match the given value.\n\t\t// Return the first found one (and set token accordingly), or null.\n\t\tfunction lookup( path ) {\n\t\t\tvar array = properties[ path.join( \"/\" ) ];\n\n\t\t\tif ( !array ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// array of pairs [key, value] sorted by desc value length.\n\t\t\tarray.some(function( item ) {\n\t\t\t\tvar valueRe = item[ 1 ];\n\t\t\t\tif ( valueRe.test( value ) ) {\n\t\t\t\t\ttoken.value = item[ 0 ];\n\t\t\t\t\ttokenRe = item[ 1 ];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn null;\n\t\t}\n\n\t\ttoken.type = current;\n\t\tchr = current.charAt( 0 );\n\t\tlength = current.length;\n\n\t\tif ( chr === \"Z\" ) {\n\n\t\t\t// Z..ZZZ: same as \"xxxx\".\n\t\t\tif ( length < 4 ) {\n\t\t\t\tchr = \"x\";\n\t\t\t\tlength = 4;\n\n\t\t\t// ZZZZ: same as \"OOOO\".\n\t\t\t} else if ( length < 5 ) {\n\t\t\t\tchr = \"O\";\n\t\t\t\tlength = 4;\n\n\t\t\t// ZZZZZ: same as \"XXXXX\"\n\t\t\t} else {\n\t\t\t\tchr = \"X\";\n\t\t\t\tlength = 5;\n\t\t\t}\n\t\t}\n\n\t\tif ( chr === \"z\" ) {\n\t\t\tif ( properties.standardOrDaylightTzName ) {\n\t\t\t\ttoken.value = null;\n\t\t\t\ttokenRe = properties.standardOrDaylightTzName;\n\t\t\t}\n\t\t}\n\n\t\t// v...vvv: \"{shortRegion}\", eg. \"PT\".\n\t\t// vvvv: \"{regionName} {Time}\" or \"{regionName} {Time}\",\n\t\t// e.g., \"Pacific Time\"\n\t\t// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\t\tif ( chr === \"v\" ) {\n\t\t\tif ( properties.genericTzName ) {\n\t\t\t\ttoken.value = null;\n\t\t\t\ttokenRe = properties.genericTzName;\n\n\t\t\t// Fall back to \"V\" format.\n\t\t\t} else {\n\t\t\t\tchr = \"V\";\n\t\t\t\tlength = 4;\n\t\t\t}\n\t\t}\n\n\t\tif ( chr === \"V\" && properties.timeZoneName ) {\n\t\t\ttoken.value = length === 2 ? properties.timeZoneName : null;\n\t\t\ttokenRe = properties.timeZoneNameRe;\n\t\t}\n\n\t\tswitch ( chr ) {\n\n\t\t\t// Era\n\t\t\tcase \"G\":\n\t\t\t\tlookup([\n\t\t\t\t\t\"gregorian/eras\",\n\t\t\t\t\tlength <= 3 ? \"eraAbbr\" : ( length === 4 ? \"eraNames\" : \"eraNarrow\" )\n\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Year\n\t\t\tcase \"y\":\n\t\t\tcase \"Y\":\n\t\t\t\tnumeric = true;\n\n\t\t\t\t// number l=1:+, l=2:{2}, l=3:{3,}, l=4:{4,}, ...\n\t\t\t\tif ( length === 1 ) {\n\n\t\t\t\t\t// Unicode equivalent to /\\d+/.\n\t\t\t\t\ttokenRe = new RegExp( \"^(\" + digitsRe.source + \")+\" );\n\t\t\t\t} else if ( length === 2 ) {\n\n\t\t\t\t\t// Lenient parsing: there's no year pattern to indicate non-zero-padded 2-digits\n\t\t\t\t\t// year, so parser accepts both zero-padded and non-zero-padded for `yy`.\n\t\t\t\t\t//\n\t\t\t\t\t// Unicode equivalent to /\\d\\d?/\n\t\t\t\t\ttokenRe = new RegExp( \"^(\" + digitsRe.source + \"){1,2}\" );\n\t\t\t\t} else {\n\n\t\t\t\t\t// Unicode equivalent to /\\d{length,}/\n\t\t\t\t\ttokenRe = new RegExp( \"^(\" + digitsRe.source + \"){\" + length + \",}\" );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Quarter\n\t\t\tcase \"Q\":\n\t\t\tcase \"q\":\n\n\t\t\t\t// number l=1:{1}, l=2:{2}.\n\t\t\t\t// lookup l=3...\n\t\t\t\toneDigitIfLengthOne() || twoDigitsIfLengthTwo() ||\n\t\t\t\t\tlookup([\n\t\t\t\t\t\t\"gregorian/quarters\",\n\t\t\t\t\t\tchr === \"Q\" ? \"format\" : \"stand-alone\",\n\t\t\t\t\t\twidths[ length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Month\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\n\t\t\t\t// number l=1:{1,2}, l=2:{2}.\n\t\t\t\t// lookup l=3...\n\t\t\t\t//\n\t\t\t\t// Lenient parsing: skeleton \"yMd\" (i.e., one M) may include MM for the pattern,\n\t\t\t\t// therefore parser accepts both zero-padded and non-zero-padded for M and MM.\n\t\t\t\t// Similar for L.\n\t\t\t\toneOrTwoDigitsIfLengthOneOrTwo() || lookup([\n\t\t\t\t\t\"gregorian/months\",\n\t\t\t\t\tchr === \"M\" ? \"format\" : \"stand-alone\",\n\t\t\t\t\twidths[ length - 3 ]\n\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Day\n\t\t\tcase \"D\":\n\n\t\t\t\t// number {l,3}.\n\t\t\t\tif ( length <= 3 ) {\n\n\t\t\t\t\t// Equivalent to /\\d{length,3}/\n\t\t\t\t\tnumeric = true;\n\t\t\t\t\ttokenRe = new RegExp( \"^(\" + digitsRe.source + \"){\" + length + \",3}\" );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"W\":\n\t\t\tcase \"F\":\n\n\t\t\t\t// number l=1:{1}.\n\t\t\t\toneDigitIfLengthOne();\n\t\t\t\tbreak;\n\n\t\t\t// Week day\n\t\t\tcase \"e\":\n\t\t\tcase \"c\":\n\n\t\t\t\t// number l=1:{1}, l=2:{2}.\n\t\t\t\t// lookup for length >=3.\n\t\t\t\tif ( length <= 2 ) {\n\t\t\t\t\toneDigitIfLengthOne() || twoDigitsIfLengthTwo();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"E\":\n\t\t\t\tif ( length === 6 ) {\n\n\t\t\t\t\t// Note: if short day names are not explicitly specified, abbreviated day\n\t\t\t\t\t// names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras\n\t\t\t\t\tlookup([\n\t\t\t\t\t\t\"gregorian/days\",\n\t\t\t\t\t\t[ chr === \"c\" ? \"stand-alone\" : \"format\" ],\n\t\t\t\t\t\t\"short\"\n\t\t\t\t\t]) || lookup([\n\t\t\t\t\t\t\"gregorian/days\",\n\t\t\t\t\t\t[ chr === \"c\" ? \"stand-alone\" : \"format\" ],\n\t\t\t\t\t\t\"abbreviated\"\n\t\t\t\t\t]);\n\t\t\t\t} else {\n\t\t\t\t\tlookup([\n\t\t\t\t\t\t\"gregorian/days\",\n\t\t\t\t\t\t[ chr === \"c\" ? \"stand-alone\" : \"format\" ],\n\t\t\t\t\t\twidths[ length < 3 ? 0 : length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Period (AM or PM)\n\t\t\tcase \"a\":\n\t\t\t\tlookup([\n\t\t\t\t\t\"gregorian/dayPeriods/format/wide\"\n\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Week\n\t\t\tcase \"w\":\n\n\t\t\t\t// number l1:{1,2}, l2:{2}.\n\t\t\t\toneOrTwoDigitsIfLengthOne() || twoDigitsIfLengthTwo();\n\t\t\t\tbreak;\n\n\t\t\t// Day, Hour, Minute, or Second\n\t\t\tcase \"d\":\n\t\t\tcase \"h\":\n\t\t\tcase \"H\":\n\t\t\tcase \"K\":\n\t\t\tcase \"k\":\n\t\t\tcase \"j\":\n\t\t\tcase \"m\":\n\t\t\tcase \"s\":\n\n\t\t\t\t// number l1:{1,2}, l2:{2}.\n\t\t\t\t//\n\t\t\t\t// Lenient parsing:\n\t\t\t\t// - skeleton \"hms\" (i.e., one m) always includes mm for the pattern, i.e., it's\n\t\t\t\t//   impossible to use a different skeleton to parse non-zero-padded minutes,\n\t\t\t\t//   therefore parser accepts both zero-padded and non-zero-padded for m. Similar\n\t\t\t\t//   for seconds s.\n\t\t\t\t// - skeleton \"hms\" (i.e., one h) may include h or hh for the pattern, i.e., it's\n\t\t\t\t//   impossible to use a different skeleton to parser non-zero-padded hours for some\n\t\t\t\t//   locales, therefore parser accepts both zero-padded and non-zero-padded for h.\n\t\t\t\t//   Similar for d (in skeleton yMd).\n\t\t\t\toneOrTwoDigitsIfLengthOneOrTwo();\n\t\t\t\tbreak;\n\n\t\t\tcase \"S\":\n\n\t\t\t\t// number {l}.\n\n\t\t\t\t// Unicode equivalent to /\\d{length}/\n\t\t\t\tnumeric = true;\n\t\t\t\ttokenRe = new RegExp( \"^(\" + digitsRe.source + \"){\" + length + \"}\" );\n\t\t\t\tbreak;\n\n\t\t\tcase \"A\":\n\n\t\t\t\t// number {l+5}.\n\n\t\t\t\t// Unicode equivalent to /\\d{length+5}/\n\t\t\t\tnumeric = true;\n\t\t\t\ttokenRe = new RegExp( \"^(\" + digitsRe.source + \"){\" + ( length + 5 ) + \"}\" );\n\t\t\t\tbreak;\n\n\t\t\t// Zone\n\t\t\tcase \"v\":\n\t\t\tcase \"V\":\n\t\t\tcase \"z\":\n\t\t\t\tif ( tokenRe && tokenRe.test( value ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( chr === \"V\" && length === 2 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"O\":\n\n\t\t\t\t// O: \"{gmtFormat}+H;{gmtFormat}-H\" or \"{gmtZeroFormat}\", eg. \"GMT-8\" or \"GMT\".\n\t\t\t\t// OOOO: \"{gmtFormat}{hourFormat}\" or \"{gmtZeroFormat}\", eg. \"GMT-08:00\" or \"GMT\".\n\t\t\t\tif ( value === properties[ \"timeZoneNames/gmtZeroFormat\" ] ) {\n\t\t\t\t\ttoken.value = 0;\n\t\t\t\t\ttokenRe = properties[ \"timeZoneNames/gmtZeroFormatRe\" ];\n\t\t\t\t} else {\n\t\t\t\t\taux = properties[ \"timeZoneNames/hourFormat\" ].some(function( hourFormatRe ) {\n\t\t\t\t\t\tif ( hourFormatParse( hourFormatRe, numberParser ) ) {\n\t\t\t\t\t\t\ttokenRe = hourFormatRe;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif ( !aux ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"X\":\n\n\t\t\t\t// Same as x*, except it uses \"Z\" for zero offset.\n\t\t\t\tif ( value === \"Z\" ) {\n\t\t\t\t\ttoken.value = 0;\n\t\t\t\t\ttokenRe = /^Z/;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"x\":\n\n\t\t\t\t// x: hourFormat(\"+HH[mm];-HH[mm]\")\n\t\t\t\t// xx: hourFormat(\"+HHmm;-HHmm\")\n\t\t\t\t// xxx: hourFormat(\"+HH:mm;-HH:mm\")\n\t\t\t\t// xxxx: hourFormat(\"+HHmm[ss];-HHmm[ss]\")\n\t\t\t\t// xxxxx: hourFormat(\"+HH:mm[:ss];-HH:mm[:ss]\")\n\t\t\t\taux = properties.x.some(function( hourFormatRe ) {\n\t\t\t\t\tif ( hourFormatParse( hourFormatRe ) ) {\n\t\t\t\t\t\ttokenRe = hourFormatRe;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif ( !aux ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"'\":\n\t\t\t\ttoken.type = \"literal\";\n\t\t\t\ttokenRe = new RegExp( \"^\" + regexpEscape( removeLiteralQuotes( current ) ) );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\ttoken.type = \"literal\";\n\t\t\t\ttokenRe = new RegExp( \"^\" + regexpEscape( current ) );\n\t\t}\n\n\t\tif ( !tokenRe ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Get lexeme and consume it.\n\t\tvalue = value.replace( tokenRe, function( lexeme ) {\n\t\t\ttoken.lexeme = lexeme;\n\t\t\tif ( numeric ) {\n\t\t\t\ttoken.value = numberParser( lexeme );\n\t\t\t}\n\t\t\treturn \"\";\n\t\t});\n\n\t\tif ( !token.lexeme ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( numeric && isNaN( token.value ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttokens.push( token );\n\t\treturn true;\n\t});\n\n\tif ( value !== \"\" ) {\n\t\tvalid = false;\n\t}\n\n\treturn valid ? tokens : [];\n};\n\n\n\n\nvar dateParserFn = function( numberParser, parseProperties, tokenizerProperties ) {\n\treturn function dateParser( value ) {\n\t\tvar tokens;\n\n\t\tvalidateParameterPresence( value, \"value\" );\n\t\tvalidateParameterTypeString( value, \"value\" );\n\n\t\ttokens = dateTokenizer( value, numberParser, tokenizerProperties );\n\t\treturn dateParse( value, tokens, parseProperties ) || null;\n\t};\n};\n\n\n\n\nvar objectFilter = function( object, testRe ) {\n\tvar key,\n\t\tcopy = {};\n\n\tfor ( key in object ) {\n\t\tif ( testRe.test( key ) ) {\n\t\t\tcopy[ key ] = object[ key ];\n\t\t}\n\t}\n\n\treturn copy;\n};\n\n\n\n\n/**\n * tokenizerProperties( pattern, cldr )\n *\n * @pattern [String] raw pattern.\n *\n * @cldr [Cldr instance].\n *\n * Return Object with data that will be used by tokenizer.\n */\nvar dateTokenizerProperties = function( pattern, cldr, timeZone ) {\n\tvar digitsReSource,\n\t\tproperties = {\n\t\t\tpattern: looseMatching( pattern )\n\t\t},\n\t\ttimeSeparator = numberSymbol( \"timeSeparator\", cldr ),\n\t\twidths = [ \"abbreviated\", \"wide\", \"narrow\" ];\n\n\tdigitsReSource = numberNumberingSystemDigitsMap( cldr );\n\tdigitsReSource = digitsReSource ? \"[\" + digitsReSource + \"]\" : \"\\\\d\";\n\tproperties.digitsRe = new RegExp( digitsReSource );\n\n\t// Transform:\n\t// - \"+H;-H\" -> /\\+(\\d\\d?)|-(\\d\\d?)/\n\t// - \"+HH;-HH\" -> /\\+(\\d\\d)|-(\\d\\d)/\n\t// - \"+HHmm;-HHmm\" -> /\\+(\\d\\d)(\\d\\d)|-(\\d\\d)(\\d\\d)/\n\t// - \"+HH:mm;-HH:mm\" -> /\\+(\\d\\d):(\\d\\d)|-(\\d\\d):(\\d\\d)/\n\t//\n\t// If gmtFormat is GMT{0}, the regexp must fill {0} in each side, e.g.:\n\t// - \"+H;-H\" -> /GMT\\+(\\d\\d?)|GMT-(\\d\\d?)/\n\tfunction hourFormatRe( hourFormat, gmtFormat, digitsReSource, timeSeparator ) {\n\t\tvar re;\n\n\t\tif ( !digitsReSource ) {\n\t\t\tdigitsReSource = \"\\\\d\";\n\t\t}\n\t\tif ( !gmtFormat ) {\n\t\t\tgmtFormat = \"{0}\";\n\t\t}\n\n\t\tre = hourFormat\n\t\t\t.replace( \"+\", \"\\\\+\" )\n\n\t\t\t// Unicode equivalent to (\\\\d\\\\d)\n\t\t\t.replace( /HH|mm|ss/g, \"((\" + digitsReSource + \"){2})\" )\n\n\t\t\t// Unicode equivalent to (\\\\d\\\\d?)\n\t\t\t.replace( /H|m/g, \"((\" + digitsReSource + \"){1,2})\" );\n\n\t\tif ( timeSeparator ) {\n\t\t\tre = re.replace( /:/g, timeSeparator );\n\t\t}\n\n\t\tre = re.split( \";\" ).map(function( part ) {\n\t\t\treturn gmtFormat.replace( \"{0}\", part );\n\t\t}).join( \"|\" );\n\n\t\treturn new RegExp( \"^\" + re );\n\t}\n\n\tfunction populateProperties( path, value ) {\n\n\t\t// Skip\n\t\tvar skipRe = /(timeZoneNames\\/zone|supplemental\\/metaZones|timeZoneNames\\/metazone|timeZoneNames\\/regionFormat|timeZoneNames\\/gmtFormat)/;\n\t\tif ( skipRe.test( path ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !value ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// The `dates` and `calendars` trim's purpose is to reduce properties' key size only.\n\t\tpath = path.replace( /^.*\\/dates\\//, \"\" ).replace( /calendars\\//, \"\" );\n\n\t\t// Specific filter for \"gregorian/dayPeriods/format/wide\".\n\t\tif ( path === \"gregorian/dayPeriods/format/wide\" ) {\n\t\t\tvalue = objectFilter( value, /^am|^pm/ );\n\t\t}\n\n\t\t// Transform object into array of pairs [key, /value/], sort by desc value length.\n\t\tif ( isPlainObject( value ) ) {\n\t\t\tvalue = Object.keys( value ).map(function( key ) {\n\t\t\t\treturn [ key, new RegExp( \"^\" + regexpEscape( looseMatching( value[ key ] ) ) ) ];\n\t\t\t}).sort(function( a, b ) {\n\t\t\t\treturn b[ 1 ].source.length - a[ 1 ].source.length;\n\t\t\t});\n\n\t\t// If typeof value === \"string\".\n\t\t} else {\n\t\t\tvalue = looseMatching( value );\n\t\t}\n\t\tproperties[ path ] = value;\n\t}\n\n\tfunction regexpSourceSomeTerm( terms ) {\n\t\treturn \"(\" + terms.filter(function( item ) {\n\t\t\treturn item;\n\t\t}).reduce(function( memo, item ) {\n\t\t\treturn memo + \"|\" + item;\n\t\t}) + \")\";\n\t}\n\n\tcldr.on( \"get\", populateProperties );\n\n\tpattern.match( datePatternRe ).forEach(function( current ) {\n\t\tvar aux, chr, daylightTzName, gmtFormat, length, standardTzName;\n\n\t\tchr = current.charAt( 0 );\n\t\tlength = current.length;\n\n\t\tif ( chr === \"Z\" ) {\n\t\t\tif ( length < 5 ) {\n\t\t\t\tchr = \"O\";\n\t\t\t\tlength = 4;\n\t\t\t} else {\n\t\t\t\tchr = \"X\";\n\t\t\t\tlength = 5;\n\t\t\t}\n\t\t}\n\n\t\t// z...zzz: \"{shortRegion}\", eg. \"PST\" or \"PDT\".\n\t\t// zzzz: \"{regionName} {Standard Time}\" or \"{regionName} {Daylight Time}\",\n\t\t//       e.g., \"Pacific Standard Time\" or \"Pacific Daylight Time\".\n\t\t// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\t\tif ( chr === \"z\" ) {\n\t\t\tstandardTzName = dateGetTimeZoneName( length, \"standard\", timeZone, cldr );\n\t\t\tdaylightTzName = dateGetTimeZoneName( length, \"daylight\", timeZone, cldr );\n\t\t\tif ( standardTzName ) {\n\t\t\t\tstandardTzName = regexpEscape( looseMatching( standardTzName ) );\n\t\t\t}\n\t\t\tif ( daylightTzName ) {\n\t\t\t\tdaylightTzName = regexpEscape( looseMatching( daylightTzName ) );\n\t\t\t}\n\t\t\tif ( standardTzName || daylightTzName ) {\n\t\t\t\tproperties.standardOrDaylightTzName = new RegExp(\n\t\t\t\t\t\"^\" + regexpSourceSomeTerm([ standardTzName, daylightTzName ])\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Fall through the \"O\" format in case one name is missing.\n\t\t\tif ( !standardTzName || !daylightTzName ) {\n\t\t\t\tchr = \"O\";\n\t\t\t\tif ( length < 4 ) {\n\t\t\t\t\tlength = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// v...vvv: \"{shortRegion}\", eg. \"PT\".\n\t\t// vvvv: \"{regionName} {Time}\" or \"{regionName} {Time}\",\n\t\t// e.g., \"Pacific Time\"\n\t\t// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\t\tif ( chr === \"v\" ) {\n\t\t\tif ( length !== 1 && length !== 4 ) {\n\t\t\t\tthrow createErrorUnsupportedFeature({\n\t\t\t\t\tfeature: \"timezone pattern `\" + pattern + \"`\"\n\t\t\t\t});\n\t\t\t}\n\t\t\tvar genericTzName = dateGetTimeZoneName( length, \"generic\", timeZone, cldr );\n\t\t\tif ( genericTzName ) {\n\t\t\t\tproperties.genericTzName = new RegExp(\n\t\t\t\t\t\"^\" + regexpEscape( looseMatching( genericTzName ) )\n\t\t\t\t);\n\t\t\t\tchr = \"O\";\n\n\t\t\t// Fall back to \"V\" format.\n\t\t\t} else {\n\t\t\t\tchr = \"V\";\n\t\t\t\tlength = 4;\n\t\t\t}\n\t\t}\n\n\t\tswitch ( chr ) {\n\n\t\t\t// Era\n\t\t\tcase \"G\":\n\t\t\t\tcldr.main([\n\t\t\t\t\t\"dates/calendars/gregorian/eras\",\n\t\t\t\t\tlength <= 3 ? \"eraAbbr\" : ( length === 4 ? \"eraNames\" : \"eraNarrow\" )\n\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Year\n\t\t\tcase \"u\": // Extended year. Need to be implemented.\n\t\t\tcase \"U\": // Cyclic year name. Need to be implemented.\n\t\t\t\tthrow createErrorUnsupportedFeature({\n\t\t\t\t\tfeature: \"year pattern `\" + chr + \"`\"\n\t\t\t\t});\n\n\t\t\t// Quarter\n\t\t\tcase \"Q\":\n\t\t\tcase \"q\":\n\t\t\t\tif ( length > 2 ) {\n\t\t\t\t\tcldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/quarters\",\n\t\t\t\t\t\tchr === \"Q\" ? \"format\" : \"stand-alone\",\n\t\t\t\t\t\twidths[ length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Month\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\n\t\t\t\t// number l=1:{1,2}, l=2:{2}.\n\t\t\t\t// lookup l=3...\n\t\t\t\tif ( length > 2 ) {\n\t\t\t\t\tcldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/months\",\n\t\t\t\t\t\tchr === \"M\" ? \"format\" : \"stand-alone\",\n\t\t\t\t\t\twidths[ length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Day\n\t\t\tcase \"g\":\n\n\t\t\t\t// Modified Julian day. Need to be implemented.\n\t\t\t\tthrow createErrorUnsupportedFeature({\n\t\t\t\t\tfeature: \"Julian day pattern `g`\"\n\t\t\t\t});\n\n\t\t\t// Week day\n\t\t\tcase \"e\":\n\t\t\tcase \"c\":\n\n\t\t\t\t// lookup for length >=3.\n\t\t\t\tif ( length <= 2 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"E\":\n\t\t\t\tif ( length === 6 ) {\n\n\t\t\t\t\t// Note: if short day names are not explicitly specified, abbreviated day\n\t\t\t\t\t// names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras\n\t\t\t\t\t// eslint-disable-next-line no-unused-expressions\n\t\t\t\t\tcldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/days\",\n\t\t\t\t\t\t[ chr === \"c\" ? \"stand-alone\" : \"format\" ],\n\t\t\t\t\t\t\"short\"\n\t\t\t\t\t]) || cldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/days\",\n\t\t\t\t\t\t[ chr === \"c\" ? \"stand-alone\" : \"format\" ],\n\t\t\t\t\t\t\"abbreviated\"\n\t\t\t\t\t]);\n\t\t\t\t} else {\n\t\t\t\t\tcldr.main([\n\t\t\t\t\t\t\"dates/calendars/gregorian/days\",\n\t\t\t\t\t\t[ chr === \"c\" ? \"stand-alone\" : \"format\" ],\n\t\t\t\t\t\twidths[ length < 3 ? 0 : length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Period (AM or PM)\n\t\t\tcase \"a\":\n\t\t\t\tcldr.main(\n\t\t\t\t\t\"dates/calendars/gregorian/dayPeriods/format/wide\"\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\t// Zone\n\t\t\tcase \"V\":\n\n\t\t\t\tif ( length === 1 ) {\n\t\t\t\t\tthrow createErrorUnsupportedFeature({\n\t\t\t\t\t\tfeature: \"timezone pattern `\" + pattern + \"`\"\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif ( timeZone ) {\n\t\t\t\t\tif ( length === 2 ) {\n\n\t\t\t\t\t\t// Skip looseMatching processing since timeZone is a canonical posix value.\n\t\t\t\t\t\tproperties.timeZoneName = timeZone;\n\t\t\t\t\t\tproperties.timeZoneNameRe = new RegExp( \"^\" + regexpEscape( timeZone ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar timeZoneName,\n\t\t\t\t\t\texemplarCity = cldr.main([\n\t\t\t\t\t\t\t\"dates/timeZoneNames/zone\", timeZone, \"exemplarCity\"\n\t\t\t\t\t\t]);\n\n\t\t\t\t\tif ( length === 3 ) {\n\t\t\t\t\t\tif ( !exemplarCity ) {\n\t\t\t\t\t\t\texemplarCity = cldr.main([\n\t\t\t\t\t\t\t\t\"dates/timeZoneNames/zone/Etc/Unknown/exemplarCity\"\n\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttimeZoneName = exemplarCity;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( exemplarCity && length === 4 ) {\n\t\t\t\t\t\ttimeZoneName = formatMessage(\n\t\t\t\t\t\t\tcldr.main(\n\t\t\t\t\t\t\t\t\"dates/timeZoneNames/regionFormat\"\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t[ exemplarCity ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( timeZoneName ) {\n\t\t\t\t\t\ttimeZoneName = looseMatching( timeZoneName );\n\t\t\t\t\t\tproperties.timeZoneName = timeZoneName;\n\t\t\t\t\t\tproperties.timeZoneNameRe = new RegExp(\n\t\t\t\t\t\t\t\"^\" + regexpEscape( timeZoneName )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( current === \"v\" ) {\n\t\t\t\t\tlength = 1;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"z\":\n\t\t\tcase \"O\":\n\t\t\t\tgmtFormat = cldr.main( \"dates/timeZoneNames/gmtFormat\" );\n\t\t\t\tcldr.main( \"dates/timeZoneNames/gmtZeroFormat\" );\n\t\t\t\tcldr.main( \"dates/timeZoneNames/hourFormat\" );\n\t\t\t\tproperties[ \"timeZoneNames/gmtZeroFormatRe\" ] =\n\t\t\t\t\tnew RegExp( \"^\" + regexpEscape( properties[ \"timeZoneNames/gmtZeroFormat\" ] ) );\n\t\t\t\taux = properties[ \"timeZoneNames/hourFormat\" ];\n\t\t\t\tproperties[ \"timeZoneNames/hourFormat\" ] = (\n\t\t\t\t\tlength < 4 ?\n\t\t\t\t\t\t[ dateTimezoneHourFormatHm( aux, \"H\" ), dateTimezoneHourFormatH( aux ) ] :\n\t\t\t\t\t\t[ dateTimezoneHourFormatHm( aux, \"HH\" ) ]\n\t\t\t\t).map(function( hourFormat ) {\n\t\t\t\t\treturn hourFormatRe(\n\t\t\t\t\t\thourFormat,\n\t\t\t\t\t\tgmtFormat,\n\t\t\t\t\t\tdigitsReSource,\n\t\t\t\t\t\ttimeSeparator\n\t\t\t\t\t);\n\t\t\t\t});\n\n\t\t\t/* falls through */\n\t\t\tcase \"X\":\n\t\t\tcase \"x\":\n\n\t\t\t\t// x: hourFormat(\"+HH[mm];-HH[mm]\")\n\t\t\t\t// xx: hourFormat(\"+HHmm;-HHmm\")\n\t\t\t\t// xxx: hourFormat(\"+HH:mm;-HH:mm\")\n\t\t\t\t// xxxx: hourFormat(\"+HHmm[ss];-HHmm[ss]\")\n\t\t\t\t// xxxxx: hourFormat(\"+HH:mm[:ss];-HH:mm[:ss]\")\n\t\t\t\tproperties.x = [\n\t\t\t\t\t[ \"+HHmm;-HHmm\", \"+HH;-HH\" ],\n\t\t\t\t\t[ \"+HHmm;-HHmm\" ],\n\t\t\t\t\t[ \"+HH:mm;-HH:mm\" ],\n\t\t\t\t\t[ \"+HHmmss;-HHmmss\", \"+HHmm;-HHmm\" ],\n\t\t\t\t\t[ \"+HH:mm:ss;-HH:mm:ss\", \"+HH:mm;-HH:mm\" ]\n\t\t\t\t][ length - 1 ].map(function( hourFormat ) {\n\t\t\t\t\treturn hourFormatRe( hourFormat );\n\t\t\t\t});\n\t\t}\n\t});\n\n\tcldr.off( \"get\", populateProperties );\n\n\treturn properties;\n};\n\n\n\n\n/**\n * dayOfWeek( date, firstDay )\n *\n * @date\n *\n * @firstDay the result of `dateFirstDayOfWeek( cldr )`\n *\n * Return the day of the week normalized by the territory's firstDay [0-6].\n * Eg for \"mon\":\n * - return 0 if territory is GB, or BR, or DE, or FR (week starts on \"mon\");\n * - return 1 if territory is US (week starts on \"sun\");\n * - return 2 if territory is EG (week starts on \"sat\");\n */\nvar dateDayOfWeek = function( date, firstDay ) {\n\treturn ( date.getDay() - firstDay + 7 ) % 7;\n};\n\n\n\n\n/**\n * distanceInDays( from, to )\n *\n * Return the distance in days between from and to Dates.\n */\nvar dateDistanceInDays = function( from, to ) {\n\tvar inDays = 864e5;\n\treturn ( to.getTime() - from.getTime() ) / inDays;\n};\n\n\n\n\n/**\n * dayOfYear\n *\n * Return the distance in days of the date to the begin of the year [0-d].\n */\nvar dateDayOfYear = function( date ) {\n\treturn Math.floor( dateDistanceInDays( dateStartOf( date, \"year\" ), date ) );\n};\n\n\n\n\n// Invert key and values, e.g., {\"year\": \"yY\"} ==> {\"y\": \"year\", \"Y\": \"year\"}\nvar dateFieldsMap = objectInvert({\n\t\"era\": \"G\",\n\t\"year\": \"yY\",\n\t\"quarter\": \"qQ\",\n\t\"month\": \"ML\",\n\t\"week\": \"wW\",\n\t\"day\": \"dDF\",\n\t\"weekday\": \"ecE\",\n\t\"dayperiod\": \"a\",\n\t\"hour\": \"hHkK\",\n\t\"minute\": \"m\",\n\t\"second\": \"sSA\",\n\t\"zone\": \"zvVOxX\"\n}, function( object, key, value ) {\n\tvalue.split( \"\" ).forEach(function( symbol ) {\n\t\tobject[ symbol ] = key;\n\t});\n\treturn object;\n});\n\n\n\n\n/**\n * millisecondsInDay\n */\nvar dateMillisecondsInDay = function( date ) {\n\n\t// TODO Handle daylight savings discontinuities\n\treturn date - dateStartOf( date, \"day\" );\n};\n\n\n\n\n/**\n * hourFormat( date, format, timeSeparator, formatNumber )\n *\n * Return date's timezone offset according to the format passed.\n * Eg for format when timezone offset is 180:\n * - \"+H;-H\": -3\n * - \"+HHmm;-HHmm\": -0300\n * - \"+HH:mm;-HH:mm\": -03:00\n * - \"+HH:mm:ss;-HH:mm:ss\": -03:00:00\n */\nvar dateTimezoneHourFormat = function( date, format, timeSeparator, formatNumber ) {\n\tvar absOffset,\n\t\toffset = date.getTimezoneOffset();\n\n\tabsOffset = Math.abs( offset );\n\tformatNumber = formatNumber || {\n\t\t1: function( value ) {\n\t\t\treturn stringPad( value, 1 );\n\t\t},\n\t\t2: function( value ) {\n\t\t\treturn stringPad( value, 2 );\n\t\t}\n\t};\n\n\treturn format\n\n\t\t// Pick the correct sign side (+ or -).\n\t\t.split( \";\" )[ offset > 0 ? 1 : 0 ]\n\n\t\t// Localize time separator\n\t\t.replace( \":\", timeSeparator )\n\n\t\t// Update hours offset.\n\t\t.replace( /HH?/, function( match ) {\n\t\t\treturn formatNumber[ match.length ]( Math.floor( absOffset / 60 ) );\n\t\t})\n\n\t\t// Update minutes offset and return.\n\t\t.replace( /mm/, function() {\n\t\t\treturn formatNumber[ 2 ]( Math.floor( absOffset % 60 ) );\n\t\t})\n\n\t\t// Update minutes offset and return.\n\t\t.replace( /ss/, function() {\n\t\t\treturn formatNumber[ 2 ]( Math.floor( absOffset % 1 * 60 ) );\n\t\t});\n};\n\n\n\n\n/**\n * format( date, properties )\n *\n * @date [Date instance].\n *\n * @properties\n *\n * TODO Support other calendar types.\n *\n * Disclosure: this function borrows excerpts of dojo/date/locale.\n */\nvar dateFormat = function( date, numberFormatters, properties ) {\n\tvar parts = [];\n\n\tvar timeSeparator = properties.timeSeparator;\n\n\t// create globalize date with given timezone data\n\tif ( properties.timeZoneData ) {\n\t\tdate = new ZonedDateTime( date, properties.timeZoneData() );\n\t}\n\n\tproperties.pattern.replace( datePatternRe, function( current ) {\n\t\tvar aux, dateField, type, value,\n\t\t\tchr = current.charAt( 0 ),\n\t\t\tlength = current.length;\n\n\t\tif ( chr === \"j\" ) {\n\n\t\t\t// Locale preferred hHKk.\n\t\t\t// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\n\t\t\tchr = properties.preferredTime;\n\t\t}\n\n\t\tif ( chr === \"Z\" ) {\n\n\t\t\t// Z..ZZZ: same as \"xxxx\".\n\t\t\tif ( length < 4 ) {\n\t\t\t\tchr = \"x\";\n\t\t\t\tlength = 4;\n\n\t\t\t// ZZZZ: same as \"OOOO\".\n\t\t\t} else if ( length < 5 ) {\n\t\t\t\tchr = \"O\";\n\t\t\t\tlength = 4;\n\n\t\t\t// ZZZZZ: same as \"XXXXX\"\n\t\t\t} else {\n\t\t\t\tchr = \"X\";\n\t\t\t\tlength = 5;\n\t\t\t}\n\t\t}\n\n\t\t// z...zzz: \"{shortRegion}\", e.g., \"PST\" or \"PDT\".\n\t\t// zzzz: \"{regionName} {Standard Time}\" or \"{regionName} {Daylight Time}\",\n\t\t//       e.g., \"Pacific Standard Time\" or \"Pacific Daylight Time\".\n\t\tif ( chr === \"z\" ) {\n\t\t\tif ( date.isDST ) {\n\t\t\t\tvalue = date.isDST() ? properties.daylightTzName : properties.standardTzName;\n\t\t\t}\n\n\t\t\t// Fall back to \"O\" format.\n\t\t\tif ( !value ) {\n\t\t\t\tchr = \"O\";\n\t\t\t\tif ( length < 4 ) {\n\t\t\t\t\tlength = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch ( chr ) {\n\n\t\t\t// Era\n\t\t\tcase \"G\":\n\t\t\t\tvalue = properties.eras[ date.getFullYear() < 0 ? 0 : 1 ];\n\t\t\t\tbreak;\n\n\t\t\t// Year\n\t\t\tcase \"y\":\n\n\t\t\t\t// Plain year.\n\t\t\t\t// The length specifies the padding, but for two letters it also specifies the\n\t\t\t\t// maximum length.\n\t\t\t\tvalue = date.getFullYear();\n\t\t\t\tif ( length === 2 ) {\n\t\t\t\t\tvalue = String( value );\n\t\t\t\t\tvalue = +value.substr( value.length - 2 );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"Y\":\n\n\t\t\t\t// Year in \"Week of Year\"\n\t\t\t\t// The length specifies the padding, but for two letters it also specifies the\n\t\t\t\t// maximum length.\n\t\t\t\t// yearInWeekofYear = date + DaysInAWeek - (dayOfWeek - firstDay) - minDays\n\t\t\t\tvalue = new Date( date.getTime() );\n\t\t\t\tvalue.setDate(\n\t\t\t\t\tvalue.getDate() + 7 -\n\t\t\t\t\tdateDayOfWeek( date, properties.firstDay ) -\n\t\t\t\t\tproperties.firstDay -\n\t\t\t\t\tproperties.minDays\n\t\t\t\t);\n\t\t\t\tvalue = value.getFullYear();\n\t\t\t\tif ( length === 2 ) {\n\t\t\t\t\tvalue = String( value );\n\t\t\t\t\tvalue = +value.substr( value.length - 2 );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Quarter\n\t\t\tcase \"Q\":\n\t\t\tcase \"q\":\n\t\t\t\tvalue = Math.ceil( ( date.getMonth() + 1 ) / 3 );\n\t\t\t\tif ( length > 2 ) {\n\t\t\t\t\tvalue = properties.quarters[ chr ][ length ][ value ];\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Month\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\t\t\t\tvalue = date.getMonth() + 1;\n\t\t\t\tif ( length > 2 ) {\n\t\t\t\t\tvalue = properties.months[ chr ][ length ][ value ];\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Week\n\t\t\tcase \"w\":\n\n\t\t\t\t// Week of Year.\n\t\t\t\t// woy = ceil( ( doy + dow of 1/1 ) / 7 ) - minDaysStuff ? 1 : 0.\n\t\t\t\t// TODO should pad on ww? Not documented, but I guess so.\n\t\t\t\tvalue = dateDayOfWeek( dateStartOf( date, \"year\" ), properties.firstDay );\n\t\t\t\tvalue = Math.ceil( ( dateDayOfYear( date ) + value ) / 7 ) -\n\t\t\t\t\t( 7 - value >= properties.minDays ? 0 : 1 );\n\t\t\t\tbreak;\n\n\t\t\tcase \"W\":\n\n\t\t\t\t// Week of Month.\n\t\t\t\t// wom = ceil( ( dom + dow of `1/month` ) / 7 ) - minDaysStuff ? 1 : 0.\n\t\t\t\tvalue = dateDayOfWeek( dateStartOf( date, \"month\" ), properties.firstDay );\n\t\t\t\tvalue = Math.ceil( ( date.getDate() + value ) / 7 ) -\n\t\t\t\t\t( 7 - value >= properties.minDays ? 0 : 1 );\n\t\t\t\tbreak;\n\n\t\t\t// Day\n\t\t\tcase \"d\":\n\t\t\t\tvalue = date.getDate();\n\t\t\t\tbreak;\n\n\t\t\tcase \"D\":\n\t\t\t\tvalue = dateDayOfYear( date ) + 1;\n\t\t\t\tbreak;\n\n\t\t\tcase \"F\":\n\n\t\t\t\t// Day of Week in month. eg. 2nd Wed in July.\n\t\t\t\tvalue = Math.floor( date.getDate() / 7 ) + 1;\n\t\t\t\tbreak;\n\n\t\t\t// Week day\n\t\t\tcase \"e\":\n\t\t\tcase \"c\":\n\t\t\t\tif ( length <= 2 ) {\n\n\t\t\t\t\t// Range is [1-7] (deduced by example provided on documentation)\n\t\t\t\t\t// TODO Should pad with zeros (not specified in the docs)?\n\t\t\t\t\tvalue = dateDayOfWeek( date, properties.firstDay ) + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"E\":\n\t\t\t\tvalue = dateWeekDays[ date.getDay() ];\n\t\t\t\tvalue = properties.days[ chr ][ length ][ value ];\n\t\t\t\tbreak;\n\n\t\t\t// Period (AM or PM)\n\t\t\tcase \"a\":\n\t\t\t\tvalue = properties.dayPeriods[ date.getHours() < 12 ? \"am\" : \"pm\" ];\n\t\t\t\tbreak;\n\n\t\t\t// Hour\n\t\t\tcase \"h\": // 1-12\n\t\t\t\tvalue = ( date.getHours() % 12 ) || 12;\n\t\t\t\tbreak;\n\n\t\t\tcase \"H\": // 0-23\n\t\t\t\tvalue = date.getHours();\n\t\t\t\tbreak;\n\n\t\t\tcase \"K\": // 0-11\n\t\t\t\tvalue = date.getHours() % 12;\n\t\t\t\tbreak;\n\n\t\t\tcase \"k\": // 1-24\n\t\t\t\tvalue = date.getHours() || 24;\n\t\t\t\tbreak;\n\n\t\t\t// Minute\n\t\t\tcase \"m\":\n\t\t\t\tvalue = date.getMinutes();\n\t\t\t\tbreak;\n\n\t\t\t// Second\n\t\t\tcase \"s\":\n\t\t\t\tvalue = date.getSeconds();\n\t\t\t\tbreak;\n\n\t\t\tcase \"S\":\n\t\t\t\tvalue = Math.round( date.getMilliseconds() * Math.pow( 10, length - 3 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase \"A\":\n\t\t\t\tvalue = Math.round( dateMillisecondsInDay( date ) * Math.pow( 10, length - 3 ) );\n\t\t\t\tbreak;\n\n\t\t\t// Zone\n\t\t\tcase \"z\":\n\t\t\t\tbreak;\n\n\t\t\tcase \"v\":\n\n\t\t\t\t// v...vvv: \"{shortRegion}\", eg. \"PT\".\n\t\t\t\t// vvvv: \"{regionName} {Time}\",\n\t\t\t\t//       e.g., \"Pacific Time\".\n\t\t\t\tif ( properties.genericTzName ) {\n\t\t\t\t\tvalue = properties.genericTzName;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"V\":\n\n\t\t\t\t//VVVV: \"{explarCity} {Time}\", e.g., \"Los Angeles Time\"\n\t\t\t\tif ( properties.timeZoneName ) {\n\t\t\t\t\tvalue = properties.timeZoneName;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( current === \"v\" ) {\n\t\t\t\t\tlength = 1;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"O\":\n\n\t\t\t\t// O: \"{gmtFormat}+H;{gmtFormat}-H\" or \"{gmtZeroFormat}\", eg. \"GMT-8\" or \"GMT\".\n\t\t\t\t// OOOO: \"{gmtFormat}{hourFormat}\" or \"{gmtZeroFormat}\", eg. \"GMT-08:00\" or \"GMT\".\n\t\t\t\tif ( date.getTimezoneOffset() === 0 ) {\n\t\t\t\t\tvalue = properties.gmtZeroFormat;\n\t\t\t\t} else {\n\n\t\t\t\t\t// If O..OOO and timezone offset has non-zero minutes, show minutes.\n\t\t\t\t\tif ( length < 4 ) {\n\t\t\t\t\t\taux = date.getTimezoneOffset();\n\t\t\t\t\t\taux = properties.hourFormat[ aux % 60 - aux % 1 === 0 ? 0 : 1 ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\taux = properties.hourFormat;\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = dateTimezoneHourFormat(\n\t\t\t\t\t\tdate,\n\t\t\t\t\t\taux,\n\t\t\t\t\t\ttimeSeparator,\n\t\t\t\t\t\tnumberFormatters\n\t\t\t\t\t);\n\t\t\t\t\tvalue = properties.gmtFormat.replace( /\\{0\\}/, value );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"X\":\n\n\t\t\t\t// Same as x*, except it uses \"Z\" for zero offset.\n\t\t\t\tif ( date.getTimezoneOffset() === 0 ) {\n\t\t\t\t\tvalue = \"Z\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"x\":\n\n\t\t\t\t// x: hourFormat(\"+HH[mm];-HH[mm]\")\n\t\t\t\t// xx: hourFormat(\"+HHmm;-HHmm\")\n\t\t\t\t// xxx: hourFormat(\"+HH:mm;-HH:mm\")\n\t\t\t\t// xxxx: hourFormat(\"+HHmm[ss];-HHmm[ss]\")\n\t\t\t\t// xxxxx: hourFormat(\"+HH:mm[:ss];-HH:mm[:ss]\")\n\t\t\t\taux = date.getTimezoneOffset();\n\n\t\t\t\t// If x and timezone offset has non-zero minutes, use xx (i.e., show minutes).\n\t\t\t\tif ( length === 1 && aux % 60 - aux % 1 !== 0 ) {\n\t\t\t\t\tlength += 1;\n\t\t\t\t}\n\n\t\t\t\t// If (xxxx or xxxxx) and timezone offset has zero seconds, use xx or xxx\n\t\t\t\t// respectively (i.e., don't show optional seconds).\n\t\t\t\tif ( ( length === 4 || length === 5 ) && aux % 1 === 0 ) {\n\t\t\t\t\tlength -= 2;\n\t\t\t\t}\n\n\t\t\t\tvalue = [\n\t\t\t\t\t\"+HH;-HH\",\n\t\t\t\t\t\"+HHmm;-HHmm\",\n\t\t\t\t\t\"+HH:mm;-HH:mm\",\n\t\t\t\t\t\"+HHmmss;-HHmmss\",\n\t\t\t\t\t\"+HH:mm:ss;-HH:mm:ss\"\n\t\t\t\t][ length - 1 ];\n\n\t\t\t\tvalue = dateTimezoneHourFormat( date, value, \":\" );\n\t\t\t\tbreak;\n\n\t\t\t// timeSeparator\n\t\t\tcase \":\":\n\t\t\t\tvalue = timeSeparator;\n\t\t\t\tbreak;\n\n\t\t\t// ' literals.\n\t\t\tcase \"'\":\n\t\t\t\tvalue = removeLiteralQuotes( current );\n\t\t\t\tbreak;\n\n\t\t\t// Anything else is considered a literal, including [ ,:/.@#], chinese, japonese, and\n\t\t\t// arabic characters.\n\t\t\tdefault:\n\t\t\t\tvalue = current;\n\n\t\t}\n\t\tif ( typeof value === \"number\" ) {\n\t\t\tvalue = numberFormatters[ length ]( value );\n\t\t}\n\n\t\tdateField = dateFieldsMap[ chr ];\n\t\ttype = dateField ? dateField : \"literal\";\n\n\t\tpartsPush( parts, type, value );\n\t});\n\n\treturn parts;\n\n};\n\n\n\n\nvar dateToPartsFormatterFn = function( numberFormatters, properties ) {\n\treturn function dateToPartsFormatter( value ) {\n\t\tvalidateParameterPresence( value, \"value\" );\n\t\tvalidateParameterTypeDate( value, \"value\" );\n\n\t\treturn dateFormat( value, numberFormatters, properties );\n\t};\n\n};\n\n\n\n\nfunction optionsHasStyle( options ) {\n\treturn options.skeleton !== undefined ||\n\t\toptions.date !== undefined ||\n\t\toptions.time !== undefined ||\n\t\toptions.datetime !== undefined ||\n\t\toptions.raw !== undefined;\n}\n\nfunction validateRequiredCldr( path, value ) {\n\tvalidateCldr( path, value, {\n\t\tskip: [\n\t\t\t/dates\\/calendars\\/gregorian\\/dateTimeFormats\\/availableFormats/,\n\t\t\t/dates\\/calendars\\/gregorian\\/days\\/.*\\/short/,\n\t\t\t/dates\\/timeZoneNames\\/zone/,\n\t\t\t/dates\\/timeZoneNames\\/metazone/,\n\t\t\t/globalize-iana/,\n\t\t\t/supplemental\\/metaZones/,\n\t\t\t/supplemental\\/timeData\\/(?!001)/,\n\t\t\t/supplemental\\/weekData\\/(?!001)/\n\t\t]\n\t});\n}\n\nfunction validateOptionsPreset( options ) {\n\tvalidateOptionsPresetEach( \"date\", options );\n\tvalidateOptionsPresetEach( \"time\", options );\n\tvalidateOptionsPresetEach( \"datetime\", options );\n}\n\nfunction validateOptionsPresetEach( type, options ) {\n\tvar value = options[ type ];\n\tvalidate(\n\t\t\"E_INVALID_OPTIONS\",\n\t\t\"Invalid `{{type}: \\\"{value}\\\"}`.\",\n\t\tvalue === undefined || [ \"short\", \"medium\", \"long\", \"full\" ].indexOf( value ) !== -1,\n\t\t{ type: type, value: value }\n\t);\n}\n\nfunction validateOptionsSkeleton( pattern, skeleton ) {\n\tvalidate(\n\t\t\"E_INVALID_OPTIONS\",\n\t\t\"Invalid `{skeleton: \\\"{value}\\\"}` based on provided CLDR.\",\n\t\tskeleton === undefined || ( typeof pattern === \"string\" && pattern ),\n\t\t{ type: \"skeleton\", value: skeleton }\n\t);\n}\n\nfunction validateRequiredIana( timeZone ) {\n\treturn function( path, value ) {\n\n\t\tif ( !/globalize-iana/.test( path ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvalidate(\n\t\t\t\"E_MISSING_IANA_TZ\",\n\t\t\t\"Missing required IANA timezone content for `{timeZone}`: `{path}`.\",\n\t\t\tvalue,\n\t\t\t{\n\t\t\t\tpath: path.replace( /globalize-iana\\//, \"\" ),\n\t\t\t\ttimeZone: timeZone\n\t\t\t}\n\t\t);\n\t};\n}\n\n/**\n * .loadTimeZone( json )\n *\n * @json [JSON]\n *\n * Load IANA timezone data.\n */\nGlobalize.loadTimeZone = function( json ) {\n\tvar customData = {\n\t\t\t\"globalize-iana\": json\n\t\t};\n\n\tvalidateParameterPresence( json, \"json\" );\n\tvalidateParameterTypePlainObject( json, \"json\" );\n\n\tCldr.load( customData );\n};\n\n/**\n * .dateFormatter( options )\n *\n * @options [Object] see date/expand_pattern for more info.\n *\n * Return a date formatter function (of the form below) according to the given options and the\n * default/instance locale.\n *\n * fn( value )\n *\n * @value [Date]\n *\n * Return a function that formats a date according to the given `format` and the default/instance\n * locale.\n */\nGlobalize.dateFormatter =\nGlobalize.prototype.dateFormatter = function( options ) {\n\tvar args, dateToPartsFormatter, returnFn;\n\n\tvalidateParameterTypePlainObject( options, \"options\" );\n\n\toptions = options || {};\n\tif ( !optionsHasStyle( options ) ) {\n\t\toptions.skeleton = \"yMd\";\n\t}\n\targs = [ options ];\n\n\tdateToPartsFormatter = this.dateToPartsFormatter( options );\n\treturnFn = dateFormatterFn( dateToPartsFormatter );\n\truntimeBind( args, this.cldr, returnFn, [ dateToPartsFormatter ] );\n\n\treturn returnFn;\n};\n\n/**\n * .dateToPartsFormatter( options )\n *\n * @options [Object] see date/expand_pattern for more info.\n *\n * Return a date formatter function (of the form below) according to the given options and the\n * default/instance locale.\n *\n * fn( value )\n *\n * @value [Date]\n *\n * Return a function that formats a date to parts according to the given `format`\n * and the default/instance\n * locale.\n */\nGlobalize.dateToPartsFormatter =\nGlobalize.prototype.dateToPartsFormatter = function( options ) {\n\tvar args, cldr, numberFormatters, pad, pattern, properties, returnFn,\n\t\ttimeZone, ianaListener;\n\n\tvalidateParameterTypePlainObject( options, \"options\" );\n\n\tcldr = this.cldr;\n\toptions = options || {};\n\tif ( !optionsHasStyle( options ) ) {\n\t\toptions.skeleton = \"yMd\";\n\t}\n\n\tvalidateOptionsPreset( options );\n\tvalidateDefaultLocale( cldr );\n\n\ttimeZone = options.timeZone;\n\tvalidateParameterTypeString( timeZone, \"options.timeZone\" );\n\n\targs = [ options ];\n\n\tcldr.on( \"get\", validateRequiredCldr );\n\tif ( timeZone ) {\n\t\tianaListener = validateRequiredIana( timeZone );\n\t\tcldr.on( \"get\", ianaListener );\n\t}\n\ttry {\n\t\tpattern = dateExpandPattern( options, cldr );\n\t\tvalidateOptionsSkeleton( pattern, options.skeleton );\n\t\tproperties = dateFormatProperties( pattern, cldr, timeZone );\n\t} finally {\n\t\tcldr.off( \"get\", validateRequiredCldr );\n\t\tif ( ianaListener ) {\n\t\t\tcldr.off( \"get\", ianaListener );\n\t\t}\n\t}\n\n\t// Create needed number formatters.\n\tnumberFormatters = properties.numberFormatters;\n\tdelete properties.numberFormatters;\n\tfor ( pad in numberFormatters ) {\n\t\tnumberFormatters[ pad ] = this.numberFormatter({\n\t\t\traw: numberFormatters[ pad ]\n\t\t});\n\t}\n\n\treturnFn = dateToPartsFormatterFn( numberFormatters, properties );\n\n\truntimeBind( args, cldr, returnFn, [ numberFormatters, properties ] );\n\n\treturn returnFn;\n};\n\n/**\n * .dateParser( options )\n *\n * @options [Object] see date/expand_pattern for more info.\n *\n * Return a function that parses a string date according to the given `formats` and the\n * default/instance locale.\n */\nGlobalize.dateParser =\nGlobalize.prototype.dateParser = function( options ) {\n\tvar args, cldr, numberParser, parseProperties, pattern, returnFn, timeZone,\n\t\ttokenizerProperties;\n\n\tvalidateParameterTypePlainObject( options, \"options\" );\n\n\tcldr = this.cldr;\n\toptions = options || {};\n\tif ( !optionsHasStyle( options ) ) {\n\t\toptions.skeleton = \"yMd\";\n\t}\n\n\tvalidateOptionsPreset( options );\n\tvalidateDefaultLocale( cldr );\n\n\ttimeZone = options.timeZone;\n\tvalidateParameterTypeString( timeZone, \"options.timeZone\" );\n\n\targs = [ options ];\n\n\ttry {\n\t\tcldr.on( \"get\", validateRequiredCldr );\n\t\tif ( timeZone ) {\n\t\t\tcldr.on( \"get\", validateRequiredIana( timeZone ) );\n\t\t}\n\t\tpattern = dateExpandPattern( options, cldr );\n\t\tvalidateOptionsSkeleton( pattern, options.skeleton );\n\t\ttokenizerProperties = dateTokenizerProperties( pattern, cldr, timeZone );\n\t\tparseProperties = dateParseProperties( cldr, timeZone );\n\t} finally {\n\t\tcldr.off( \"get\", validateRequiredCldr );\n\t\tif ( timeZone ) {\n\t\t\tcldr.off( \"get\", validateRequiredIana( timeZone ) );\n\t\t}\n\t}\n\tnumberParser = this.numberParser({ raw: \"0\" });\n\n\treturnFn = dateParserFn( numberParser, parseProperties, tokenizerProperties );\n\n\truntimeBind( args, cldr, returnFn, [ numberParser, parseProperties, tokenizerProperties ] );\n\n\treturn returnFn;\n};\n\n/**\n * .formatDate( value, options )\n *\n * @value [Date]\n *\n * @options [Object] see date/expand_pattern for more info.\n *\n * Formats a date or number according to the given options string and the default/instance locale.\n */\nGlobalize.formatDate =\nGlobalize.prototype.formatDate = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeDate( value, \"value\" );\n\n\treturn this.dateFormatter( options )( value );\n};\n\n/**\n * .formatDateToParts( value, options )\n *\n * @value [Date]\n *\n * @options [Object] see date/expand_pattern for more info.\n *\n * Formats a date or number to parts according to the given options and the default/instance locale.\n */\nGlobalize.formatDateToParts =\nGlobalize.prototype.formatDateToParts = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeDate( value, \"value\" );\n\n\treturn this.dateToPartsFormatter( options )( value );\n};\n\n/**\n * .parseDate( value, options )\n *\n * @value [String]\n *\n * @options [Object] see date/expand_pattern for more info.\n *\n * Return a Date instance or null.\n */\nGlobalize.parseDate =\nGlobalize.prototype.parseDate = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeString( value, \"value\" );\n\n\treturn this.dateParser( options )( value );\n};\n\nreturn Globalize;\n\n\n\n\n}));\n"]},"metadata":{},"sourceType":"script"}