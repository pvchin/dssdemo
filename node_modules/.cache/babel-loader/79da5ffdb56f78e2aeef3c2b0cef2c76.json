{"ast":null,"code":"/**\n * Globalize v1.7.0\n *\n * https://github.com/globalizejs/globalize\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2021-08-02T11:53Z\n */\n\n/*!\n * Globalize v1.7.0 2021-08-02T11:53Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function (root, factory) {\n  // UMD returnExports\n  if (typeof define === \"function\" && define.amd) {\n    // AMD\n    define([\"cldr\", \"../globalize\", \"cldr/event\"], factory);\n  } else if (typeof exports === \"object\") {\n    // Node, CommonJS\n    module.exports = factory(require(\"cldrjs\"), require(\"../globalize\"));\n  } else {\n    // Extend global\n    factory(root.Cldr, root.Globalize);\n  }\n})(this, function (Cldr, Globalize) {\n  var alwaysArray = Globalize._alwaysArray,\n      createError = Globalize._createError,\n      isPlainObject = Globalize._isPlainObject,\n      runtimeBind = Globalize._runtimeBind,\n      validateDefaultLocale = Globalize._validateDefaultLocale,\n      validate = Globalize._validate,\n      validateParameterPresence = Globalize._validateParameterPresence,\n      validateParameterType = Globalize._validateParameterType,\n      validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;\n  var MessageFormat;\n  /* eslint-disable */\n\n  MessageFormat = function () {\n    MessageFormat._parse = function () {\n      /*\n       * Generated by PEG.js 0.8.0.\n       *\n       * http://pegjs.majda.cz/\n       */\n      function peg$subclass(child, parent) {\n        function ctor() {\n          this.constructor = child;\n        }\n\n        ctor.prototype = parent.prototype;\n        child.prototype = new ctor();\n      }\n\n      function SyntaxError(message, expected, found, offset, line, column) {\n        this.message = message;\n        this.expected = expected;\n        this.found = found;\n        this.offset = offset;\n        this.line = line;\n        this.column = column;\n        this.name = \"SyntaxError\";\n      }\n\n      peg$subclass(SyntaxError, Error);\n\n      function parse(input) {\n        var options = arguments.length > 1 ? arguments[1] : {},\n            peg$FAILED = {},\n            peg$startRuleFunctions = {\n          start: peg$parsestart\n        },\n            peg$startRuleFunction = peg$parsestart,\n            peg$c0 = [],\n            peg$c1 = function (st) {\n          return {\n            type: 'messageFormatPattern',\n            statements: st\n          };\n        },\n            peg$c2 = peg$FAILED,\n            peg$c3 = \"{\",\n            peg$c4 = {\n          type: \"literal\",\n          value: \"{\",\n          description: \"\\\"{\\\"\"\n        },\n            peg$c5 = null,\n            peg$c6 = \",\",\n            peg$c7 = {\n          type: \"literal\",\n          value: \",\",\n          description: \"\\\",\\\"\"\n        },\n            peg$c8 = \"}\",\n            peg$c9 = {\n          type: \"literal\",\n          value: \"}\",\n          description: \"\\\"}\\\"\"\n        },\n            peg$c10 = function (argIdx, efmt) {\n          var res = {\n            type: \"messageFormatElement\",\n            argumentIndex: argIdx\n          };\n\n          if (efmt && efmt.length) {\n            res.elementFormat = efmt[1];\n          } else {\n            res.output = true;\n          }\n\n          return res;\n        },\n            peg$c11 = \"plural\",\n            peg$c12 = {\n          type: \"literal\",\n          value: \"plural\",\n          description: \"\\\"plural\\\"\"\n        },\n            peg$c13 = function (t, s) {\n          return {\n            type: \"elementFormat\",\n            key: t,\n            val: s\n          };\n        },\n            peg$c14 = \"selectordinal\",\n            peg$c15 = {\n          type: \"literal\",\n          value: \"selectordinal\",\n          description: \"\\\"selectordinal\\\"\"\n        },\n            peg$c16 = \"select\",\n            peg$c17 = {\n          type: \"literal\",\n          value: \"select\",\n          description: \"\\\"select\\\"\"\n        },\n            peg$c18 = function (t, p) {\n          return {\n            type: \"elementFormat\",\n            key: t,\n            val: p\n          };\n        },\n            peg$c19 = function (op, pf) {\n          return {\n            type: \"pluralFormatPattern\",\n            pluralForms: pf,\n            offset: op || 0\n          };\n        },\n            peg$c20 = \"offset\",\n            peg$c21 = {\n          type: \"literal\",\n          value: \"offset\",\n          description: \"\\\"offset\\\"\"\n        },\n            peg$c22 = \":\",\n            peg$c23 = {\n          type: \"literal\",\n          value: \":\",\n          description: \"\\\":\\\"\"\n        },\n            peg$c24 = function (d) {\n          return d;\n        },\n            peg$c25 = function (k, mfp) {\n          return {\n            key: k,\n            val: mfp\n          };\n        },\n            peg$c26 = function (i) {\n          return i;\n        },\n            peg$c27 = \"=\",\n            peg$c28 = {\n          type: \"literal\",\n          value: \"=\",\n          description: \"\\\"=\\\"\"\n        },\n            peg$c29 = function (pf) {\n          return {\n            type: \"selectFormatPattern\",\n            pluralForms: pf\n          };\n        },\n            peg$c30 = function (p) {\n          return p;\n        },\n            peg$c31 = \"#\",\n            peg$c32 = {\n          type: \"literal\",\n          value: \"#\",\n          description: \"\\\"#\\\"\"\n        },\n            peg$c33 = function () {\n          return {\n            type: 'octothorpe'\n          };\n        },\n            peg$c34 = function (s) {\n          return {\n            type: \"string\",\n            val: s.join('')\n          };\n        },\n            peg$c35 = {\n          type: \"other\",\n          description: \"identifier\"\n        },\n            peg$c36 = /^[0-9a-zA-Z$_]/,\n            peg$c37 = {\n          type: \"class\",\n          value: \"[0-9a-zA-Z$_]\",\n          description: \"[0-9a-zA-Z$_]\"\n        },\n            peg$c38 = /^[^ \\t\\n\\r,.+={}]/,\n            peg$c39 = {\n          type: \"class\",\n          value: \"[^ \\\\t\\\\n\\\\r,.+={}]\",\n          description: \"[^ \\\\t\\\\n\\\\r,.+={}]\"\n        },\n            peg$c40 = function (s) {\n          return s;\n        },\n            peg$c41 = function (chars) {\n          return chars.join('');\n        },\n            peg$c42 = /^[^{}#\\\\\\0-\\x1F \\t\\n\\r]/,\n            peg$c43 = {\n          type: \"class\",\n          value: \"[^{}#\\\\\\\\\\\\0-\\\\x1F \\\\t\\\\n\\\\r]\",\n          description: \"[^{}#\\\\\\\\\\\\0-\\\\x1F \\\\t\\\\n\\\\r]\"\n        },\n            peg$c44 = function (x) {\n          return x;\n        },\n            peg$c45 = \"\\\\\\\\\",\n            peg$c46 = {\n          type: \"literal\",\n          value: \"\\\\\\\\\",\n          description: \"\\\"\\\\\\\\\\\\\\\\\\\"\"\n        },\n            peg$c47 = function () {\n          return \"\\\\\";\n        },\n            peg$c48 = \"\\\\#\",\n            peg$c49 = {\n          type: \"literal\",\n          value: \"\\\\#\",\n          description: \"\\\"\\\\\\\\#\\\"\"\n        },\n            peg$c50 = function () {\n          return \"#\";\n        },\n            peg$c51 = \"\\\\{\",\n            peg$c52 = {\n          type: \"literal\",\n          value: \"\\\\{\",\n          description: \"\\\"\\\\\\\\{\\\"\"\n        },\n            peg$c53 = function () {\n          return \"\\u007B\";\n        },\n            peg$c54 = \"\\\\}\",\n            peg$c55 = {\n          type: \"literal\",\n          value: \"\\\\}\",\n          description: \"\\\"\\\\\\\\}\\\"\"\n        },\n            peg$c56 = function () {\n          return \"\\u007D\";\n        },\n            peg$c57 = \"\\\\u\",\n            peg$c58 = {\n          type: \"literal\",\n          value: \"\\\\u\",\n          description: \"\\\"\\\\\\\\u\\\"\"\n        },\n            peg$c59 = function (h1, h2, h3, h4) {\n          return String.fromCharCode(parseInt(\"0x\" + h1 + h2 + h3 + h4));\n        },\n            peg$c60 = /^[0-9]/,\n            peg$c61 = {\n          type: \"class\",\n          value: \"[0-9]\",\n          description: \"[0-9]\"\n        },\n            peg$c62 = function (ds) {\n          //the number might start with 0 but must not be interpreted as an octal number\n          //Hence, the base is passed to parseInt explicitely\n          return parseInt(ds.join(''), 10);\n        },\n            peg$c63 = /^[0-9a-fA-F]/,\n            peg$c64 = {\n          type: \"class\",\n          value: \"[0-9a-fA-F]\",\n          description: \"[0-9a-fA-F]\"\n        },\n            peg$c65 = {\n          type: \"other\",\n          description: \"whitespace\"\n        },\n            peg$c66 = function (w) {\n          return w.join('');\n        },\n            peg$c67 = /^[ \\t\\n\\r]/,\n            peg$c68 = {\n          type: \"class\",\n          value: \"[ \\\\t\\\\n\\\\r]\",\n          description: \"[ \\\\t\\\\n\\\\r]\"\n        },\n            peg$currPos = 0,\n            peg$reportedPos = 0,\n            peg$cachedPos = 0,\n            peg$cachedPosDetails = {\n          line: 1,\n          column: 1,\n          seenCR: false\n        },\n            peg$maxFailPos = 0,\n            peg$maxFailExpected = [],\n            peg$silentFails = 0,\n            peg$result;\n\n        if (\"startRule\" in options) {\n          if (!(options.startRule in peg$startRuleFunctions)) {\n            throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n          }\n\n          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n        }\n\n        function text() {\n          return input.substring(peg$reportedPos, peg$currPos);\n        }\n\n        function offset() {\n          return peg$reportedPos;\n        }\n\n        function line() {\n          return peg$computePosDetails(peg$reportedPos).line;\n        }\n\n        function column() {\n          return peg$computePosDetails(peg$reportedPos).column;\n        }\n\n        function expected(description) {\n          throw peg$buildException(null, [{\n            type: \"other\",\n            description: description\n          }], peg$reportedPos);\n        }\n\n        function error(message) {\n          throw peg$buildException(message, null, peg$reportedPos);\n        }\n\n        function peg$computePosDetails(pos) {\n          function advance(details, startPos, endPos) {\n            var p, ch;\n\n            for (p = startPos; p < endPos; p++) {\n              ch = input.charAt(p);\n\n              if (ch === \"\\n\") {\n                if (!details.seenCR) {\n                  details.line++;\n                }\n\n                details.column = 1;\n                details.seenCR = false;\n              } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n                details.line++;\n                details.column = 1;\n                details.seenCR = true;\n              } else {\n                details.column++;\n                details.seenCR = false;\n              }\n            }\n          }\n\n          if (peg$cachedPos !== pos) {\n            if (peg$cachedPos > pos) {\n              peg$cachedPos = 0;\n              peg$cachedPosDetails = {\n                line: 1,\n                column: 1,\n                seenCR: false\n              };\n            }\n\n            advance(peg$cachedPosDetails, peg$cachedPos, pos);\n            peg$cachedPos = pos;\n          }\n\n          return peg$cachedPosDetails;\n        }\n\n        function peg$fail(expected) {\n          if (peg$currPos < peg$maxFailPos) {\n            return;\n          }\n\n          if (peg$currPos > peg$maxFailPos) {\n            peg$maxFailPos = peg$currPos;\n            peg$maxFailExpected = [];\n          }\n\n          peg$maxFailExpected.push(expected);\n        }\n\n        function peg$buildException(message, expected, pos) {\n          function cleanupExpected(expected) {\n            var i = 1;\n            expected.sort(function (a, b) {\n              if (a.description < b.description) {\n                return -1;\n              } else if (a.description > b.description) {\n                return 1;\n              } else {\n                return 0;\n              }\n            });\n\n            while (i < expected.length) {\n              if (expected[i - 1] === expected[i]) {\n                expected.splice(i, 1);\n              } else {\n                i++;\n              }\n            }\n          }\n\n          function buildMessage(expected, found) {\n            function stringEscape(s) {\n              function hex(ch) {\n                return ch.charCodeAt(0).toString(16).toUpperCase();\n              }\n\n              return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\x08/g, '\\\\b').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\f/g, '\\\\f').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function (ch) {\n                return '\\\\x0' + hex(ch);\n              }).replace(/[\\x10-\\x1F\\x80-\\xFF]/g, function (ch) {\n                return '\\\\x' + hex(ch);\n              }).replace(/[\\u0180-\\u0FFF]/g, function (ch) {\n                return '\\\\u0' + hex(ch);\n              }).replace(/[\\u1080-\\uFFFF]/g, function (ch) {\n                return '\\\\u' + hex(ch);\n              });\n            }\n\n            var expectedDescs = new Array(expected.length),\n                expectedDesc,\n                foundDesc,\n                i;\n\n            for (i = 0; i < expected.length; i++) {\n              expectedDescs[i] = expected[i].description;\n            }\n\n            expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(\", \") + \" or \" + expectedDescs[expected.length - 1] : expectedDescs[0];\n            foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n            return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n          }\n\n          var posDetails = peg$computePosDetails(pos),\n              found = pos < input.length ? input.charAt(pos) : null;\n\n          if (expected !== null) {\n            cleanupExpected(expected);\n          }\n\n          return new SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);\n        }\n\n        function peg$parsestart() {\n          var s0;\n          s0 = peg$parsemessageFormatPattern();\n          return s0;\n        }\n\n        function peg$parsemessageFormatPattern() {\n          var s0, s1, s2;\n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parsemessageFormatElement();\n\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsestring();\n\n            if (s2 === peg$FAILED) {\n              s2 = peg$parseoctothorpe();\n            }\n          }\n\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parsemessageFormatElement();\n\n            if (s2 === peg$FAILED) {\n              s2 = peg$parsestring();\n\n              if (s2 === peg$FAILED) {\n                s2 = peg$parseoctothorpe();\n              }\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c1(s1);\n          }\n\n          s0 = s1;\n          return s0;\n        }\n\n        function peg$parsemessageFormatElement() {\n          var s0, s1, s2, s3, s4, s5, s6;\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 123) {\n            s1 = peg$c3;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c4);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseid();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s5 = peg$c6;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$c7);\n                  }\n                }\n\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parseelementFormat();\n\n                  if (s6 !== peg$FAILED) {\n                    s5 = [s5, s6];\n                    s4 = s5;\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$c2;\n                }\n\n                if (s4 === peg$FAILED) {\n                  s4 = peg$c5;\n                }\n\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parse_();\n\n                  if (s5 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 125) {\n                      s6 = peg$c8;\n                      peg$currPos++;\n                    } else {\n                      s6 = peg$FAILED;\n\n                      if (peg$silentFails === 0) {\n                        peg$fail(peg$c9);\n                      }\n                    }\n\n                    if (s6 !== peg$FAILED) {\n                      peg$reportedPos = s0;\n                      s1 = peg$c10(s3, s4);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n\n          return s0;\n        }\n\n        function peg$parseelementFormat() {\n          var s0, s1, s2, s3, s4, s5, s6, s7;\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 6) === peg$c11) {\n              s2 = peg$c11;\n              peg$currPos += 6;\n            } else {\n              s2 = peg$FAILED;\n\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c12);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s4 = peg$c6;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$c7);\n                  }\n                }\n\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parse_();\n\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parsepluralFormatPattern();\n\n                    if (s6 !== peg$FAILED) {\n                      s7 = peg$parse_();\n\n                      if (s7 !== peg$FAILED) {\n                        peg$reportedPos = s0;\n                        s1 = peg$c13(s2, s6);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parse_();\n\n            if (s1 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 13) === peg$c14) {\n                s2 = peg$c14;\n                peg$currPos += 13;\n              } else {\n                s2 = peg$FAILED;\n\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c15);\n                }\n              }\n\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parse_();\n\n                if (s3 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 44) {\n                    s4 = peg$c6;\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n\n                    if (peg$silentFails === 0) {\n                      peg$fail(peg$c7);\n                    }\n                  }\n\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parse_();\n\n                    if (s5 !== peg$FAILED) {\n                      s6 = peg$parsepluralFormatPattern();\n\n                      if (s6 !== peg$FAILED) {\n                        s7 = peg$parse_();\n\n                        if (s7 !== peg$FAILED) {\n                          peg$reportedPos = s0;\n                          s1 = peg$c13(s2, s6);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c2;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parse_();\n\n              if (s1 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 6) === peg$c16) {\n                  s2 = peg$c16;\n                  peg$currPos += 6;\n                } else {\n                  s2 = peg$FAILED;\n\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$c17);\n                  }\n                }\n\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$parse_();\n\n                  if (s3 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 44) {\n                      s4 = peg$c6;\n                      peg$currPos++;\n                    } else {\n                      s4 = peg$FAILED;\n\n                      if (peg$silentFails === 0) {\n                        peg$fail(peg$c7);\n                      }\n                    }\n\n                    if (s4 !== peg$FAILED) {\n                      s5 = peg$parse_();\n\n                      if (s5 !== peg$FAILED) {\n                        s6 = peg$parseselectFormatPattern();\n\n                        if (s6 !== peg$FAILED) {\n                          s7 = peg$parse_();\n\n                          if (s7 !== peg$FAILED) {\n                            peg$reportedPos = s0;\n                            s1 = peg$c13(s2, s6);\n                            s0 = s1;\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c2;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c2;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$parse_();\n\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$parseid();\n\n                  if (s2 !== peg$FAILED) {\n                    s3 = [];\n                    s4 = peg$parseargStylePattern();\n\n                    while (s4 !== peg$FAILED) {\n                      s3.push(s4);\n                      s4 = peg$parseargStylePattern();\n                    }\n\n                    if (s3 !== peg$FAILED) {\n                      peg$reportedPos = s0;\n                      s1 = peg$c18(s2, s3);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              }\n            }\n          }\n\n          return s0;\n        }\n\n        function peg$parsepluralFormatPattern() {\n          var s0, s1, s2, s3;\n          s0 = peg$currPos;\n          s1 = peg$parseoffsetPattern();\n\n          if (s1 === peg$FAILED) {\n            s1 = peg$c5;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsepluralForm();\n\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$parsepluralForm();\n              }\n            } else {\n              s2 = peg$c2;\n            }\n\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c19(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n\n          return s0;\n        }\n\n        function peg$parseoffsetPattern() {\n          var s0, s1, s2, s3, s4, s5, s6, s7;\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 6) === peg$c20) {\n              s2 = peg$c20;\n              peg$currPos += 6;\n            } else {\n              s2 = peg$FAILED;\n\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c21);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 58) {\n                  s4 = peg$c22;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$c23);\n                  }\n                }\n\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parse_();\n\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parsedigits();\n\n                    if (s6 !== peg$FAILED) {\n                      s7 = peg$parse_();\n\n                      if (s7 !== peg$FAILED) {\n                        peg$reportedPos = s0;\n                        s1 = peg$c24(s6);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n\n          return s0;\n        }\n\n        function peg$parsepluralForm() {\n          var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsepluralKey();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 123) {\n                  s4 = peg$c3;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$c4);\n                  }\n                }\n\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parse_();\n\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parsemessageFormatPattern();\n\n                    if (s6 !== peg$FAILED) {\n                      s7 = peg$parse_();\n\n                      if (s7 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 125) {\n                          s8 = peg$c8;\n                          peg$currPos++;\n                        } else {\n                          s8 = peg$FAILED;\n\n                          if (peg$silentFails === 0) {\n                            peg$fail(peg$c9);\n                          }\n                        }\n\n                        if (s8 !== peg$FAILED) {\n                          peg$reportedPos = s0;\n                          s1 = peg$c25(s2, s6);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c2;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n\n          return s0;\n        }\n\n        function peg$parsepluralKey() {\n          var s0, s1, s2;\n          s0 = peg$currPos;\n          s1 = peg$parseid();\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c26(s1);\n          }\n\n          s0 = s1;\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n\n            if (input.charCodeAt(peg$currPos) === 61) {\n              s1 = peg$c27;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c28);\n              }\n            }\n\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parsedigits();\n\n              if (s2 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c24(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          }\n\n          return s0;\n        }\n\n        function peg$parseselectFormatPattern() {\n          var s0, s1, s2;\n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parseselectForm();\n\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              s2 = peg$parseselectForm();\n            }\n          } else {\n            s1 = peg$c2;\n          }\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c29(s1);\n          }\n\n          s0 = s1;\n          return s0;\n        }\n\n        function peg$parseselectForm() {\n          var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseid();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 123) {\n                  s4 = peg$c3;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$c4);\n                  }\n                }\n\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parse_();\n\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parsemessageFormatPattern();\n\n                    if (s6 !== peg$FAILED) {\n                      s7 = peg$parse_();\n\n                      if (s7 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 125) {\n                          s8 = peg$c8;\n                          peg$currPos++;\n                        } else {\n                          s8 = peg$FAILED;\n\n                          if (peg$silentFails === 0) {\n                            peg$fail(peg$c9);\n                          }\n                        }\n\n                        if (s8 !== peg$FAILED) {\n                          peg$reportedPos = s0;\n                          s1 = peg$c25(s2, s6);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c2;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n\n          return s0;\n        }\n\n        function peg$parseargStylePattern() {\n          var s0, s1, s2, s3, s4, s5;\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s2 = peg$c6;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c7);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parseid();\n\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parse_();\n\n                  if (s5 !== peg$FAILED) {\n                    peg$reportedPos = s0;\n                    s1 = peg$c30(s4);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n\n          return s0;\n        }\n\n        function peg$parseoctothorpe() {\n          var s0, s1;\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 35) {\n            s1 = peg$c31;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c32);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c33();\n          }\n\n          s0 = s1;\n          return s0;\n        }\n\n        function peg$parsestring() {\n          var s0, s1, s2;\n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parsechars();\n\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsewhitespace();\n          }\n\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              s2 = peg$parsechars();\n\n              if (s2 === peg$FAILED) {\n                s2 = peg$parsewhitespace();\n              }\n            }\n          } else {\n            s1 = peg$c2;\n          }\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c34(s1);\n          }\n\n          s0 = s1;\n          return s0;\n        }\n\n        function peg$parseid() {\n          var s0, s1, s2, s3, s4, s5, s6;\n          peg$silentFails++;\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$currPos;\n\n            if (peg$c36.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c37);\n              }\n            }\n\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n\n              if (peg$c38.test(input.charAt(peg$currPos))) {\n                s6 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c39);\n                }\n              }\n\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n\n                if (peg$c38.test(input.charAt(peg$currPos))) {\n                  s6 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$c39);\n                  }\n                }\n              }\n\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$c2;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c2;\n            }\n\n            if (s3 !== peg$FAILED) {\n              s3 = input.substring(s2, peg$currPos);\n            }\n\n            s2 = s3;\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c40(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n\n          peg$silentFails--;\n\n          if (s0 === peg$FAILED) {\n            s1 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c35);\n            }\n          }\n\n          return s0;\n        }\n\n        function peg$parsechars() {\n          var s0, s1, s2;\n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parsechar();\n\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              s2 = peg$parsechar();\n            }\n          } else {\n            s1 = peg$c2;\n          }\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c41(s1);\n          }\n\n          s0 = s1;\n          return s0;\n        }\n\n        function peg$parsechar() {\n          var s0, s1, s2, s3, s4, s5;\n          s0 = peg$currPos;\n\n          if (peg$c42.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c43);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c44(s1);\n          }\n\n          s0 = s1;\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n\n            if (input.substr(peg$currPos, 2) === peg$c45) {\n              s1 = peg$c45;\n              peg$currPos += 2;\n            } else {\n              s1 = peg$FAILED;\n\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c46);\n              }\n            }\n\n            if (s1 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c47();\n            }\n\n            s0 = s1;\n\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n\n              if (input.substr(peg$currPos, 2) === peg$c48) {\n                s1 = peg$c48;\n                peg$currPos += 2;\n              } else {\n                s1 = peg$FAILED;\n\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c49);\n                }\n              }\n\n              if (s1 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c50();\n              }\n\n              s0 = s1;\n\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n\n                if (input.substr(peg$currPos, 2) === peg$c51) {\n                  s1 = peg$c51;\n                  peg$currPos += 2;\n                } else {\n                  s1 = peg$FAILED;\n\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$c52);\n                  }\n                }\n\n                if (s1 !== peg$FAILED) {\n                  peg$reportedPos = s0;\n                  s1 = peg$c53();\n                }\n\n                s0 = s1;\n\n                if (s0 === peg$FAILED) {\n                  s0 = peg$currPos;\n\n                  if (input.substr(peg$currPos, 2) === peg$c54) {\n                    s1 = peg$c54;\n                    peg$currPos += 2;\n                  } else {\n                    s1 = peg$FAILED;\n\n                    if (peg$silentFails === 0) {\n                      peg$fail(peg$c55);\n                    }\n                  }\n\n                  if (s1 !== peg$FAILED) {\n                    peg$reportedPos = s0;\n                    s1 = peg$c56();\n                  }\n\n                  s0 = s1;\n\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$currPos;\n\n                    if (input.substr(peg$currPos, 2) === peg$c57) {\n                      s1 = peg$c57;\n                      peg$currPos += 2;\n                    } else {\n                      s1 = peg$FAILED;\n\n                      if (peg$silentFails === 0) {\n                        peg$fail(peg$c58);\n                      }\n                    }\n\n                    if (s1 !== peg$FAILED) {\n                      s2 = peg$parsehexDigit();\n\n                      if (s2 !== peg$FAILED) {\n                        s3 = peg$parsehexDigit();\n\n                        if (s3 !== peg$FAILED) {\n                          s4 = peg$parsehexDigit();\n\n                          if (s4 !== peg$FAILED) {\n                            s5 = peg$parsehexDigit();\n\n                            if (s5 !== peg$FAILED) {\n                              peg$reportedPos = s0;\n                              s1 = peg$c59(s2, s3, s4, s5);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$c2;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c2;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c2;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          return s0;\n        }\n\n        function peg$parsedigits() {\n          var s0, s1, s2;\n          s0 = peg$currPos;\n          s1 = [];\n\n          if (peg$c60.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c61);\n            }\n          }\n\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c61);\n                }\n              }\n            }\n          } else {\n            s1 = peg$c2;\n          }\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c62(s1);\n          }\n\n          s0 = s1;\n          return s0;\n        }\n\n        function peg$parsehexDigit() {\n          var s0;\n\n          if (peg$c63.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c64);\n            }\n          }\n\n          return s0;\n        }\n\n        function peg$parse_() {\n          var s0, s1, s2;\n          peg$silentFails++;\n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parsewhitespace();\n\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parsewhitespace();\n          }\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c66(s1);\n          }\n\n          s0 = s1;\n          peg$silentFails--;\n\n          if (s0 === peg$FAILED) {\n            s1 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c65);\n            }\n          }\n\n          return s0;\n        }\n\n        function peg$parsewhitespace() {\n          var s0;\n\n          if (peg$c67.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c68);\n            }\n          }\n\n          return s0;\n        }\n\n        peg$result = peg$startRuleFunction();\n\n        if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n          return peg$result;\n        } else {\n          if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n            peg$fail({\n              type: \"end\",\n              description: \"end of input\"\n            });\n          }\n\n          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n        }\n      }\n\n      return {\n        SyntaxError: SyntaxError,\n        parse: parse\n      };\n    }().parse;\n    /** @file messageformat.js - ICU PluralFormat + SelectFormat for JavaScript\n     *  @author Alex Sexton - @SlexAxton\n     *  @version 0.3.0-1\n     *  @copyright 2012-2015 Alex Sexton, Eemeli Aro, and Contributors\n     *  @license To use or fork, MIT. To contribute back, Dojo CLA  */\n\n    /** Utility function for quoting an Object's key value iff required\n     *  @private  */\n\n\n    function propname(key, obj) {\n      if (/^[A-Z_$][0-9A-Z_$]*$/i.test(key)) {\n        return obj ? obj + '.' + key : key;\n      } else {\n        var jkey = JSON.stringify(key);\n        return obj ? obj + '[' + jkey + ']' : jkey;\n      }\n    }\n\n    ;\n    /** Create a new message formatter\n     *\n     *  @class\n     *  @global\n     *  @param {string|string[]} [locale=\"en\"] - The locale to use, with fallbacks\n     *  @param {function} [pluralFunc] - Optional custom pluralization function\n     *  @param {function[]} [formatters] - Optional custom formatting functions  */\n\n    function MessageFormat(locale, pluralFunc, formatters) {\n      this.lc = [locale];\n      this.runtime.pluralFuncs = {};\n      this.runtime.pluralFuncs[this.lc[0]] = pluralFunc;\n      this.runtime.fmt = {};\n      if (formatters) for (var f in formatters) {\n        this.runtime.fmt[f] = formatters[f];\n      }\n    }\n    /** Parse an input string to its AST\n     *\n     *  Precompiled from `lib/messageformat-parser.pegjs` by\n     *  {@link http://pegjs.org/ PEG.js}. Included in MessageFormat object\n     *  to enable testing.\n     *\n     *  @private  */\n\n    /** Pluralization functions from\n     *  {@link http://github.com/eemeli/make-plural.js make-plural}\n     *\n     *  @memberof MessageFormat\n     *  @type Object.<string,function>  */\n\n\n    MessageFormat.plurals = {};\n    /** Default number formatting functions in the style of ICU's\n     *  {@link http://icu-project.org/apiref/icu4j/com/ibm/icu/text/MessageFormat.html simpleArg syntax}\n     *  implemented using the\n     *  {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl Intl}\n     *  object defined by ECMA-402.\n     *\n     *  **Note**: Intl is not defined in default Node until 0.11.15 / 0.12.0, so\n     *  earlier versions require a {@link https://www.npmjs.com/package/intl polyfill}.\n     *  Therefore {@link MessageFormat.withIntlSupport} needs to be true for these\n     *  functions to be available for inclusion in the output.\n     *\n     *  @see MessageFormat#setIntlSupport\n     *\n     *  @namespace\n     *  @memberof MessageFormat\n     *  @property {function} number - Represent a number as an integer, percent or currency value\n     *  @property {function} date - Represent a date as a full/long/default/short string\n     *  @property {function} time - Represent a time as a full/long/default/short string\n     *\n     *  @example\n     *  > var MessageFormat = require('messageformat');\n     *  > var mf = (new MessageFormat('en')).setIntlSupport(true);\n     *  > mf.currency = 'EUR';\n     *  > var mfunc = mf.compile(\"The total is {V,number,currency}.\");\n     *  > mfunc({V:5.5})\n     *  \"The total is 5.50.\"\n     *\n     *  @example\n     *  > var MessageFormat = require('messageformat');\n     *  > var mf = new MessageFormat('en', null, {number: MessageFormat.number});\n     *  > mf.currency = 'EUR';\n     *  > var mfunc = mf.compile(\"The total is {V,number,currency}.\");\n     *  > mfunc({V:5.5})\n     *  \"The total is 5.50.\"  */\n\n    MessageFormat.formatters = {};\n    /** Enable or disable support for the default formatters, which require the\n     *  `Intl` object. Note that this can't be autodetected, as the environment\n     *  in which the formatted text is compiled into Javascript functions is not\n     *  necessarily the same environment in which they will get executed.\n     *\n     *  @see MessageFormat.formatters\n     *\n     *  @memberof MessageFormat\n     *  @param {boolean} [enable=true]\n     *  @returns {Object} The MessageFormat instance, to allow for chaining\n     *  @example\n     *  > var Intl = require('intl');\n     *  > var MessageFormat = require('messageformat');\n     *  > var mf = (new MessageFormat('en')).setIntlSupport(true);\n     *  > mf.currency = 'EUR';\n     *  > mf.compile(\"The total is {V,number,currency}.\")({V:5.5});\n     *  \"The total is 5.50.\"  */\n\n    /** A set of utility functions that are called by the compiled Javascript\n     *  functions, these are included locally in the output of {@link\n     *  MessageFormat#compile compile()}.\n     *\n     *  @namespace\n     *  @memberof MessageFormat  */\n\n    MessageFormat.prototype.runtime = {\n      /** Utility function for `#` in plural rules\n       *\n       *  @param {number} value - The value to operate on\n       *  @param {number} [offset=0] - An optional offset, set by the surrounding context  */\n      number: function (value, offset) {\n        if (isNaN(value)) throw new Error(\"'\" + value + \"' isn't a number.\");\n        return value - (offset || 0);\n      },\n\n      /** Utility function for `{N, plural|selectordinal, ...}`\n       *\n       *  @param {number} value - The key to use to find a pluralization rule\n       *  @param {number} offset - An offset to apply to `value`\n       *  @param {function} lcfunc - A locale function from `pluralFuncs`\n       *  @param {Object.<string,string>} data - The object from which results are looked up\n       *  @param {?boolean} isOrdinal - If true, use ordinal rather than cardinal rules\n       *  @returns {string} The result of the pluralization  */\n      plural: function (value, offset, lcfunc, data, isOrdinal) {\n        if ({}.hasOwnProperty.call(data, value)) return data[value]();\n        if (offset) value -= offset;\n        var key = lcfunc(value, isOrdinal);\n        if (key in data) return data[key]();\n        return data.other();\n      },\n\n      /** Utility function for `{N, select, ...}`\n       *\n       *  @param {number} value - The key to use to find a selection\n       *  @param {Object.<string,string>} data - The object from which results are looked up\n       *  @returns {string} The result of the select statement  */\n      select: function (value, data) {\n        if ({}.hasOwnProperty.call(data, value)) return data[value]();\n        return data.other();\n      },\n\n      /** Pluralization functions included in compiled output\n       *  @instance\n       *  @type Object.<string,function>  */\n      pluralFuncs: {},\n\n      /** Custom formatting functions called by `{var, fn[, args]*}` syntax\n       *\n       *  For examples, see {@link MessageFormat.formatters}\n       *\n       *  @instance\n       *  @see MessageFormat.formatters\n       *  @type Object.<string,function>  */\n      fmt: {},\n\n      /** Custom stringifier to clean up browser inconsistencies\n       *  @instance  */\n      toString: function () {\n        var _stringify = function (o, level) {\n          if (typeof o != 'object') {\n            var funcStr = o.toString().replace(/^(function )\\w*/, '$1');\n            var indent = /([ \\t]*)\\S.*$/.exec(funcStr);\n            return indent ? funcStr.replace(new RegExp('^' + indent[1], 'mg'), '') : funcStr;\n          }\n\n          var s = [];\n\n          for (var i in o) if (i != 'toString') {\n            if (level == 0) s.push('var ' + i + ' = ' + _stringify(o[i], level + 1) + ';\\n');else s.push(propname(i) + ': ' + _stringify(o[i], level + 1));\n          }\n\n          if (level == 0) return s.join('');\n          if (s.length == 0) return '{}';\n          var indent = '  ';\n\n          while (--level) indent += '  ';\n\n          return '{\\n' + s.join(',\\n').replace(/^/gm, indent) + '\\n}';\n        };\n\n        return _stringify(this, 0);\n      }\n    };\n    /** Recursively map an AST to its resulting string\n     *\n     *  @memberof MessageFormat\n     *\n     *  @param ast - the Ast node for which the JS code should be generated\n     *\n     *  @private  */\n\n    MessageFormat.prototype._precompile = function (ast, data) {\n      data = data || {\n        keys: {},\n        offset: {}\n      };\n      var r = [],\n          i,\n          tmp,\n          args = [];\n\n      switch (ast.type) {\n        case 'messageFormatPattern':\n          for (i = 0; i < ast.statements.length; ++i) {\n            r.push(this._precompile(ast.statements[i], data));\n          }\n\n          tmp = r.join(' + ') || '\"\"';\n          return data.pf_count ? tmp : 'function(d) { return ' + tmp + '; }';\n\n        case 'messageFormatElement':\n          data.pf_count = data.pf_count || 0;\n\n          if (ast.output) {\n            return propname(ast.argumentIndex, 'd');\n          } else {\n            data.keys[data.pf_count] = ast.argumentIndex;\n            return this._precompile(ast.elementFormat, data);\n          }\n\n          return '';\n\n        case 'elementFormat':\n          args = [propname(data.keys[data.pf_count], 'd')];\n\n          switch (ast.key) {\n            case 'select':\n              args.push(this._precompile(ast.val, data));\n              return 'select(' + args.join(', ') + ')';\n\n            case 'selectordinal':\n              args = args.concat([0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data), 1]);\n              return 'plural(' + args.join(', ') + ')';\n\n            case 'plural':\n              data.offset[data.pf_count || 0] = ast.val.offset || 0;\n              args = args.concat([data.offset[data.pf_count] || 0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data)]);\n              return 'plural(' + args.join(', ') + ')';\n\n            default:\n              if (this.withIntlSupport && !(ast.key in this.runtime.fmt) && ast.key in MessageFormat.formatters) {\n                tmp = MessageFormat.formatters[ast.key];\n                this.runtime.fmt[ast.key] = typeof tmp(this) == 'function' ? tmp(this) : tmp;\n              }\n\n              args.push(JSON.stringify(this.lc));\n              if (ast.val && ast.val.length) args.push(JSON.stringify(ast.val.length == 1 ? ast.val[0] : ast.val));\n              return 'fmt.' + ast.key + '(' + args.join(', ') + ')';\n          }\n\n        case 'pluralFormatPattern':\n        case 'selectFormatPattern':\n          data.pf_count = data.pf_count || 0;\n          if (ast.type == 'selectFormatPattern') data.offset[data.pf_count] = 0;\n          var needOther = true;\n\n          for (i = 0; i < ast.pluralForms.length; ++i) {\n            var key = ast.pluralForms[i].key;\n            if (key === 'other') needOther = false;\n            var data_copy = JSON.parse(JSON.stringify(data));\n            data_copy.pf_count++;\n            r.push(propname(key) + ': function() { return ' + this._precompile(ast.pluralForms[i].val, data_copy) + ';}');\n          }\n\n          if (needOther) throw new Error(\"No 'other' form found in \" + ast.type + \" \" + data.pf_count);\n          return '{ ' + r.join(', ') + ' }';\n\n        case 'string':\n          return JSON.stringify(ast.val || \"\");\n\n        case 'octothorpe':\n          if (!data.pf_count) return '\"#\"';\n          args = [propname(data.keys[data.pf_count - 1], 'd')];\n          if (data.offset[data.pf_count - 1]) args.push(data.offset[data.pf_count - 1]);\n          return 'number(' + args.join(', ') + ')';\n\n        default:\n          throw new Error('Bad AST type: ' + ast.type);\n      }\n    };\n    /** Compile messages into an executable function with clean string\n     *  representation.\n     *\n     *  If `messages` is a single string including ICU MessageFormat declarations,\n     *  `opt` is ignored and the returned function takes a single Object parameter\n     *  `d` representing each of the input's defined variables. The returned\n     *  function will be defined in a local scope that includes all the required\n     *  runtime variables.\n     *\n     *  If `messages` is a map of keys to strings, or a map of namespace keys to\n     *  such key/string maps, the returned function will fill the specified global\n     *  with javascript functions matching the structure of the input. In such use,\n     *  the output of `compile()` is expected to be serialized using `.toString()`,\n     *  and will include definitions of the runtime functions. If `opt.global` is\n     *  null, calling the output function will return the object itself.\n     *\n     *  Together, the input parameters should match the following patterns:\n     *  ```js\n     *  messages = \"string\" || { key0: \"string0\", key1: \"string1\", ... } || {\n     *    ns0: { key0: \"string0\", key1: \"string1\", ...  },\n     *    ns1: { key0: \"string0\", key1: \"string1\", ...  },\n     *    ...\n     *  }\n     *\n     *  opt = null || {\n     *    locale: null || {\n     *      ns0: \"lc0\" || [ \"lc0\", ... ],\n     *      ns1: \"lc1\" || [ \"lc1\", ... ],\n     *      ...\n     *    },\n     *    global: null || \"module.exports\" || \"exports\" || \"i18n\" || ...\n     *  }\n     *  ```\n     *\n     *  @memberof MessageFormat\n     *  @param {string|Object}\n     *      messages - The input message(s) to be compiled, in ICU MessageFormat\n     *  @param {Object} [opt={}] - Options controlling output for non-simple intput\n     *  @param {Object} [opt.locale] - The locales to use for the messages, with a\n     *      structure matching that of `messages`\n     *  @param {string} [opt.global=\"\"] - The global variable that the output\n     *      function should use, or a null string for none. \"exports\" and\n     *      \"module.exports\" are recognised as special cases.\n     *  @returns {function} The first match found for the given locale(s)\n     *\n     *  @example\n     * > var MessageFormat = require('messageformat'),\n     * ...   mf = new MessageFormat('en'),\n     * ...   mfunc0 = mf.compile('A {TYPE} example.');\n     * > mfunc0({TYPE:'simple'})\n     * 'A simple example.'\n     * > mfunc0.toString()\n     * 'function (d) { return \"A \" + d.TYPE + \" example.\"; }'\n     *\n     *  @example\n     * > var msgSet = { a: 'A {TYPE} example.',\n     * ...              b: 'This has {COUNT, plural, one{one member} other{# members}}.' },\n     * ...   mfuncSet = mf.compile(msgSet);\n     * > mfuncSet().a({TYPE:'more complex'})\n     * 'A more complex example.'\n     * > mfuncSet().b({COUNT:2})\n     * 'This has 2 members.'\n     *\n     * > console.log(mfuncSet.toString())\n     * function anonymous() {\n     * var number = function (value, offset) {\n     *   if (isNaN(value)) throw new Error(\"'\" + value + \"' isn't a number.\");\n     *   return value - (offset || 0);\n     * };\n     * var plural = function (value, offset, lcfunc, data, isOrdinal) {\n     *   if ({}.hasOwnProperty.call(data, value)) return data[value]();\n     *   if (offset) value -= offset;\n     *   var key = lcfunc(value, isOrdinal);\n     *   if (key in data) return data[key]();\n     *   return data.other();\n     * };\n     * var select = function (value, data) {\n     *   if ({}.hasOwnProperty.call(data, value)) return data[value]();\n     *   return data.other()\n     * };\n     * var pluralFuncs = {\n     *   en: function (n, ord) {\n     *     var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,\n     *         n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);\n     *     if (ord) return (n10 == 1 && n100 != 11) ? 'one'\n     *         : (n10 == 2 && n100 != 12) ? 'two'\n     *         : (n10 == 3 && n100 != 13) ? 'few'\n     *         : 'other';\n     *     return (n == 1 && v0) ? 'one' : 'other';\n     *   }\n     * };\n     * var fmt = {};\n     *\n     * return {\n     *   a: function(d) { return \"A \" + d.TYPE + \" example.\"; },\n     *   b: function(d) { return \"This has \" + plural(d.COUNT, 0, pluralFuncs.en, { one: function() { return \"one member\";}, other: function() { return number(d.COUNT)+\" members\";} }) + \".\"; }\n     * }\n     * }\n     *\n     *  @example\n     * > mf.runtime.pluralFuncs.fi = MessageFormat.plurals.fi;\n     * > var multiSet = { en: { a: 'A {TYPE} example.',\n     * ...                      b: 'This is the {COUNT, selectordinal, one{#st} two{#nd} few{#rd} other{#th}} example.' },\n     * ...                fi: { a: '{TYPE} esimerkki.',\n     * ...                      b: 'Tm on {COUNT, selectordinal, other{#.}} esimerkki.' } },\n     * ...   multiSetLocales = { en: 'en', fi: 'fi' },\n     * ...   mfuncSet = mf.compile(multiSet, { locale: multiSetLocales, global: 'i18n' });\n     * > mfuncSet(this);\n     * > i18n.en.b({COUNT:3})\n     * 'This is the 3rd example.'\n     * > i18n.fi.b({COUNT:3})\n     * 'Tm on 3. esimerkki.'  */\n\n\n    MessageFormat.prototype.compile = function (messages, opt) {\n      var r = {},\n          lc0 = this.lc,\n          compileMsg = function (self, msg) {\n        try {\n          var ast = MessageFormat._parse(msg);\n\n          return self._precompile(ast);\n        } catch (e) {\n          throw new Error((ast ? 'Precompiler' : 'Parser') + ' error: ' + e.toString());\n        }\n      },\n          stringify = function (r, level) {\n        if (!level) level = 0;\n        if (typeof r != 'object') return r;\n        var o = [],\n            indent = '';\n\n        for (var i = 0; i < level; ++i) indent += '  ';\n\n        for (var k in r) o.push('\\n' + indent + '  ' + propname(k) + ': ' + stringify(r[k], level + 1));\n\n        return '{' + o.join(',') + '\\n' + indent + '}';\n      };\n\n      if (typeof messages == 'string') {\n        var f = new Function('number, plural, select, pluralFuncs, fmt', 'return ' + compileMsg(this, messages));\n        return f(this.runtime.number, this.runtime.plural, this.runtime.select, this.runtime.pluralFuncs, this.runtime.fmt);\n      }\n\n      opt = opt || {};\n\n      for (var ns in messages) {\n        if (opt.locale) this.lc = opt.locale[ns] && [].concat(opt.locale[ns]) || lc0;\n\n        if (typeof messages[ns] == 'string') {\n          try {\n            r[ns] = compileMsg(this, messages[ns]);\n          } catch (e) {\n            e.message = e.message.replace(':', ' with `' + ns + '`:');\n            throw e;\n          }\n        } else {\n          r[ns] = {};\n\n          for (var key in messages[ns]) {\n            try {\n              r[ns][key] = compileMsg(this, messages[ns][key]);\n            } catch (e) {\n              e.message = e.message.replace(':', ' with `' + key + '` in `' + ns + '`:');\n              throw e;\n            }\n          }\n        }\n      }\n\n      this.lc = lc0;\n      var s = this.runtime.toString() + '\\n';\n\n      switch (opt.global || '') {\n        case 'exports':\n          var o = [];\n\n          for (var k in r) o.push(propname(k, 'exports') + ' = ' + stringify(r[k]));\n\n          return new Function(s + o.join(';\\n'));\n\n        case 'module.exports':\n          return new Function(s + 'module.exports = ' + stringify(r));\n\n        case '':\n          return new Function(s + 'return ' + stringify(r));\n\n        default:\n          return new Function('G', s + propname(opt.global, 'G') + ' = ' + stringify(r));\n      }\n    };\n\n    return MessageFormat;\n  }();\n  /* eslint-enable */\n\n\n  var createErrorPluralModulePresence = function () {\n    return createError(\"E_MISSING_PLURAL_MODULE\", \"Plural module not loaded.\");\n  };\n\n  var validateMessageBundle = function (cldr) {\n    validate(\"E_MISSING_MESSAGE_BUNDLE\", \"Missing message bundle for locale `{locale}`.\", cldr.attributes.bundle && cldr.get(\"globalize-messages/{bundle}\") !== undefined, {\n      locale: cldr.locale\n    });\n  };\n\n  var validateMessagePresence = function (path, value) {\n    path = path.join(\"/\");\n    validate(\"E_MISSING_MESSAGE\", \"Missing required message content `{path}`.\", value !== undefined, {\n      path: path\n    });\n  };\n\n  var validateMessageType = function (path, value) {\n    path = path.join(\"/\");\n    validate(\"E_INVALID_MESSAGE\", \"Invalid message content `{path}`. {expected} expected.\", typeof value === \"string\", {\n      expected: \"a string\",\n      path: path\n    });\n  };\n\n  var validateParameterTypeMessageVariables = function (value, name) {\n    validateParameterType(value, name, value === undefined || isPlainObject(value) || Array.isArray(value), \"Array or Plain Object\");\n  };\n\n  var messageFormatterFn = function (formatter) {\n    return function messageFormatter(variables) {\n      if (typeof variables === \"number\" || typeof variables === \"string\") {\n        variables = [].slice.call(arguments, 0);\n      }\n\n      validateParameterTypeMessageVariables(variables, \"variables\");\n      return formatter(variables);\n    };\n  };\n\n  var messageFormatterRuntimeBind = function (cldr, messageformatter) {\n    var locale = cldr.locale,\n        origToString = messageformatter.toString;\n\n    messageformatter.toString = function () {\n      var argNames,\n          argValues,\n          output,\n          args = {}; // Properly adjust SlexAxton/messageformat.js compiled variables with Globalize variables:\n\n      output = origToString.call(messageformatter);\n\n      if (/number\\(/.test(output)) {\n        args.number = \"messageFormat.number\";\n      }\n\n      if (/plural\\(/.test(output)) {\n        args.plural = \"messageFormat.plural\";\n      }\n\n      if (/select\\(/.test(output)) {\n        args.select = \"messageFormat.select\";\n      }\n\n      output.replace(/pluralFuncs(\\[([^\\]]+)\\]|\\.([a-zA-Z]+))/, function (match) {\n        args.pluralFuncs = \"{\" + \"\\\"\" + locale + \"\\\": Globalize(\\\"\" + locale + \"\\\").pluralGenerator()\" + \"}\";\n        return match;\n      });\n      argNames = Object.keys(args).join(\", \");\n      argValues = Object.keys(args).map(function (key) {\n        return args[key];\n      }).join(\", \");\n      return \"(function( \" + argNames + \" ) {\\n\" + \"  return \" + output + \"\\n\" + \"})(\" + argValues + \")\";\n    };\n\n    return messageformatter;\n  };\n\n  var slice = [].slice;\n  /**\n   * .loadMessages( json )\n   *\n   * @json [JSON]\n   *\n   * Load translation data.\n   */\n\n  Globalize.loadMessages = function (json) {\n    var locale,\n        customData = {\n      \"globalize-messages\": json,\n      \"main\": {}\n    };\n    validateParameterPresence(json, \"json\");\n    validateParameterTypePlainObject(json, \"json\"); // Set available bundles by populating customData main dataset.\n\n    for (locale in json) {\n      if (json.hasOwnProperty(locale)) {\n        customData.main[locale] = {};\n      }\n    }\n\n    Cldr.load(customData);\n  };\n  /**\n   * .messageFormatter( path )\n   *\n   * @path [String or Array]\n   *\n   * Format a message given its path.\n   */\n\n\n  Globalize.messageFormatter = Globalize.prototype.messageFormatter = function (path) {\n    var cldr,\n        formatter,\n        message,\n        pluralGenerator,\n        returnFn,\n        args = slice.call(arguments, 0);\n    validateParameterPresence(path, \"path\");\n    validateParameterType(path, \"path\", typeof path === \"string\" || Array.isArray(path), \"a String nor an Array\");\n    path = alwaysArray(path);\n    cldr = this.cldr;\n    validateDefaultLocale(cldr);\n    validateMessageBundle(cldr);\n    message = cldr.get([\"globalize-messages/{bundle}\"].concat(path));\n    validateMessagePresence(path, message); // If message is an Array, concatenate it.\n\n    if (Array.isArray(message)) {\n      message = message.join(\" \");\n    }\n\n    validateMessageType(path, message); // Is plural module present? Yes, use its generator. Nope, use an error generator.\n\n    pluralGenerator = this.plural !== undefined ? this.pluralGenerator() : createErrorPluralModulePresence;\n    formatter = new MessageFormat(cldr.locale, pluralGenerator).compile(message);\n    returnFn = messageFormatterFn(formatter);\n    runtimeBind(args, cldr, returnFn, [messageFormatterRuntimeBind(cldr, formatter), pluralGenerator]);\n    return returnFn;\n  };\n  /**\n   * .formatMessage( path [, variables] )\n   *\n   * @path [String or Array]\n   *\n   * @variables [Number, String, Array or Object]\n   *\n   * Format a message given its path.\n   */\n\n\n  Globalize.formatMessage = Globalize.prototype.formatMessage = function (path\n  /* , variables */\n  ) {\n    return this.messageFormatter(path).apply({}, slice.call(arguments, 1));\n  };\n\n  return Globalize;\n});","map":{"version":3,"sources":["D:/react-myprojects/hrms-airtable/node_modules/globalize/dist/globalize/message.js"],"names":["root","factory","define","amd","exports","module","require","Cldr","Globalize","alwaysArray","_alwaysArray","createError","_createError","isPlainObject","_isPlainObject","runtimeBind","_runtimeBind","validateDefaultLocale","_validateDefaultLocale","validate","_validate","validateParameterPresence","_validateParameterPresence","validateParameterType","_validateParameterType","validateParameterTypePlainObject","_validateParameterTypePlainObject","MessageFormat","_parse","peg$subclass","child","parent","ctor","constructor","prototype","SyntaxError","message","expected","found","offset","line","column","name","Error","parse","input","options","arguments","length","peg$FAILED","peg$startRuleFunctions","start","peg$parsestart","peg$startRuleFunction","peg$c0","peg$c1","st","type","statements","peg$c2","peg$c3","peg$c4","value","description","peg$c5","peg$c6","peg$c7","peg$c8","peg$c9","peg$c10","argIdx","efmt","res","argumentIndex","elementFormat","output","peg$c11","peg$c12","peg$c13","t","s","key","val","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","p","peg$c19","op","pf","pluralForms","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","d","peg$c25","k","mfp","peg$c26","i","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","join","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","chars","peg$c42","peg$c43","peg$c44","x","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$c54","peg$c55","peg$c56","peg$c57","peg$c58","peg$c59","h1","h2","h3","h4","String","fromCharCode","parseInt","peg$c60","peg$c61","peg$c62","ds","peg$c63","peg$c64","peg$c65","peg$c66","w","peg$c67","peg$c68","peg$currPos","peg$reportedPos","peg$cachedPos","peg$cachedPosDetails","seenCR","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","peg$result","startRule","text","substring","peg$computePosDetails","peg$buildException","error","pos","advance","details","startPos","endPos","ch","charAt","peg$fail","push","cleanupExpected","sort","a","b","splice","buildMessage","stringEscape","hex","charCodeAt","toString","toUpperCase","replace","expectedDescs","Array","expectedDesc","foundDesc","slice","posDetails","s0","peg$parsemessageFormatPattern","s1","s2","peg$parsemessageFormatElement","peg$parsestring","peg$parseoctothorpe","s3","s4","s5","s6","peg$parse_","peg$parseid","peg$parseelementFormat","s7","substr","peg$parsepluralFormatPattern","peg$parseselectFormatPattern","peg$parseargStylePattern","peg$parseoffsetPattern","peg$parsepluralForm","peg$parsedigits","s8","peg$parsepluralKey","peg$parseselectForm","peg$parsechars","peg$parsewhitespace","test","peg$parsechar","peg$parsehexDigit","propname","obj","jkey","JSON","stringify","locale","pluralFunc","formatters","lc","runtime","pluralFuncs","fmt","f","plurals","number","isNaN","plural","lcfunc","data","isOrdinal","hasOwnProperty","call","other","select","_stringify","o","level","funcStr","indent","exec","RegExp","_precompile","ast","keys","r","tmp","args","pf_count","concat","withIntlSupport","needOther","data_copy","compile","messages","opt","lc0","compileMsg","self","msg","e","Function","ns","global","createErrorPluralModulePresence","validateMessageBundle","cldr","attributes","bundle","get","undefined","validateMessagePresence","path","validateMessageType","validateParameterTypeMessageVariables","isArray","messageFormatterFn","formatter","messageFormatter","variables","messageFormatterRuntimeBind","messageformatter","origToString","argNames","argValues","match","Object","map","loadMessages","json","customData","main","load","pluralGenerator","returnFn","formatMessage","apply"],"mappings":"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,CAAC7M,IAAlC,GAAyC,GAAzC,GAA+C+L,IAAI,CAACmB,QAA9D,CAAN;AACf,iBAAO,OAAOH,CAAC,CAACxJ,IAAF,CAAO,IAAP,CAAP,GAAsB,IAA7B;;AAEF,aAAK,QAAL;AACE,iBAAOyH,IAAI,CAACC,SAAL,CAAe4B,GAAG,CAACpL,GAAJ,IAAW,EAA1B,CAAP;;AAEF,aAAK,YAAL;AACE,cAAI,CAACsK,IAAI,CAACmB,QAAV,EAAoB,OAAO,KAAP;AACpBD,UAAAA,IAAI,GAAG,CAAEpC,QAAQ,CAACkB,IAAI,CAACe,IAAL,CAAUf,IAAI,CAACmB,QAAL,GAAc,CAAxB,CAAD,EAA6B,GAA7B,CAAV,CAAP;AACA,cAAInB,IAAI,CAACjN,MAAL,CAAYiN,IAAI,CAACmB,QAAL,GAAc,CAA1B,CAAJ,EAAkCD,IAAI,CAACrF,IAAL,CAAUmE,IAAI,CAACjN,MAAL,CAAYiN,IAAI,CAACmB,QAAL,GAAc,CAA1B,CAAV;AAClC,iBAAO,YAAYD,IAAI,CAAC1J,IAAL,CAAU,IAAV,CAAZ,GAA8B,GAArC;;AAEF;AACE,gBAAM,IAAIrE,KAAJ,CAAW,mBAAmB2N,GAAG,CAAC7M,IAAlC,CAAN;AAnEJ;AAqED,KAzED;AA2EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA9B,IAAAA,aAAa,CAACO,SAAd,CAAwB8O,OAAxB,GAAkC,UAAWC,QAAX,EAAqBC,GAArB,EAA2B;AAC3D,UAAIV,CAAC,GAAG,EAAR;AAAA,UAAYW,GAAG,GAAG,KAAKrC,EAAvB;AAAA,UACIsC,UAAU,GAAG,UAASC,IAAT,EAAeC,GAAf,EAAoB;AAC/B,YAAI;AACF,cAAIhB,GAAG,GAAG3O,aAAa,CAACC,MAAd,CAAqB0P,GAArB,CAAV;;AACA,iBAAOD,IAAI,CAAChB,WAAL,CAAiBC,GAAjB,CAAP;AACD,SAHD,CAGE,OAAOiB,CAAP,EAAU;AACV,gBAAM,IAAI5O,KAAJ,CAAU,CAAC2N,GAAG,GAAG,aAAH,GAAmB,QAAvB,IAAmC,UAAnC,GAAgDiB,CAAC,CAACxF,QAAF,EAA1D,CAAN;AACD;AACF,OARL;AAAA,UASI2C,SAAS,GAAG,UAAS8B,CAAT,EAAYR,KAAZ,EAAmB;AAC7B,YAAI,CAACA,KAAL,EAAYA,KAAK,GAAG,CAAR;AACZ,YAAI,OAAOQ,CAAP,IAAY,QAAhB,EAA0B,OAAOA,CAAP;AAC1B,YAAIT,CAAC,GAAG,EAAR;AAAA,YAAYG,MAAM,GAAG,EAArB;;AACA,aAAK,IAAI3J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyJ,KAApB,EAA2B,EAAEzJ,CAA7B,EAAgC2J,MAAM,IAAI,IAAV;;AAChC,aAAK,IAAI9J,CAAT,IAAcoK,CAAd,EAAiBT,CAAC,CAAC1E,IAAF,CAAO,OAAO6E,MAAP,GAAgB,IAAhB,GAAuB5B,QAAQ,CAAClI,CAAD,CAA/B,GAAqC,IAArC,GAA4CsI,SAAS,CAAC8B,CAAC,CAACpK,CAAD,CAAF,EAAO4J,KAAK,GAAG,CAAf,CAA5D;;AACjB,eAAO,MAAMD,CAAC,CAAC/I,IAAF,CAAO,GAAP,CAAN,GAAoB,IAApB,GAA2BkJ,MAA3B,GAAoC,GAA3C;AACD,OAhBL;;AAkBA,UAAI,OAAOe,QAAP,IAAmB,QAAvB,EAAiC;AAC/B,YAAI/B,CAAC,GAAG,IAAIsC,QAAJ,CACJ,0CADI,EAEJ,YAAYJ,UAAU,CAAC,IAAD,EAAOH,QAAP,CAFlB,CAAR;AAGA,eAAO/B,CAAC,CAAC,KAAKH,OAAL,CAAaK,MAAd,EAAsB,KAAKL,OAAL,CAAaO,MAAnC,EAA2C,KAAKP,OAAL,CAAac,MAAxD,EACJ,KAAKd,OAAL,CAAaC,WADT,EACsB,KAAKD,OAAL,CAAaE,GADnC,CAAR;AAED;;AAEDiC,MAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;;AAEA,WAAK,IAAIO,EAAT,IAAeR,QAAf,EAAyB;AACvB,YAAIC,GAAG,CAACvC,MAAR,EAAgB,KAAKG,EAAL,GAAUoC,GAAG,CAACvC,MAAJ,CAAW8C,EAAX,KAAkB,GAAGb,MAAH,CAAUM,GAAG,CAACvC,MAAJ,CAAW8C,EAAX,CAAV,CAAlB,IAA+CN,GAAzD;;AAChB,YAAI,OAAOF,QAAQ,CAACQ,EAAD,CAAf,IAAuB,QAA3B,EAAqC;AACnC,cAAI;AAAEjB,YAAAA,CAAC,CAACiB,EAAD,CAAD,GAAQL,UAAU,CAAC,IAAD,EAAOH,QAAQ,CAACQ,EAAD,CAAf,CAAlB;AAAyC,WAA/C,CACA,OAAOF,CAAP,EAAU;AAAEA,YAAAA,CAAC,CAACnP,OAAF,GAAYmP,CAAC,CAACnP,OAAF,CAAU6J,OAAV,CAAkB,GAAlB,EAAuB,YAAYwF,EAAZ,GAAiB,IAAxC,CAAZ;AAA2D,kBAAMF,CAAN;AAAU;AAClF,SAHD,MAGO;AACLf,UAAAA,CAAC,CAACiB,EAAD,CAAD,GAAQ,EAAR;;AACA,eAAK,IAAIxM,GAAT,IAAgBgM,QAAQ,CAACQ,EAAD,CAAxB,EAA8B;AAC5B,gBAAI;AAAEjB,cAAAA,CAAC,CAACiB,EAAD,CAAD,CAAMxM,GAAN,IAAamM,UAAU,CAAC,IAAD,EAAOH,QAAQ,CAACQ,EAAD,CAAR,CAAaxM,GAAb,CAAP,CAAvB;AAAmD,aAAzD,CACA,OAAOsM,CAAP,EAAU;AAAEA,cAAAA,CAAC,CAACnP,OAAF,GAAYmP,CAAC,CAACnP,OAAF,CAAU6J,OAAV,CAAkB,GAAlB,EAAuB,YAAYhH,GAAZ,GAAkB,QAAlB,GAA6BwM,EAA7B,GAAkC,IAAzD,CAAZ;AAA4E,oBAAMF,CAAN;AAAU;AACnG;AACF;AACF;;AAED,WAAKzC,EAAL,GAAUqC,GAAV;AACA,UAAInM,CAAC,GAAG,KAAK+J,OAAL,CAAahD,QAAb,KAA0B,IAAlC;;AACA,cAAQmF,GAAG,CAACQ,MAAJ,IAAc,EAAtB;AACE,aAAK,SAAL;AACE,cAAI3B,CAAC,GAAG,EAAR;;AACA,eAAK,IAAI3J,CAAT,IAAcoK,CAAd,EAAiBT,CAAC,CAAC1E,IAAF,CAAOiD,QAAQ,CAAClI,CAAD,EAAI,SAAJ,CAAR,GAAyB,KAAzB,GAAiCsI,SAAS,CAAC8B,CAAC,CAACpK,CAAD,CAAF,CAAjD;;AACjB,iBAAO,IAAIoL,QAAJ,CAAaxM,CAAC,GAAG+K,CAAC,CAAC/I,IAAF,CAAO,KAAP,CAAjB,CAAP;;AACF,aAAK,gBAAL;AACE,iBAAO,IAAIwK,QAAJ,CAAaxM,CAAC,GAAG,mBAAJ,GAA0B0J,SAAS,CAAC8B,CAAD,CAAhD,CAAP;;AACF,aAAK,EAAL;AACE,iBAAO,IAAIgB,QAAJ,CAAaxM,CAAC,GAAG,SAAJ,GAAgB0J,SAAS,CAAC8B,CAAD,CAAtC,CAAP;;AACF;AACE,iBAAO,IAAIgB,QAAJ,CAAa,GAAb,EAAkBxM,CAAC,GAAGsJ,QAAQ,CAAC4C,GAAG,CAACQ,MAAL,EAAa,GAAb,CAAZ,GAAgC,KAAhC,GAAwChD,SAAS,CAAC8B,CAAD,CAAnE,CAAP;AAVJ;AAYD,KAzDD;;AA4DA,WAAO7O,aAAP;AACC,GApxDgB,EAAjB;AAqxDA;;;AAGA,MAAIgQ,+BAA+B,GAAG,YAAW;AAChD,WAAOhR,WAAW,CAAE,yBAAF,EAA6B,2BAA7B,CAAlB;AACA,GAFD;;AAOA,MAAIiR,qBAAqB,GAAG,UAAUC,IAAV,EAAiB;AAC5C1Q,IAAAA,QAAQ,CACP,0BADO,EAEP,+CAFO,EAGP0Q,IAAI,CAACC,UAAL,CAAgBC,MAAhB,IAA0BF,IAAI,CAACG,GAAL,CAAU,6BAAV,MAA8CC,SAHjE,EAIP;AACCtD,MAAAA,MAAM,EAAEkD,IAAI,CAAClD;AADd,KAJO,CAAR;AAQA,GATD;;AAcA,MAAIuD,uBAAuB,GAAG,UAAUC,IAAV,EAAgBrO,KAAhB,EAAwB;AACrDqO,IAAAA,IAAI,GAAGA,IAAI,CAACnL,IAAL,CAAW,GAAX,CAAP;AACA7F,IAAAA,QAAQ,CAAE,mBAAF,EAAuB,4CAAvB,EACP2C,KAAK,KAAKmO,SADH,EACc;AAAEE,MAAAA,IAAI,EAAEA;AAAR,KADd,CAAR;AAEA,GAJD;;AASA,MAAIC,mBAAmB,GAAG,UAAUD,IAAV,EAAgBrO,KAAhB,EAAwB;AACjDqO,IAAAA,IAAI,GAAGA,IAAI,CAACnL,IAAL,CAAW,GAAX,CAAP;AACA7F,IAAAA,QAAQ,CACP,mBADO,EAEP,wDAFO,EAGP,OAAO2C,KAAP,KAAiB,QAHV,EAIP;AACCzB,MAAAA,QAAQ,EAAE,UADX;AAEC8P,MAAAA,IAAI,EAAEA;AAFP,KAJO,CAAR;AASA,GAXD;;AAgBA,MAAIE,qCAAqC,GAAG,UAAUvO,KAAV,EAAiBpB,IAAjB,EAAwB;AACnEnB,IAAAA,qBAAqB,CACpBuC,KADoB,EAEpBpB,IAFoB,EAGpBoB,KAAK,KAAKmO,SAAV,IAAuBpR,aAAa,CAAEiD,KAAF,CAApC,IAAiDqI,KAAK,CAACmG,OAAN,CAAexO,KAAf,CAH7B,EAIpB,uBAJoB,CAArB;AAMA,GAPD;;AAYA,MAAIyO,kBAAkB,GAAG,UAAUC,SAAV,EAAsB;AAC9C,WAAO,SAASC,gBAAT,CAA2BC,SAA3B,EAAuC;AAC7C,UAAK,OAAOA,SAAP,KAAqB,QAArB,IAAiC,OAAOA,SAAP,KAAqB,QAA3D,EAAsE;AACrEA,QAAAA,SAAS,GAAG,GAAGpG,KAAH,CAASqD,IAAT,CAAe5M,SAAf,EAA0B,CAA1B,CAAZ;AACA;;AACDsP,MAAAA,qCAAqC,CAAEK,SAAF,EAAa,WAAb,CAArC;AACA,aAAOF,SAAS,CAAEE,SAAF,CAAhB;AACA,KAND;AAOA,GARD;;AAaA,MAAIC,2BAA2B,GAAG,UAAUd,IAAV,EAAgBe,gBAAhB,EAAmC;AACpE,QAAIjE,MAAM,GAAGkD,IAAI,CAAClD,MAAlB;AAAA,QACCkE,YAAY,GAAGD,gBAAgB,CAAC7G,QADjC;;AAGA6G,IAAAA,gBAAgB,CAAC7G,QAAjB,GAA4B,YAAW;AACtC,UAAI+G,QAAJ;AAAA,UAAcC,SAAd;AAAA,UAAyBpO,MAAzB;AAAA,UACC+L,IAAI,GAAG,EADR,CADsC,CAItC;;AACA/L,MAAAA,MAAM,GAAGkO,YAAY,CAAClD,IAAb,CAAmBiD,gBAAnB,CAAT;;AAEA,UAAK,WAAWzE,IAAX,CAAiBxJ,MAAjB,CAAL,EAAiC;AAChC+L,QAAAA,IAAI,CAACtB,MAAL,GAAc,sBAAd;AACA;;AAED,UAAK,WAAWjB,IAAX,CAAiBxJ,MAAjB,CAAL,EAAiC;AAChC+L,QAAAA,IAAI,CAACpB,MAAL,GAAc,sBAAd;AACA;;AAED,UAAK,WAAWnB,IAAX,CAAiBxJ,MAAjB,CAAL,EAAiC;AAChC+L,QAAAA,IAAI,CAACb,MAAL,GAAc,sBAAd;AACA;;AAEDlL,MAAAA,MAAM,CAACsH,OAAP,CAAgB,yCAAhB,EAA2D,UAAU+G,KAAV,EAAkB;AAC5EtC,QAAAA,IAAI,CAAC1B,WAAL,GAAmB,MAClB,IADkB,GACXL,MADW,GACF,kBADE,GACmBA,MADnB,GAC4B,uBAD5B,GAElB,GAFD;AAGA,eAAOqE,KAAP;AACA,OALD;AAOAF,MAAAA,QAAQ,GAAGG,MAAM,CAAC1C,IAAP,CAAaG,IAAb,EAAoB1J,IAApB,CAA0B,IAA1B,CAAX;AACA+L,MAAAA,SAAS,GAAGE,MAAM,CAAC1C,IAAP,CAAaG,IAAb,EAAoBwC,GAApB,CAAwB,UAAUjO,GAAV,EAAgB;AACnD,eAAOyL,IAAI,CAAEzL,GAAF,CAAX;AACA,OAFW,EAET+B,IAFS,CAEH,IAFG,CAAZ;AAIA,aAAO,gBAAgB8L,QAAhB,GAA2B,QAA3B,GACN,WADM,GACQnO,MADR,GACiB,IADjB,GAEN,KAFM,GAEEoO,SAFF,GAEc,GAFrB;AAGA,KAlCD;;AAoCA,WAAOH,gBAAP;AACA,GAzCD;;AA8CA,MAAItG,KAAK,GAAG,GAAGA,KAAf;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA9L,EAAAA,SAAS,CAAC2S,YAAV,GAAyB,UAAUC,IAAV,EAAiB;AACzC,QAAIzE,MAAJ;AAAA,QACC0E,UAAU,GAAG;AACZ,4BAAsBD,IADV;AAEZ,cAAQ;AAFI,KADd;AAMA/R,IAAAA,yBAAyB,CAAE+R,IAAF,EAAQ,MAAR,CAAzB;AACA3R,IAAAA,gCAAgC,CAAE2R,IAAF,EAAQ,MAAR,CAAhC,CARyC,CAUzC;;AACA,SAAMzE,MAAN,IAAgByE,IAAhB,EAAuB;AACtB,UAAKA,IAAI,CAAC1D,cAAL,CAAqBf,MAArB,CAAL,EAAqC;AACpC0E,QAAAA,UAAU,CAACC,IAAX,CAAiB3E,MAAjB,IAA4B,EAA5B;AACA;AACD;;AAEDpO,IAAAA,IAAI,CAACgT,IAAL,CAAWF,UAAX;AACA,GAlBD;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA7S,EAAAA,SAAS,CAACiS,gBAAV,GACAjS,SAAS,CAAC0B,SAAV,CAAoBuQ,gBAApB,GAAuC,UAAUN,IAAV,EAAiB;AACvD,QAAIN,IAAJ;AAAA,QAAUW,SAAV;AAAA,QAAqBpQ,OAArB;AAAA,QAA8BoR,eAA9B;AAAA,QAA+CC,QAA/C;AAAA,QACC/C,IAAI,GAAGpE,KAAK,CAACqD,IAAN,CAAY5M,SAAZ,EAAuB,CAAvB,CADR;AAGA1B,IAAAA,yBAAyB,CAAE8Q,IAAF,EAAQ,MAAR,CAAzB;AACA5Q,IAAAA,qBAAqB,CAAE4Q,IAAF,EAAQ,MAAR,EAAgB,OAAOA,IAAP,KAAgB,QAAhB,IAA4BhG,KAAK,CAACmG,OAAN,CAAeH,IAAf,CAA5C,EACpB,uBADoB,CAArB;AAGAA,IAAAA,IAAI,GAAG1R,WAAW,CAAE0R,IAAF,CAAlB;AACAN,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AAEA5Q,IAAAA,qBAAqB,CAAE4Q,IAAF,CAArB;AACAD,IAAAA,qBAAqB,CAAEC,IAAF,CAArB;AAEAzP,IAAAA,OAAO,GAAGyP,IAAI,CAACG,GAAL,CAAU,CAAE,6BAAF,EAAkCpB,MAAlC,CAA0CuB,IAA1C,CAAV,CAAV;AACAD,IAAAA,uBAAuB,CAAEC,IAAF,EAAQ/P,OAAR,CAAvB,CAfuD,CAiBvD;;AACA,QAAK+J,KAAK,CAACmG,OAAN,CAAelQ,OAAf,CAAL,EAAgC;AAC/BA,MAAAA,OAAO,GAAGA,OAAO,CAAC4E,IAAR,CAAc,GAAd,CAAV;AACA;;AACDoL,IAAAA,mBAAmB,CAAED,IAAF,EAAQ/P,OAAR,CAAnB,CArBuD,CAuBvD;;AACAoR,IAAAA,eAAe,GAAG,KAAKlE,MAAL,KAAgB2C,SAAhB,GACjB,KAAKuB,eAAL,EADiB,GAEjB7B,+BAFD;AAIAa,IAAAA,SAAS,GAAG,IAAI7Q,aAAJ,CAAmBkQ,IAAI,CAAClD,MAAxB,EAAgC6E,eAAhC,EAAkDxC,OAAlD,CAA2D5O,OAA3D,CAAZ;AAEAqR,IAAAA,QAAQ,GAAGlB,kBAAkB,CAAEC,SAAF,CAA7B;AAEAzR,IAAAA,WAAW,CAAE2P,IAAF,EAAQmB,IAAR,EAAc4B,QAAd,EACV,CAAEd,2BAA2B,CAAEd,IAAF,EAAQW,SAAR,CAA7B,EAAkDgB,eAAlD,CADU,CAAX;AAGA,WAAOC,QAAP;AACA,GArCD;AAuCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAjT,EAAAA,SAAS,CAACkT,aAAV,GACAlT,SAAS,CAAC0B,SAAV,CAAoBwR,aAApB,GAAoC,UAAUvB;AAAK;AAAf,IAAmC;AACtE,WAAO,KAAKM,gBAAL,CAAuBN,IAAvB,EAA8BwB,KAA9B,CAAqC,EAArC,EAAyCrH,KAAK,CAACqD,IAAN,CAAY5M,SAAZ,EAAuB,CAAvB,CAAzC,CAAP;AACA,GAHD;;AAKA,SAAOvC,SAAP;AAKC,CA5gEA,CAAD","sourcesContent":["/**\n * Globalize v1.7.0\n *\n * https://github.com/globalizejs/globalize\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2021-08-02T11:53Z\n */\n/*!\n * Globalize v1.7.0 2021-08-02T11:53Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function( root, factory ) {\n\n\t// UMD returnExports\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD\n\t\tdefine([\n\t\t\t\"cldr\",\n\t\t\t\"../globalize\",\n\t\t\t\"cldr/event\"\n\t\t], factory );\n\t} else if ( typeof exports === \"object\" ) {\n\n\t\t// Node, CommonJS\n\t\tmodule.exports = factory( require( \"cldrjs\" ), require( \"../globalize\" ) );\n\t} else {\n\n\t\t// Extend global\n\t\tfactory( root.Cldr, root.Globalize );\n\t}\n}(this, function( Cldr, Globalize ) {\n\nvar alwaysArray = Globalize._alwaysArray,\n\tcreateError = Globalize._createError,\n\tisPlainObject = Globalize._isPlainObject,\n\truntimeBind = Globalize._runtimeBind,\n\tvalidateDefaultLocale = Globalize._validateDefaultLocale,\n\tvalidate = Globalize._validate,\n\tvalidateParameterPresence = Globalize._validateParameterPresence,\n\tvalidateParameterType = Globalize._validateParameterType,\n\tvalidateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;\nvar MessageFormat;\n/* eslint-disable */\nMessageFormat = (function() {\nMessageFormat._parse = (function() {\n\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = [],\n        peg$c1 = function(st) {\n              return { type: 'messageFormatPattern', statements: st };\n            },\n        peg$c2 = peg$FAILED,\n        peg$c3 = \"{\",\n        peg$c4 = { type: \"literal\", value: \"{\", description: \"\\\"{\\\"\" },\n        peg$c5 = null,\n        peg$c6 = \",\",\n        peg$c7 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n        peg$c8 = \"}\",\n        peg$c9 = { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\n        peg$c10 = function(argIdx, efmt) {\n              var res = {\n                type: \"messageFormatElement\",\n                argumentIndex: argIdx\n              };\n              if (efmt && efmt.length) {\n                res.elementFormat = efmt[1];\n              } else {\n                res.output = true;\n              }\n              return res;\n            },\n        peg$c11 = \"plural\",\n        peg$c12 = { type: \"literal\", value: \"plural\", description: \"\\\"plural\\\"\" },\n        peg$c13 = function(t, s) {\n              return { type: \"elementFormat\", key: t, val: s };\n            },\n        peg$c14 = \"selectordinal\",\n        peg$c15 = { type: \"literal\", value: \"selectordinal\", description: \"\\\"selectordinal\\\"\" },\n        peg$c16 = \"select\",\n        peg$c17 = { type: \"literal\", value: \"select\", description: \"\\\"select\\\"\" },\n        peg$c18 = function(t, p) {\n              return { type: \"elementFormat\", key: t, val: p };\n            },\n        peg$c19 = function(op, pf) {\n              return { type: \"pluralFormatPattern\", pluralForms: pf, offset: op || 0 };\n            },\n        peg$c20 = \"offset\",\n        peg$c21 = { type: \"literal\", value: \"offset\", description: \"\\\"offset\\\"\" },\n        peg$c22 = \":\",\n        peg$c23 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n        peg$c24 = function(d) { return d; },\n        peg$c25 = function(k, mfp) {\n              return { key: k, val: mfp };\n            },\n        peg$c26 = function(i) { return i; },\n        peg$c27 = \"=\",\n        peg$c28 = { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n        peg$c29 = function(pf) { return { type: \"selectFormatPattern\", pluralForms: pf }; },\n        peg$c30 = function(p) { return p; },\n        peg$c31 = \"#\",\n        peg$c32 = { type: \"literal\", value: \"#\", description: \"\\\"#\\\"\" },\n        peg$c33 = function() { return {type: 'octothorpe'}; },\n        peg$c34 = function(s) { return { type: \"string\", val: s.join('') }; },\n        peg$c35 = { type: \"other\", description: \"identifier\" },\n        peg$c36 = /^[0-9a-zA-Z$_]/,\n        peg$c37 = { type: \"class\", value: \"[0-9a-zA-Z$_]\", description: \"[0-9a-zA-Z$_]\" },\n        peg$c38 = /^[^ \\t\\n\\r,.+={}]/,\n        peg$c39 = { type: \"class\", value: \"[^ \\\\t\\\\n\\\\r,.+={}]\", description: \"[^ \\\\t\\\\n\\\\r,.+={}]\" },\n        peg$c40 = function(s) { return s; },\n        peg$c41 = function(chars) { return chars.join(''); },\n        peg$c42 = /^[^{}#\\\\\\0-\\x1F \\t\\n\\r]/,\n        peg$c43 = { type: \"class\", value: \"[^{}#\\\\\\\\\\\\0-\\\\x1F \\\\t\\\\n\\\\r]\", description: \"[^{}#\\\\\\\\\\\\0-\\\\x1F \\\\t\\\\n\\\\r]\" },\n        peg$c44 = function(x) { return x; },\n        peg$c45 = \"\\\\\\\\\",\n        peg$c46 = { type: \"literal\", value: \"\\\\\\\\\", description: \"\\\"\\\\\\\\\\\\\\\\\\\"\" },\n        peg$c47 = function() { return \"\\\\\"; },\n        peg$c48 = \"\\\\#\",\n        peg$c49 = { type: \"literal\", value: \"\\\\#\", description: \"\\\"\\\\\\\\#\\\"\" },\n        peg$c50 = function() { return \"#\"; },\n        peg$c51 = \"\\\\{\",\n        peg$c52 = { type: \"literal\", value: \"\\\\{\", description: \"\\\"\\\\\\\\{\\\"\" },\n        peg$c53 = function() { return \"\\u007B\"; },\n        peg$c54 = \"\\\\}\",\n        peg$c55 = { type: \"literal\", value: \"\\\\}\", description: \"\\\"\\\\\\\\}\\\"\" },\n        peg$c56 = function() { return \"\\u007D\"; },\n        peg$c57 = \"\\\\u\",\n        peg$c58 = { type: \"literal\", value: \"\\\\u\", description: \"\\\"\\\\\\\\u\\\"\" },\n        peg$c59 = function(h1, h2, h3, h4) {\n              return String.fromCharCode(parseInt(\"0x\" + h1 + h2 + h3 + h4));\n            },\n        peg$c60 = /^[0-9]/,\n        peg$c61 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n        peg$c62 = function(ds) {\n            //the number might start with 0 but must not be interpreted as an octal number\n            //Hence, the base is passed to parseInt explicitely\n            return parseInt((ds.join('')), 10);\n          },\n        peg$c63 = /^[0-9a-fA-F]/,\n        peg$c64 = { type: \"class\", value: \"[0-9a-fA-F]\", description: \"[0-9a-fA-F]\" },\n        peg$c65 = { type: \"other\", description: \"whitespace\" },\n        peg$c66 = function(w) { return w.join(''); },\n        peg$c67 = /^[ \\t\\n\\r]/,\n        peg$c68 = { type: \"class\", value: \"[ \\\\t\\\\n\\\\r]\", description: \"[ \\\\t\\\\n\\\\r]\" },\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$parsestart() {\n      var s0;\n\n      s0 = peg$parsemessageFormatPattern();\n\n      return s0;\n    }\n\n    function peg$parsemessageFormatPattern() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsemessageFormatElement();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsestring();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseoctothorpe();\n        }\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsemessageFormatElement();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsestring();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseoctothorpe();\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c1(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsemessageFormatElement() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s1 = peg$c3;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c4); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseid();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c6;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c7); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseelementFormat();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c2;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c2;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = peg$c5;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 125) {\n                  s6 = peg$c8;\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c9); }\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$reportedPos = s0;\n                  s1 = peg$c10(s3, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      return s0;\n    }\n\n    function peg$parseelementFormat() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 6) === peg$c11) {\n          s2 = peg$c11;\n          peg$currPos += 6;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c12); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s4 = peg$c6;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c7); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsepluralFormatPattern();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_();\n                  if (s7 !== peg$FAILED) {\n                    peg$reportedPos = s0;\n                    s1 = peg$c13(s2, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 13) === peg$c14) {\n            s2 = peg$c14;\n            peg$currPos += 13;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c15); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s4 = peg$c6;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c7); }\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parse_();\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parsepluralFormatPattern();\n                  if (s6 !== peg$FAILED) {\n                    s7 = peg$parse_();\n                    if (s7 !== peg$FAILED) {\n                      peg$reportedPos = s0;\n                      s1 = peg$c13(s2, s6);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n          if (s1 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 6) === peg$c16) {\n              s2 = peg$c16;\n              peg$currPos += 6;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c17); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n              if (s3 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s4 = peg$c6;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c7); }\n                }\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parse_();\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parseselectFormatPattern();\n                    if (s6 !== peg$FAILED) {\n                      s7 = peg$parse_();\n                      if (s7 !== peg$FAILED) {\n                        peg$reportedPos = s0;\n                        s1 = peg$c13(s2, s6);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parse_();\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parseid();\n              if (s2 !== peg$FAILED) {\n                s3 = [];\n                s4 = peg$parseargStylePattern();\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n                  s4 = peg$parseargStylePattern();\n                }\n                if (s3 !== peg$FAILED) {\n                  peg$reportedPos = s0;\n                  s1 = peg$c18(s2, s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsepluralFormatPattern() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parseoffsetPattern();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c5;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsepluralForm();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsepluralForm();\n          }\n        } else {\n          s2 = peg$c2;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c19(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      return s0;\n    }\n\n    function peg$parseoffsetPattern() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 6) === peg$c20) {\n          s2 = peg$c20;\n          peg$currPos += 6;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 58) {\n              s4 = peg$c22;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsedigits();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_();\n                  if (s7 !== peg$FAILED) {\n                    peg$reportedPos = s0;\n                    s1 = peg$c24(s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      return s0;\n    }\n\n    function peg$parsepluralForm() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsepluralKey();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 123) {\n              s4 = peg$c3;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c4); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsemessageFormatPattern();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_();\n                  if (s7 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 125) {\n                      s8 = peg$c8;\n                      peg$currPos++;\n                    } else {\n                      s8 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c9); }\n                    }\n                    if (s8 !== peg$FAILED) {\n                      peg$reportedPos = s0;\n                      s1 = peg$c25(s2, s6);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      return s0;\n    }\n\n    function peg$parsepluralKey() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$parseid();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c26(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s1 = peg$c27;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsedigits();\n          if (s2 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c24(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseselectFormatPattern() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseselectForm();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseselectForm();\n        }\n      } else {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c29(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseselectForm() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseid();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 123) {\n              s4 = peg$c3;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c4); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsemessageFormatPattern();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_();\n                  if (s7 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 125) {\n                      s8 = peg$c8;\n                      peg$currPos++;\n                    } else {\n                      s8 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c9); }\n                    }\n                    if (s8 !== peg$FAILED) {\n                      peg$reportedPos = s0;\n                      s1 = peg$c25(s2, s6);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      return s0;\n    }\n\n    function peg$parseargStylePattern() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c6;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c7); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseid();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c30(s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      return s0;\n    }\n\n    function peg$parseoctothorpe() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 35) {\n        s1 = peg$c31;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c33();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsestring() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsechars();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsewhitespace();\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsechars();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsewhitespace();\n          }\n        }\n      } else {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c34(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseid() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$currPos;\n        if (peg$c36.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c37); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = [];\n          if (peg$c38.test(input.charAt(peg$currPos))) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c39); }\n          }\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            if (peg$c38.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c39); }\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c2;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s3 = input.substring(s2, peg$currPos);\n        }\n        s2 = s3;\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c40(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c35); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsechars() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsechar();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsechar();\n        }\n      } else {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c41(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsechar() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (peg$c42.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c43); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c44(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2) === peg$c45) {\n          s1 = peg$c45;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c46); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c47();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 2) === peg$c48) {\n            s1 = peg$c48;\n            peg$currPos += 2;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c49); }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c50();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 2) === peg$c51) {\n              s1 = peg$c51;\n              peg$currPos += 2;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c52); }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c53();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.substr(peg$currPos, 2) === peg$c54) {\n                s1 = peg$c54;\n                peg$currPos += 2;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c55); }\n              }\n              if (s1 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c56();\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                if (input.substr(peg$currPos, 2) === peg$c57) {\n                  s1 = peg$c57;\n                  peg$currPos += 2;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                }\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$parsehexDigit();\n                  if (s2 !== peg$FAILED) {\n                    s3 = peg$parsehexDigit();\n                    if (s3 !== peg$FAILED) {\n                      s4 = peg$parsehexDigit();\n                      if (s4 !== peg$FAILED) {\n                        s5 = peg$parsehexDigit();\n                        if (s5 !== peg$FAILED) {\n                          peg$reportedPos = s0;\n                          s1 = peg$c59(s2, s3, s4, s5);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c2;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsedigits() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c60.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c61); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c60.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c61); }\n          }\n        }\n      } else {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c62(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsehexDigit() {\n      var s0;\n\n      if (peg$c63.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c64); }\n      }\n\n      return s0;\n    }\n\n    function peg$parse_() {\n      var s0, s1, s2;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsewhitespace();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewhitespace();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c66(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c65); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsewhitespace() {\n      var s0;\n\n      if (peg$c67.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c68); }\n      }\n\n      return s0;\n    }\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       parse\n  };\n}()).parse;\n\n\n/** @file messageformat.js - ICU PluralFormat + SelectFormat for JavaScript\n *  @author Alex Sexton - @SlexAxton\n *  @version 0.3.0-1\n *  @copyright 2012-2015 Alex Sexton, Eemeli Aro, and Contributors\n *  @license To use or fork, MIT. To contribute back, Dojo CLA  */\n\n\n/** Utility function for quoting an Object's key value iff required\n *  @private  */\nfunction propname(key, obj) {\n  if (/^[A-Z_$][0-9A-Z_$]*$/i.test(key)) {\n    return obj ? obj + '.' + key : key;\n  } else {\n    var jkey = JSON.stringify(key);\n    return obj ? obj + '[' + jkey + ']' : jkey;\n  }\n};\n\n\n/** Create a new message formatter\n *\n *  @class\n *  @global\n *  @param {string|string[]} [locale=\"en\"] - The locale to use, with fallbacks\n *  @param {function} [pluralFunc] - Optional custom pluralization function\n *  @param {function[]} [formatters] - Optional custom formatting functions  */\nfunction MessageFormat(locale, pluralFunc, formatters) {\n  this.lc = [locale];  \n  this.runtime.pluralFuncs = {};\n  this.runtime.pluralFuncs[this.lc[0]] = pluralFunc;\n  this.runtime.fmt = {};\n  if (formatters) for (var f in formatters) {\n    this.runtime.fmt[f] = formatters[f];\n  }\n}\n\n\n\n\n/** Parse an input string to its AST\n *\n *  Precompiled from `lib/messageformat-parser.pegjs` by\n *  {@link http://pegjs.org/ PEG.js}. Included in MessageFormat object\n *  to enable testing.\n *\n *  @private  */\n\n\n\n/** Pluralization functions from\n *  {@link http://github.com/eemeli/make-plural.js make-plural}\n *\n *  @memberof MessageFormat\n *  @type Object.<string,function>  */\nMessageFormat.plurals = {};\n\n\n/** Default number formatting functions in the style of ICU's\n *  {@link http://icu-project.org/apiref/icu4j/com/ibm/icu/text/MessageFormat.html simpleArg syntax}\n *  implemented using the\n *  {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl Intl}\n *  object defined by ECMA-402.\n *\n *  **Note**: Intl is not defined in default Node until 0.11.15 / 0.12.0, so\n *  earlier versions require a {@link https://www.npmjs.com/package/intl polyfill}.\n *  Therefore {@link MessageFormat.withIntlSupport} needs to be true for these\n *  functions to be available for inclusion in the output.\n *\n *  @see MessageFormat#setIntlSupport\n *\n *  @namespace\n *  @memberof MessageFormat\n *  @property {function} number - Represent a number as an integer, percent or currency value\n *  @property {function} date - Represent a date as a full/long/default/short string\n *  @property {function} time - Represent a time as a full/long/default/short string\n *\n *  @example\n *  > var MessageFormat = require('messageformat');\n *  > var mf = (new MessageFormat('en')).setIntlSupport(true);\n *  > mf.currency = 'EUR';\n *  > var mfunc = mf.compile(\"The total is {V,number,currency}.\");\n *  > mfunc({V:5.5})\n *  \"The total is 5.50.\"\n *\n *  @example\n *  > var MessageFormat = require('messageformat');\n *  > var mf = new MessageFormat('en', null, {number: MessageFormat.number});\n *  > mf.currency = 'EUR';\n *  > var mfunc = mf.compile(\"The total is {V,number,currency}.\");\n *  > mfunc({V:5.5})\n *  \"The total is 5.50.\"  */\nMessageFormat.formatters = {};\n\n/** Enable or disable support for the default formatters, which require the\n *  `Intl` object. Note that this can't be autodetected, as the environment\n *  in which the formatted text is compiled into Javascript functions is not\n *  necessarily the same environment in which they will get executed.\n *\n *  @see MessageFormat.formatters\n *\n *  @memberof MessageFormat\n *  @param {boolean} [enable=true]\n *  @returns {Object} The MessageFormat instance, to allow for chaining\n *  @example\n *  > var Intl = require('intl');\n *  > var MessageFormat = require('messageformat');\n *  > var mf = (new MessageFormat('en')).setIntlSupport(true);\n *  > mf.currency = 'EUR';\n *  > mf.compile(\"The total is {V,number,currency}.\")({V:5.5});\n *  \"The total is 5.50.\"  */\n\n\n\n/** A set of utility functions that are called by the compiled Javascript\n *  functions, these are included locally in the output of {@link\n *  MessageFormat#compile compile()}.\n *\n *  @namespace\n *  @memberof MessageFormat  */\nMessageFormat.prototype.runtime = {\n\n  /** Utility function for `#` in plural rules\n   *\n   *  @param {number} value - The value to operate on\n   *  @param {number} [offset=0] - An optional offset, set by the surrounding context  */\n  number: function(value, offset) {\n    if (isNaN(value)) throw new Error(\"'\" + value + \"' isn't a number.\");\n    return value - (offset || 0);\n  },\n\n  /** Utility function for `{N, plural|selectordinal, ...}`\n   *\n   *  @param {number} value - The key to use to find a pluralization rule\n   *  @param {number} offset - An offset to apply to `value`\n   *  @param {function} lcfunc - A locale function from `pluralFuncs`\n   *  @param {Object.<string,string>} data - The object from which results are looked up\n   *  @param {?boolean} isOrdinal - If true, use ordinal rather than cardinal rules\n   *  @returns {string} The result of the pluralization  */\n  plural: function(value, offset, lcfunc, data, isOrdinal) {\n    if ({}.hasOwnProperty.call(data, value)) return data[value]();\n    if (offset) value -= offset;\n    var key = lcfunc(value, isOrdinal);\n    if (key in data) return data[key]();\n    return data.other();\n  },\n\n  /** Utility function for `{N, select, ...}`\n   *\n   *  @param {number} value - The key to use to find a selection\n   *  @param {Object.<string,string>} data - The object from which results are looked up\n   *  @returns {string} The result of the select statement  */\n  select: function(value, data) {\n    if ({}.hasOwnProperty.call(data, value)) return data[value]();\n    return data.other()\n  },\n\n  /** Pluralization functions included in compiled output\n   *  @instance\n   *  @type Object.<string,function>  */\n  pluralFuncs: {},\n\n  /** Custom formatting functions called by `{var, fn[, args]*}` syntax\n   *\n   *  For examples, see {@link MessageFormat.formatters}\n   *\n   *  @instance\n   *  @see MessageFormat.formatters\n   *  @type Object.<string,function>  */\n  fmt: {},\n\n  /** Custom stringifier to clean up browser inconsistencies\n   *  @instance  */\n  toString: function () {\n    var _stringify = function(o, level) {\n      if (typeof o != 'object') {\n        var funcStr = o.toString().replace(/^(function )\\w*/, '$1');\n        var indent = /([ \\t]*)\\S.*$/.exec(funcStr);\n        return indent ? funcStr.replace(new RegExp('^' + indent[1], 'mg'), '') : funcStr;\n      }\n      var s = [];\n      for (var i in o) if (i != 'toString') {\n        if (level == 0) s.push('var ' + i + ' = ' + _stringify(o[i], level + 1) + ';\\n');\n        else s.push(propname(i) + ': ' + _stringify(o[i], level + 1));\n      }\n      if (level == 0) return s.join('');\n      if (s.length == 0) return '{}';\n      var indent = '  '; while (--level) indent += '  ';\n      return '{\\n' + s.join(',\\n').replace(/^/gm, indent) + '\\n}';\n    };\n    return _stringify(this, 0);\n  }\n};\n\n\n/** Recursively map an AST to its resulting string\n *\n *  @memberof MessageFormat\n *\n *  @param ast - the Ast node for which the JS code should be generated\n *\n *  @private  */\nMessageFormat.prototype._precompile = function(ast, data) {\n  data = data || { keys: {}, offset: {} };\n  var r = [], i, tmp, args = [];\n\n  switch ( ast.type ) {\n    case 'messageFormatPattern':\n      for ( i = 0; i < ast.statements.length; ++i ) {\n        r.push(this._precompile( ast.statements[i], data ));\n      }\n      tmp = r.join(' + ') || '\"\"';\n      return data.pf_count ? tmp : 'function(d) { return ' + tmp + '; }';\n\n    case 'messageFormatElement':\n      data.pf_count = data.pf_count || 0;\n      if ( ast.output ) {\n        return propname(ast.argumentIndex, 'd');\n      }\n      else {\n        data.keys[data.pf_count] = ast.argumentIndex;\n        return this._precompile( ast.elementFormat, data );\n      }\n      return '';\n\n    case 'elementFormat':\n      args = [ propname(data.keys[data.pf_count], 'd') ];\n      switch (ast.key) {\n        case 'select':\n          args.push(this._precompile(ast.val, data));\n          return 'select(' + args.join(', ') + ')';\n        case 'selectordinal':\n          args = args.concat([ 0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data), 1 ]);\n          return 'plural(' + args.join(', ') + ')';\n        case 'plural':\n          data.offset[data.pf_count || 0] = ast.val.offset || 0;\n          args = args.concat([ data.offset[data.pf_count] || 0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data) ]);\n          return 'plural(' + args.join(', ') + ')';\n        default:\n          if (this.withIntlSupport && !(ast.key in this.runtime.fmt) && (ast.key in MessageFormat.formatters)) {\n            tmp = MessageFormat.formatters[ast.key];\n            this.runtime.fmt[ast.key] = (typeof tmp(this) == 'function') ? tmp(this) : tmp;\n          }\n          args.push(JSON.stringify(this.lc));\n          if (ast.val && ast.val.length) args.push(JSON.stringify(ast.val.length == 1 ? ast.val[0] : ast.val));\n          return 'fmt.' + ast.key + '(' + args.join(', ') + ')';\n      }\n\n    case 'pluralFormatPattern':\n    case 'selectFormatPattern':\n      data.pf_count = data.pf_count || 0;\n      if (ast.type == 'selectFormatPattern') data.offset[data.pf_count] = 0;\n      var needOther = true;\n      for (i = 0; i < ast.pluralForms.length; ++i) {\n        var key = ast.pluralForms[i].key;\n        if (key === 'other') needOther = false;\n        var data_copy = JSON.parse(JSON.stringify(data));\n        data_copy.pf_count++;\n        r.push(propname(key) + ': function() { return ' + this._precompile(ast.pluralForms[i].val, data_copy) + ';}');\n      }\n      if (needOther) throw new Error(\"No 'other' form found in \" + ast.type + \" \" + data.pf_count);\n      return '{ ' + r.join(', ') + ' }';\n\n    case 'string':\n      return JSON.stringify(ast.val || \"\");\n\n    case 'octothorpe':\n      if (!data.pf_count) return '\"#\"';\n      args = [ propname(data.keys[data.pf_count-1], 'd') ];\n      if (data.offset[data.pf_count-1]) args.push(data.offset[data.pf_count-1]);\n      return 'number(' + args.join(', ') + ')';\n\n    default:\n      throw new Error( 'Bad AST type: ' + ast.type );\n  }\n};\n\n/** Compile messages into an executable function with clean string\n *  representation.\n *\n *  If `messages` is a single string including ICU MessageFormat declarations,\n *  `opt` is ignored and the returned function takes a single Object parameter\n *  `d` representing each of the input's defined variables. The returned\n *  function will be defined in a local scope that includes all the required\n *  runtime variables.\n *\n *  If `messages` is a map of keys to strings, or a map of namespace keys to\n *  such key/string maps, the returned function will fill the specified global\n *  with javascript functions matching the structure of the input. In such use,\n *  the output of `compile()` is expected to be serialized using `.toString()`,\n *  and will include definitions of the runtime functions. If `opt.global` is\n *  null, calling the output function will return the object itself.\n *\n *  Together, the input parameters should match the following patterns:\n *  ```js\n *  messages = \"string\" || { key0: \"string0\", key1: \"string1\", ... } || {\n *    ns0: { key0: \"string0\", key1: \"string1\", ...  },\n *    ns1: { key0: \"string0\", key1: \"string1\", ...  },\n *    ...\n *  }\n *\n *  opt = null || {\n *    locale: null || {\n *      ns0: \"lc0\" || [ \"lc0\", ... ],\n *      ns1: \"lc1\" || [ \"lc1\", ... ],\n *      ...\n *    },\n *    global: null || \"module.exports\" || \"exports\" || \"i18n\" || ...\n *  }\n *  ```\n *\n *  @memberof MessageFormat\n *  @param {string|Object}\n *      messages - The input message(s) to be compiled, in ICU MessageFormat\n *  @param {Object} [opt={}] - Options controlling output for non-simple intput\n *  @param {Object} [opt.locale] - The locales to use for the messages, with a\n *      structure matching that of `messages`\n *  @param {string} [opt.global=\"\"] - The global variable that the output\n *      function should use, or a null string for none. \"exports\" and\n *      \"module.exports\" are recognised as special cases.\n *  @returns {function} The first match found for the given locale(s)\n *\n *  @example\n * > var MessageFormat = require('messageformat'),\n * ...   mf = new MessageFormat('en'),\n * ...   mfunc0 = mf.compile('A {TYPE} example.');\n * > mfunc0({TYPE:'simple'})\n * 'A simple example.'\n * > mfunc0.toString()\n * 'function (d) { return \"A \" + d.TYPE + \" example.\"; }'\n *\n *  @example\n * > var msgSet = { a: 'A {TYPE} example.',\n * ...              b: 'This has {COUNT, plural, one{one member} other{# members}}.' },\n * ...   mfuncSet = mf.compile(msgSet);\n * > mfuncSet().a({TYPE:'more complex'})\n * 'A more complex example.'\n * > mfuncSet().b({COUNT:2})\n * 'This has 2 members.'\n *\n * > console.log(mfuncSet.toString())\n * function anonymous() {\n * var number = function (value, offset) {\n *   if (isNaN(value)) throw new Error(\"'\" + value + \"' isn't a number.\");\n *   return value - (offset || 0);\n * };\n * var plural = function (value, offset, lcfunc, data, isOrdinal) {\n *   if ({}.hasOwnProperty.call(data, value)) return data[value]();\n *   if (offset) value -= offset;\n *   var key = lcfunc(value, isOrdinal);\n *   if (key in data) return data[key]();\n *   return data.other();\n * };\n * var select = function (value, data) {\n *   if ({}.hasOwnProperty.call(data, value)) return data[value]();\n *   return data.other()\n * };\n * var pluralFuncs = {\n *   en: function (n, ord) {\n *     var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,\n *         n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);\n *     if (ord) return (n10 == 1 && n100 != 11) ? 'one'\n *         : (n10 == 2 && n100 != 12) ? 'two'\n *         : (n10 == 3 && n100 != 13) ? 'few'\n *         : 'other';\n *     return (n == 1 && v0) ? 'one' : 'other';\n *   }\n * };\n * var fmt = {};\n *\n * return {\n *   a: function(d) { return \"A \" + d.TYPE + \" example.\"; },\n *   b: function(d) { return \"This has \" + plural(d.COUNT, 0, pluralFuncs.en, { one: function() { return \"one member\";}, other: function() { return number(d.COUNT)+\" members\";} }) + \".\"; }\n * }\n * }\n *\n *  @example\n * > mf.runtime.pluralFuncs.fi = MessageFormat.plurals.fi;\n * > var multiSet = { en: { a: 'A {TYPE} example.',\n * ...                      b: 'This is the {COUNT, selectordinal, one{#st} two{#nd} few{#rd} other{#th}} example.' },\n * ...                fi: { a: '{TYPE} esimerkki.',\n * ...                      b: 'Tm on {COUNT, selectordinal, other{#.}} esimerkki.' } },\n * ...   multiSetLocales = { en: 'en', fi: 'fi' },\n * ...   mfuncSet = mf.compile(multiSet, { locale: multiSetLocales, global: 'i18n' });\n * > mfuncSet(this);\n * > i18n.en.b({COUNT:3})\n * 'This is the 3rd example.'\n * > i18n.fi.b({COUNT:3})\n * 'Tm on 3. esimerkki.'  */\nMessageFormat.prototype.compile = function ( messages, opt ) {\n  var r = {}, lc0 = this.lc,\n      compileMsg = function(self, msg) {\n        try {\n          var ast = MessageFormat._parse(msg);\n          return self._precompile(ast);\n        } catch (e) {\n          throw new Error((ast ? 'Precompiler' : 'Parser') + ' error: ' + e.toString());\n        }\n      },\n      stringify = function(r, level) {\n        if (!level) level = 0;\n        if (typeof r != 'object') return r;\n        var o = [], indent = '';\n        for (var i = 0; i < level; ++i) indent += '  ';\n        for (var k in r) o.push('\\n' + indent + '  ' + propname(k) + ': ' + stringify(r[k], level + 1));\n        return '{' + o.join(',') + '\\n' + indent + '}';\n      };\n\n  if (typeof messages == 'string') {\n    var f = new Function(\n        'number, plural, select, pluralFuncs, fmt',\n        'return ' + compileMsg(this, messages));\n    return f(this.runtime.number, this.runtime.plural, this.runtime.select,\n        this.runtime.pluralFuncs, this.runtime.fmt);\n  }\n\n  opt = opt || {};\n\n  for (var ns in messages) {\n    if (opt.locale) this.lc = opt.locale[ns] && [].concat(opt.locale[ns]) || lc0;\n    if (typeof messages[ns] == 'string') {\n      try { r[ns] = compileMsg(this, messages[ns]); }\n      catch (e) { e.message = e.message.replace(':', ' with `' + ns + '`:'); throw e; }\n    } else {\n      r[ns] = {};\n      for (var key in messages[ns]) {\n        try { r[ns][key] = compileMsg(this, messages[ns][key]); }\n        catch (e) { e.message = e.message.replace(':', ' with `' + key + '` in `' + ns + '`:'); throw e; }\n      }\n    }\n  }\n\n  this.lc = lc0;\n  var s = this.runtime.toString() + '\\n';\n  switch (opt.global || '') {\n    case 'exports':\n      var o = [];\n      for (var k in r) o.push(propname(k, 'exports') + ' = ' + stringify(r[k]));\n      return new Function(s + o.join(';\\n'));\n    case 'module.exports':\n      return new Function(s + 'module.exports = ' + stringify(r));\n    case '':\n      return new Function(s + 'return ' + stringify(r));\n    default:\n      return new Function('G', s + propname(opt.global, 'G') + ' = ' + stringify(r));\n  }\n};\n\n\nreturn MessageFormat;\n}());\n/* eslint-enable */\n\n\nvar createErrorPluralModulePresence = function() {\n\treturn createError( \"E_MISSING_PLURAL_MODULE\", \"Plural module not loaded.\" );\n};\n\n\n\n\nvar validateMessageBundle = function( cldr ) {\n\tvalidate(\n\t\t\"E_MISSING_MESSAGE_BUNDLE\",\n\t\t\"Missing message bundle for locale `{locale}`.\",\n\t\tcldr.attributes.bundle && cldr.get( \"globalize-messages/{bundle}\" ) !== undefined,\n\t\t{\n\t\t\tlocale: cldr.locale\n\t\t}\n\t);\n};\n\n\n\n\nvar validateMessagePresence = function( path, value ) {\n\tpath = path.join( \"/\" );\n\tvalidate( \"E_MISSING_MESSAGE\", \"Missing required message content `{path}`.\",\n\t\tvalue !== undefined, { path: path } );\n};\n\n\n\n\nvar validateMessageType = function( path, value ) {\n\tpath = path.join( \"/\" );\n\tvalidate(\n\t\t\"E_INVALID_MESSAGE\",\n\t\t\"Invalid message content `{path}`. {expected} expected.\",\n\t\ttypeof value === \"string\",\n\t\t{\n\t\t\texpected: \"a string\",\n\t\t\tpath: path\n\t\t}\n\t);\n};\n\n\n\n\nvar validateParameterTypeMessageVariables = function( value, name ) {\n\tvalidateParameterType(\n\t\tvalue,\n\t\tname,\n\t\tvalue === undefined || isPlainObject( value ) || Array.isArray( value ),\n\t\t\"Array or Plain Object\"\n\t);\n};\n\n\n\n\nvar messageFormatterFn = function( formatter ) {\n\treturn function messageFormatter( variables ) {\n\t\tif ( typeof variables === \"number\" || typeof variables === \"string\" ) {\n\t\t\tvariables = [].slice.call( arguments, 0 );\n\t\t}\n\t\tvalidateParameterTypeMessageVariables( variables, \"variables\" );\n\t\treturn formatter( variables );\n\t};\n};\n\n\n\n\nvar messageFormatterRuntimeBind = function( cldr, messageformatter ) {\n\tvar locale = cldr.locale,\n\t\torigToString = messageformatter.toString;\n\n\tmessageformatter.toString = function() {\n\t\tvar argNames, argValues, output,\n\t\t\targs = {};\n\n\t\t// Properly adjust SlexAxton/messageformat.js compiled variables with Globalize variables:\n\t\toutput = origToString.call( messageformatter );\n\n\t\tif ( /number\\(/.test( output ) ) {\n\t\t\targs.number = \"messageFormat.number\";\n\t\t}\n\n\t\tif ( /plural\\(/.test( output ) ) {\n\t\t\targs.plural = \"messageFormat.plural\";\n\t\t}\n\n\t\tif ( /select\\(/.test( output ) ) {\n\t\t\targs.select = \"messageFormat.select\";\n\t\t}\n\n\t\toutput.replace( /pluralFuncs(\\[([^\\]]+)\\]|\\.([a-zA-Z]+))/, function( match ) {\n\t\t\targs.pluralFuncs = \"{\" +\n\t\t\t\t\"\\\"\" + locale + \"\\\": Globalize(\\\"\" + locale + \"\\\").pluralGenerator()\" +\n\t\t\t\t\"}\";\n\t\t\treturn match;\n\t\t});\n\n\t\targNames = Object.keys( args ).join( \", \" );\n\t\targValues = Object.keys( args ).map(function( key ) {\n\t\t\treturn args[ key ];\n\t\t}).join( \", \" );\n\n\t\treturn \"(function( \" + argNames + \" ) {\\n\" +\n\t\t\t\"  return \" + output + \"\\n\" +\n\t\t\t\"})(\" + argValues + \")\";\n\t};\n\n\treturn messageformatter;\n};\n\n\n\n\nvar slice = [].slice;\n\n/**\n * .loadMessages( json )\n *\n * @json [JSON]\n *\n * Load translation data.\n */\nGlobalize.loadMessages = function( json ) {\n\tvar locale,\n\t\tcustomData = {\n\t\t\t\"globalize-messages\": json,\n\t\t\t\"main\": {}\n\t\t};\n\n\tvalidateParameterPresence( json, \"json\" );\n\tvalidateParameterTypePlainObject( json, \"json\" );\n\n\t// Set available bundles by populating customData main dataset.\n\tfor ( locale in json ) {\n\t\tif ( json.hasOwnProperty( locale ) ) {\n\t\t\tcustomData.main[ locale ] = {};\n\t\t}\n\t}\n\n\tCldr.load( customData );\n};\n\n/**\n * .messageFormatter( path )\n *\n * @path [String or Array]\n *\n * Format a message given its path.\n */\nGlobalize.messageFormatter =\nGlobalize.prototype.messageFormatter = function( path ) {\n\tvar cldr, formatter, message, pluralGenerator, returnFn,\n\t\targs = slice.call( arguments, 0 );\n\n\tvalidateParameterPresence( path, \"path\" );\n\tvalidateParameterType( path, \"path\", typeof path === \"string\" || Array.isArray( path ),\n\t\t\"a String nor an Array\" );\n\n\tpath = alwaysArray( path );\n\tcldr = this.cldr;\n\n\tvalidateDefaultLocale( cldr );\n\tvalidateMessageBundle( cldr );\n\n\tmessage = cldr.get( [ \"globalize-messages/{bundle}\" ].concat( path ) );\n\tvalidateMessagePresence( path, message );\n\n\t// If message is an Array, concatenate it.\n\tif ( Array.isArray( message ) ) {\n\t\tmessage = message.join( \" \" );\n\t}\n\tvalidateMessageType( path, message );\n\n\t// Is plural module present? Yes, use its generator. Nope, use an error generator.\n\tpluralGenerator = this.plural !== undefined ?\n\t\tthis.pluralGenerator() :\n\t\tcreateErrorPluralModulePresence;\n\n\tformatter = new MessageFormat( cldr.locale, pluralGenerator ).compile( message );\n\n\treturnFn = messageFormatterFn( formatter );\n\n\truntimeBind( args, cldr, returnFn,\n\t\t[ messageFormatterRuntimeBind( cldr, formatter ), pluralGenerator ] );\n\n\treturn returnFn;\n};\n\n/**\n * .formatMessage( path [, variables] )\n *\n * @path [String or Array]\n *\n * @variables [Number, String, Array or Object]\n *\n * Format a message given its path.\n */\nGlobalize.formatMessage =\nGlobalize.prototype.formatMessage = function( path /* , variables */ ) {\n\treturn this.messageFormatter( path ).apply( {}, slice.call( arguments, 1 ) );\n};\n\nreturn Globalize;\n\n\n\n\n}));\n"]},"metadata":{},"sourceType":"script"}